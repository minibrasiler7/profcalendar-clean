/**
 * Create Annotation Canvas - Cr√©e automatiquement les canvas d'annotation
 * Solution finale pour le syst√®me d'annotations iPad
 */

(function() {
    'use strict';

    console.log('üé® Cr√©ation automatique des canvas d\'annotation...');

    // Variables globales pour le dessin
    let isDrawing = false;
    let currentStroke = [];
    let currentTool = 'pen';
    let currentColor = '#ff0000';
    let currentStrokeWidth = 3;

    /**
     * Cr√©er un canvas d'annotation pour une page PDF
     */
    function createAnnotationCanvas(pageWrapper, pageNum) {
        const pdfCanvas = pageWrapper.querySelector(`#pdf-canvas-${pageNum}, .pdf-canvas`);
        if (!pdfCanvas) {
            console.warn(`‚ö†Ô∏è PDF Canvas non trouv√© pour page ${pageNum}`);
            return null;
        }

        // V√©rifier si le canvas d'annotation existe d√©j√†
        let annotationCanvas = pageWrapper.querySelector(`#annotation-canvas-${pageNum}`);
        if (annotationCanvas) {
            console.log(`‚ÑπÔ∏è Canvas d'annotation existe d√©j√† pour page ${pageNum}`);
            return annotationCanvas;
        }

        // Cr√©er le nouveau canvas d'annotation
        annotationCanvas = document.createElement('canvas');
        annotationCanvas.id = `annotation-canvas-${pageNum}`;
        annotationCanvas.className = 'annotation-canvas';
        
        // Copier les dimensions exactes du PDF canvas
        annotationCanvas.width = pdfCanvas.width;
        annotationCanvas.height = pdfCanvas.height;
        
        // Positionner par-dessus le PDF canvas
        annotationCanvas.style.position = 'absolute';
        annotationCanvas.style.top = '0';
        annotationCanvas.style.left = '0';
        annotationCanvas.style.width = pdfCanvas.style.width || `${pdfCanvas.width}px`;
        annotationCanvas.style.height = pdfCanvas.style.height || `${pdfCanvas.height}px`;
        annotationCanvas.style.zIndex = '100';
        annotationCanvas.style.pointerEvents = 'none'; // Par d√©faut, laisser passer les √©v√©nements
        annotationCanvas.style.touchAction = 'none'; // Sera g√©r√© dynamiquement
        annotationCanvas.style.userSelect = 'none';
        
        // S'assurer que le conteneur parent a position relative
        if (pageWrapper.style.position !== 'relative' && pageWrapper.style.position !== 'absolute') {
            pageWrapper.style.position = 'relative';
        }
        
        // Ajouter au DOM
        pageWrapper.appendChild(annotationCanvas);

        // Fonction de d√©tection stylet locale
        function isStylusTouch(touch) {
            return touch.touchType === 'stylus' || 
                   (touch.force !== undefined && touch.radiusX !== undefined && 
                    touch.force > 0.05 && (touch.radiusX < 10 || touch.radiusY < 10));
        }

        // Ajouter un syst√®me de d√©tection globale des touches sur le conteneur parent
        pageWrapper.addEventListener('touchstart', function(e) {
            const touches = Array.from(e.touches || []);
            const hasStylusOnly = touches.length === 1 && isStylusTouch(touches[0]);
            
            if (hasStylusOnly) {
                // Activer le canvas pour intercepter les √©v√©nements stylet
                annotationCanvas.style.pointerEvents = 'auto';
                if (window.debugLog_custom) {
                    window.debugLog_custom(`‚úèÔ∏è Canvas P${pageNum} activ√© pour stylet`);
                }
            } else {
                // D√©sactiver le canvas pour laisser passer scroll/zoom
                annotationCanvas.style.pointerEvents = 'none';
                if (window.debugLog_custom) {
                    window.debugLog_custom(`üëÜ Canvas P${pageNum} d√©sactiv√©: ${touches.length} touches`);
                }
            }
        }, { passive: true, capture: true });

        // D√©sactiver le canvas quand on l√®ve tous les doigts
        pageWrapper.addEventListener('touchend', function(e) {
            if (e.touches.length === 0) {
                annotationCanvas.style.pointerEvents = 'none';
                if (window.debugLog_custom) {
                    window.debugLog_custom(`üõë Canvas P${pageNum} d√©sactiv√© - fin de touch`);
                }
            }
        }, { passive: true });
        
        console.log(`‚úÖ Canvas d'annotation cr√©√© pour page ${pageNum}: ${annotationCanvas.width}x${annotationCanvas.height}`);
        if (window.debugLog_custom) {
            window.debugLog_custom(`‚úÖ Canvas cr√©√© P${pageNum}: ${annotationCanvas.width}x${annotationCanvas.height}`);
        }

        return annotationCanvas;
    }

    /**
     * Configurer les √©v√©nements stylet sur un canvas
     */
    function setupStylusEvents(annotationCanvas, pageNum) {
        let pageIsDrawing = false;
        let pageCurrentStroke = [];

        /**
         * D√©tecter si c'est un stylet
         */
        function isStylusTouch(touch) {
            return touch.touchType === 'stylus' || 
                   (touch.force !== undefined && touch.radiusX !== undefined && 
                    touch.force > 0.05 && (touch.radiusX < 10 || touch.radiusY < 10));
        }

        /**
         * Obtenir les outils actuels
         */
        function getCurrentTools() {
            return {
                tool: window.currentTool || currentTool,
                color: window.currentAnnotationColor || window.currentColor || currentColor,
                strokeWidth: window.currentStrokeWidth || currentStrokeWidth
            };
        }

        /**
         * D√©but du dessin stylet
         */
        function handleStylusStart(e) {
            // Analyser les touches
            const touches = Array.from(e.touches || []);
            const stylusTouch = touches.find(isStylusTouch);
            
            // Si ce n'est PAS un stylet seul, laisser passer l'√©v√©nement
            if (!stylusTouch || touches.length !== 1) {
                if (window.debugLog_custom) {
                    window.debugLog_custom(`üëÜ Geste non-stylet P${pageNum}: ${touches.length} touches, stylet: ${!!stylusTouch}`);
                }
                return; // Ne pas preventDefault/stopPropagation - laisser passer
            }

            if (window.debugLog_custom) {
                window.debugLog_custom(`‚úèÔ∏è Dessin stylet P${pageNum} force:${stylusTouch.force?.toFixed(2)}`);
            }

            e.preventDefault();
            e.stopPropagation();

            const rect = annotationCanvas.getBoundingClientRect();
            const ctx = annotationCanvas.getContext('2d');
            const tools = getCurrentTools();

            // Coordonn√©es relatives au canvas
            const x = (stylusTouch.clientX - rect.left) * (annotationCanvas.width / rect.width);
            const y = (stylusTouch.clientY - rect.top) * (annotationCanvas.height / rect.height);

            pageIsDrawing = true;
            pageCurrentStroke = [{ x, y, pressure: stylusTouch.force || 0.5 }];

            // Configuration du contexte
            ctx.globalCompositeOperation = tools.tool === 'eraser' ? 'destination-out' : 'source-over';
            ctx.strokeStyle = tools.color;
            ctx.lineWidth = tools.strokeWidth * (stylusTouch.force || 0.5);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Commencer le trait
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        /**
         * Mouvement du stylet
         */
        function handleStylusMove(e) {
            // Si on n'est pas en train de dessiner, laisser passer tous les √©v√©nements
            if (!pageIsDrawing) {
                return; // Ne pas intercepter les gestes de scroll/zoom
            }

            const touches = Array.from(e.touches || []);
            const stylusTouch = touches.find(isStylusTouch);
            
            if (!stylusTouch) {
                handleStylusEnd(e);
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            const rect = annotationCanvas.getBoundingClientRect();
            const ctx = annotationCanvas.getContext('2d');
            const tools = getCurrentTools();

            const x = (stylusTouch.clientX - rect.left) * (annotationCanvas.width / rect.width);
            const y = (stylusTouch.clientY - rect.top) * (annotationCanvas.height / rect.height);

            // Adapter l'√©paisseur √† la pression
            const pressure = stylusTouch.force || 0.5;
            ctx.lineWidth = tools.strokeWidth * Math.max(0.1, pressure);

            // Dessiner
            ctx.lineTo(x, y);
            ctx.stroke();

            pageCurrentStroke.push({ x, y, pressure });
        }

        /**
         * Fin du dessin stylet
         */
        function handleStylusEnd(e) {
            if (!pageIsDrawing) return;

            pageIsDrawing = false;

            if (window.debugLog_custom) {
                window.debugLog_custom(`üé® Trait termin√© P${pageNum}: ${pageCurrentStroke.length} points`);
            }

            // Sauvegarder si possible
            if (pageCurrentStroke.length > 1) {
                const tools = getCurrentTools();
                const annotation = {
                    type: 'stylus_stroke',
                    tool: tools.tool,
                    color: tools.color,
                    strokeWidth: tools.strokeWidth,
                    points: pageCurrentStroke,
                    page: parseInt(pageNum),
                    timestamp: Date.now()
                };

                // Tenter de sauvegarder
                if (window.saveAnnotationToDatabase) {
                    try {
                        window.saveAnnotationToDatabase(annotation);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Erreur sauvegarde annotation:', error);
                    }
                }
            }

            pageCurrentStroke = [];
        }

        // Ajouter les √©v√©nements - NE PAS utiliser capture pour permettre la propagation
        annotationCanvas.addEventListener('touchstart', handleStylusStart, { passive: false, capture: false });
        annotationCanvas.addEventListener('touchmove', handleStylusMove, { passive: false, capture: false });
        annotationCanvas.addEventListener('touchend', handleStylusEnd, { passive: false, capture: false });
        annotationCanvas.addEventListener('touchcancel', handleStylusEnd, { passive: false, capture: false });

        console.log(`‚úÖ √âv√©nements stylet configur√©s pour page ${pageNum}`);
    }

    /**
     * Traiter toutes les pages PDF trouv√©es
     */
    function processAllPages() {
        // Chercher tous les wrappers de page possibles
        const pageWrappers = document.querySelectorAll(
            '.pdf-page-wrapper, .pdf-page-container, [id*="page-wrapper"], [id*="page-container"]'
        );

        if (pageWrappers.length === 0) {
            if (window.debugLog_custom) {
                window.debugLog_custom('‚ö†Ô∏è Aucune page PDF trouv√©e');
            }
            return;
        }

        let canvasCreated = 0;
        pageWrappers.forEach((wrapper, index) => {
            // Extraire le num√©ro de page de l'ID ou utiliser l'index
            let pageNum = index + 1;
            if (wrapper.id) {
                const match = wrapper.id.match(/(\d+)/);
                if (match) {
                    pageNum = parseInt(match[1]);
                }
            }

            const canvas = createAnnotationCanvas(wrapper, pageNum);
            if (canvas) {
                setupStylusEvents(canvas, pageNum);
                canvasCreated++;
            }
        });

        console.log(`‚úÖ ${canvasCreated} canvas d'annotation cr√©√©s sur ${pageWrappers.length} pages`);
        if (window.debugLog_custom) {
            window.debugLog_custom(`‚úÖ ${canvasCreated} canvas cr√©√©s automatiquement`);
        }
    }

    /**
     * Observer les nouvelles pages cr√©√©es dynamiquement
     */
    function watchForNewPages() {
        const observer = new MutationObserver((mutations) => {
            let hasNewPages = false;
            
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.classList && (
                            node.classList.contains('pdf-page-wrapper') ||
                            node.classList.contains('pdf-page-container') ||
                            node.id && (node.id.includes('page-wrapper') || node.id.includes('page-container'))
                        )) {
                            hasNewPages = true;
                        } else if (node.querySelectorAll) {
                            const newPages = node.querySelectorAll(
                                '.pdf-page-wrapper, .pdf-page-container, [id*="page-wrapper"], [id*="page-container"]'
                            );
                            if (newPages.length > 0) {
                                hasNewPages = true;
                            }
                        }
                    }
                });
            });

            if (hasNewPages) {
                if (window.debugLog_custom) {
                    window.debugLog_custom('üÜï Nouvelles pages PDF d√©tect√©es');
                }
                setTimeout(processAllPages, 500);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        console.log('üëÅÔ∏è Observer pages PDF configur√©');
    }

    /**
     * Test de diagnostic
     */
    window.testCanvasCreation = function() {
        console.log('üß™ Test de cr√©ation de canvas:');
        processAllPages();
        
        const annotationCanvases = document.querySelectorAll('.annotation-canvas');
        console.log(`üìä R√©sultat: ${annotationCanvases.length} canvas d'annotation trouv√©s`);
        
        annotationCanvases.forEach((canvas, index) => {
            console.log(`  Canvas ${index + 1}: ${canvas.id}, ${canvas.width}x${canvas.height}`);
        });

        if (window.debugLog_custom) {
            window.debugLog_custom(`üß™ Test: ${annotationCanvases.length} canvas trouv√©s`);
        }
    };

    /**
     * Initialisation
     */
    function init() {
        console.log('üöÄ Initialisation cr√©ation canvas annotations...');
        
        // Traiter les pages existantes
        setTimeout(processAllPages, 1000);
        
        // Observer les nouvelles pages
        watchForNewPages();
        
        // Re-traiter p√©riodiquement au cas o√π
        setTimeout(processAllPages, 3000);
        setTimeout(processAllPages, 5000);
        
        console.log('‚úÖ Syst√®me cr√©ation canvas initialis√©');
        if (window.debugLog_custom) {
            window.debugLog_custom('‚úÖ Cr√©ation auto canvas activ√©e');
        }
    }

    // Initialiser apr√®s tout le reste
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(init, 2000);
        });
    } else {
        setTimeout(init, 2000);
    }

    // R√©initialiser quand un PDF est charg√©
    window.addEventListener('pdfLoaded', () => {
        setTimeout(init, 1000);
    });

})();