{% extends "base.html" %}

{% block title %}{% if not lesson %}Aucun cours{% elif is_current %}Le√ßon en cours{% else %}Prochain cours{% endif %} - ProfCalendar{% endblock %}

<!-- VERSION: 2dfd042-fix-studentsdata-tojson - 2026-01-19T16:35:00Z -->

{% block extra_css %}
<!-- Cache busting pour forcer le rechargement -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<!-- PDF.js pour l'affichage des PDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<!-- Font Awesome pour les ic√¥nes -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!-- Dessin natif Canvas optimis√© - pas de d√©pendance externe -->
<!-- Lecteur PDF unifi√© -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/unified-pdf-viewer.css') }}">
<!-- D√©sactivation ancien syst√®me d√©faillant - D√âSACTIV√â (bloque aussi le nouveau syst√®me) -->
<!-- <script src="{{ url_for('static', filename='js/disable-old-annotation-system.js') }}"></script> -->
<!-- Am√©lioration tactile pour iPad/tablettes - D√âSACTIV√â (bloque le zoom natif) -->
<!-- <script src="{{ url_for('static', filename='js/touch-scroll-enhancement.js') }}"></script> -->
<!-- Support tactile pour annotations PDF - D√âSACTIV√â (conflit avec syst√®me moderne) -->
<!-- <script src="{{ url_for('static', filename='js/pdf-touch-annotations.js') }}"></script> -->
<!-- Debug overlay pour iPad - D√âSACTIV√â (optimisation performances) -->
<!-- <script src="{{ url_for('static', filename='js/debug-overlay.js') }}"></script> -->
<!-- Correctif des erreurs d'annotation - D√âSACTIV√â (conflit avec syst√®me unifi√©) -->
<!-- <script src="{{ url_for('static', filename='js/fix-annotation-errors.js') }}"></script> -->
<!-- Cr√©ation automatique canvas annotations - D√âSACTIV√â (syst√®me unifi√© le fait d√©j√†) -->
<!-- <script src="{{ url_for('static', filename='js/create-annotation-canvas.js') }}"></script> -->
<!-- Syst√®me stylet uniquement pour iPad - D√âSACTIV√â (int√©gr√© dans syst√®me unifi√©) -->
<!-- <script src="{{ url_for('static', filename='js/stylus-only-annotations.js') }}"></script> -->
<!-- Toggle pour annotations tactiles -->
<script src="{{ url_for('static', filename='js/touch-annotation-toggle.js') }}"></script>
<script>
// Configuration du worker PDF.js
if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    console.log('PDF.js worker configur√©');
}
</script>
<style>
/* Emp√™cher le scroll automatique vers les inputs lors du focus */
html {
    scroll-behavior: auto;
}

body {
    overflow-anchor: none;
}

/* Emp√™cher les inputs de provoquer un scroll */
input, textarea, select {
    scroll-margin: 0;
    scroll-margin-top: 0;
    scroll-margin-bottom: 0;
}

.lesson-container {
    max-width: 1400px;
    margin: 0 auto;
    padding-bottom: 2rem;
    min-height: calc(100vh - 200px);
}

.lesson-header {
    background-color: var(--white);
    padding: 1.5rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-bottom: 1.5rem;
}

.lesson-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.lesson-title h1 {
    margin: 0;
    font-size: 1.75rem;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.lesson-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 9999px;
    font-size: 0.875rem;
    font-weight: 500;
}

.lesson-badge.current {
    background-color: #FEF3C7;
    color: #92400E;
}

.lesson-badge.next {
    background-color: #DBEAFE;
    color: #1E40AF;
}

.lesson-details {
    display: flex;
    gap: 2rem;
    margin-top: 0.5rem;
    color: var(--gray-color);
}

.lesson-detail {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.lesson-main {
    display: grid;
    grid-template-columns: 1.5fr 1fr 1fr;
    gap: 1.5rem;
    min-height: 500px;
    margin-bottom: 2rem;
    transition: all 0.3s ease;
}

/* Dispositions alternatives - Focus Planification = 50% gauche, autres empil√©es √† droite */
.lesson-main.layout-planning-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning attendance"
        "planning resources" !important;
}

.lesson-main.layout-planning-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-planning-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-planning-focus .resources-section {
    grid-area: resources;
}

/* Focus Pr√©sences = 50% droite, autres empil√©es √† gauche */
.lesson-main.layout-attendance-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning attendance"
        "resources attendance" !important;
}

.lesson-main.layout-attendance-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-attendance-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-attendance-focus .resources-section {
    grid-area: resources;
}

/* Focus Ressources = 50% droite, autres empil√©es √† gauche */
.lesson-main.layout-resources-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning resources"
        "attendance resources" !important;
}

.lesson-main.layout-resources-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-resources-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-resources-focus .resources-section {
    grid-area: resources;
}

/* Effets visuels discrets pour les sections focus */
.lesson-main.layout-planning-focus .planning-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-resources-focus .resources-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-attendance-focus .attendance-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-vertical {
    grid-template-columns: 1fr;
    gap: 1rem;
}

.lesson-main.layout-vertical .planning-section {
    order: 1;
}

.lesson-main.layout-vertical .resources-section {
    order: 2;
}

.lesson-main.layout-vertical .attendance-section {
    order: 3;
}

.planning-section, .resources-section, .attendance-section {
    background-color: var(--white);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    min-height: 400px;
    height: auto;
    transition: all 0.3s ease;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--light-gray);
}

.section-title {
    font-size: 1.25rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.planning-content {
    flex: 1;
    overflow-y: auto;
}

.planning-item {
    margin-bottom: 2rem;
}

.planning-item h3 {
    color: var(--primary-color);
    margin-bottom: 0.5rem;
    font-size: 1.125rem;
}

.planning-description {
    color: var(--gray-color);
    line-height: 1.6;
    white-space: pre-wrap;
}

/* Style sp√©cifique pour les checkboxes dans la description de planification */
.planning-description .checkbox-item {
    margin: 0.125rem 0;
}

.planning-description > div:not(.checkbox-item) {
    margin: 0.25rem 0;
}

/* Styles pour les checkboxes dans la planification */
.planning-checklist-item, .checkbox-item {
    display: flex;
    align-items: flex-start;
    gap: 0.5rem;
    margin: 0.25rem 0;
    min-height: 1.5rem;
}

.planning-checkbox {
    margin-top: 0.125rem;
    cursor: pointer;
    width: 1rem;
    height: 1rem;
}

.planning-checkbox-label {
    flex: 1;
    cursor: pointer;
    user-select: none;
    line-height: 1.4;
    padding-left: 0.125rem;
}

.planning-checkbox:checked + .planning-checkbox-label {
    text-decoration: line-through;
    opacity: 0.7;
}

#planningDescription {
    font-family: monospace;
    tab-size: 4;
}

.checklist-help {
    font-size: 0.75rem;
    color: var(--gray-color);
    margin-top: 0.5rem;
    font-style: italic;
}

.resources-content {
    flex: 1;
    overflow-y: auto;
}

.no-resources {
    text-align: center;
    padding: 3rem;
    color: var(--gray-color);
}

.no-resources i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

/* Styles pour les onglets de suivi */
.tracking-tabs {
    display: flex;
    border-bottom: 2px solid var(--light-gray);
    margin-bottom: 1.5rem;
}

.tracking-tab {
    padding: 0.75rem 1.5rem;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    color: var(--gray-color);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.tracking-tab:hover {
    color: var(--primary-color);
}

.tracking-tab.active {
    color: var(--primary-color);
    border-bottom-color: var(--primary-color);
}

.tracking-content {
    display: none;
}

.tracking-content.active {
    display: block;
}

/* Styles pour la section pr√©sences */
.attendance-content {
    flex: 1;
    overflow-y: auto;
}

.attendance-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.stat-item {
    text-align: center;
    padding: 0.5rem;
    border-radius: 0.375rem;
    background-color: var(--light-gray);
}

.stat-item.present {
    background-color: #D1FAE5;
    color: #065F46;
}

.stat-item.absent {
    background-color: #FEE2E2;
    color: #991B1B;
}

.stat-item.late {
    background-color: #FEF3C7;
    color: #92400E;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 700;
}

.stat-label {
    font-size: 0.75rem;
}

.students-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.student-attendance {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    border-radius: 0.375rem;
    background-color: var(--light-gray);
    transition: all 0.2s ease;
}

.student-attendance.present {
    background-color: #D1FAE5;
}

.student-attendance.absent {
    background-color: #FEE2E2;
}

.student-attendance.late {
    background-color: #FEF3C7;
}

.student-info {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    user-select: none;
}

.student-avatar {
    width: 32px;
    height: 32px;
    background-color: var(--primary-color);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
}

.student-attendance.absent .student-avatar {
    background-color: var(--danger-color);
}

.student-attendance.late .student-avatar {
    background-color: var(--warning-color);
}

.student-name {
    font-weight: 500;
}

.student-name-container {
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
}

.student-accommodations {
    display: flex;
    gap: 0.25rem;
    flex-wrap: wrap;
}

.accommodation-emoji {
    font-size: 0.875rem;
}

.accommodation-name {
    font-size: 0.75rem;
    color: #6b7280;
    font-style: italic;
}

.student-attendance.absent .student-name {
    color: var(--danger-color);
    text-decoration: line-through;
}

.student-attendance.late .student-name {
    color: var(--warning-color);
}

.late-controls {
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.late-minutes {
    width: 60px;
    padding: 0.25rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    text-align: center;
}

.late-minutes:focus {
    outline: none;
    border-color: var(--warning-color);
}

.late-btn {
    width: 28px;
    height: 28px;
    border: 1px solid #D1D5DB;
    background-color: white;
    color: var(--gray-color);
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 0.875rem;
}

.late-btn:hover {
    background-color: #F3F4F6;
    border-color: var(--warning-color);
    color: var(--warning-color);
}

.late-btn:active {
    transform: scale(0.95);
}

.btn-late {
    width: 32px;
    height: 32px;
    border: none;
    background-color: #F3F4F6;
    color: var(--gray-color);
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.btn-late:hover {
    background-color: var(--warning-color);
    color: white;
}

.student-attendance.late .btn-late {
    background-color: var(--warning-color);
    color: white;
}

/* Styles pour les sanctions */
.sanctions-content {
    flex: 1;
    overflow-y: auto;
}

.sanctions-table-container {
    overflow-x: auto;
    border-radius: var(--border-radius);
    border: 1px solid var(--light-gray);
    background-color: var(--white);
}

.sanctions-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
}

.sanctions-table th {
    background-color: var(--light-gray);
    padding: 0.75rem;
    text-align: center;
    font-weight: 600;
    color: var(--dark-color);
    border-bottom: 2px solid var(--primary-color);
    position: sticky;
    top: 0;
    z-index: 1;
    font-size: 0.875rem;
}

.sanctions-table th.student-column {
    text-align: left;
    min-width: 150px;
    max-width: 150px;
}

.sanctions-table th.sanction-column {
    min-width: 100px;
}

.sanctions-table td {
    padding: 0.5rem;
    border-bottom: 1px solid var(--light-gray);
    vertical-align: middle;
}

.sanctions-table tr:hover {
    background-color: #F9FAFB;
}

.student-name {
    font-weight: 500;
    color: var(--dark-color);
    text-align: left;
    font-size: 0.875rem;
}

.sanction-count {
    text-align: center;
}

.count-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
}

.count-btn {
    width: 24px;
    height: 24px;
    border: 1px solid var(--light-gray);
    background-color: var(--white);
    color: var(--gray-color);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.625rem;
    transition: all 0.2s ease;
}

.count-btn:hover {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    transform: scale(1.1);
}

.count-btn.decrease:hover {
    background-color: var(--danger-color);
    border-color: var(--danger-color);
}

.count-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.count-display {
    font-weight: 600;
    font-size: 0.875rem;
    min-width: 24px;
    text-align: center;
    color: var(--dark-color);
    padding: 0.125rem 0.25rem;
    border-radius: var(--border-radius);
    background-color: var(--light-gray);
}

.count-display.warning {
    background-color: #FEF3C7;
    color: #92400E;
}

.count-display.danger {
    background-color: #FEE2E2;
    color: #991B1B;
}

.lesson-controls {
    display: flex;
    align-items: center;
    gap: 2rem;
}

.layout-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.layout-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--gray-color);
}

.layout-buttons {
    display: flex;
    gap: 0.25rem;
    background-color: var(--light-gray);
    padding: 0.25rem;
    border-radius: 0.5rem;
}

.layout-btn {
    width: 40px;
    height: 40px;
    border: none;
    background-color: transparent;
    color: var(--gray-color);
    border-radius: 0.375rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 1rem;
}

.layout-btn:hover {
    background-color: var(--white);
    color: var(--primary-color);
    transform: scale(1.05);
}

.layout-btn.active {
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
}

.clock-widget {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
    padding: 0.75rem 1rem;
    background-color: #E0F2FE;
    border: 2px solid #0EA5E9;
    border-radius: var(--border-radius);
    min-width: 120px;
}

.clock-display {
    font-size: 1.25rem;
    font-weight: bold;
    color: #0C4A6E;
    font-family: 'Courier New', monospace;
}

.clock-label {
    font-size: 0.75rem;
    color: #0369A1;
    text-align: center;
    font-weight: 500;
}

.timer-widget {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 1.5rem;
    background-color: var(--light-gray);
    border-radius: var(--border-radius);
}

.timer-display {
    font-size: 1.5rem;
    font-weight: 600;
    font-family: monospace;
}

.timer-controls {
    display: flex;
    gap: 0.5rem;
}

.timer-btn {
    width: 36px;
    height: 36px;
    border: none;
    background-color: var(--white);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timer-btn:hover {
    transform: scale(1.1);
    box-shadow: var(--shadow-sm);
}

/* Indicateur de sauvegarde */
.saving-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background-color: #3B82F6;
    color: white;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    display: none;
    align-items: center;
    gap: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.saving-indicator.show {
    display: flex;
}

.saving-indicator.success {
    background-color: #10B981;
}

.saving-indicator.error {
    background-color: #EF4444;
}

@media (max-width: 900px) {
    .lesson-main,
    .lesson-main.layout-planning-focus,
    .lesson-main.layout-resources-focus,
    .lesson-main.layout-attendance-focus {
        grid-template-columns: 1fr !important;
        gap: 1rem;
    }
}

@media (min-width: 901px) and (max-width: 1200px) {
    .lesson-main {
        grid-template-columns: 1fr 1fr 1fr;
    }
    
    .lesson-main.layout-planning-focus {
        grid-template-columns: 2fr 1fr 1fr !important;
    }

    .lesson-main.layout-resources-focus {
        grid-template-columns: 1fr 2fr 1fr !important;
    }

    .lesson-main.layout-attendance-focus {
        grid-template-columns: 1fr 1fr 2fr !important;
    }
}

@media (max-width: 1200px) {
    .lesson-container {
        min-height: auto;
        padding-bottom: 2rem;
    }

    .planning-section, .resources-section, .attendance-section, .seating-plan-section {
        min-height: 300px;
    }
    
    .lesson-controls {
        flex-direction: column;
        gap: 1rem;
        align-items: flex-start;
    }
    
    .layout-controls {
        width: 100%;
        justify-content: space-between;
    }
    
    .layout-buttons {
        flex-wrap: wrap;
    }
}

@media (max-width: 768px) {
    .layout-label {
        display: none;
    }
    
    .layout-btn {
        width: 36px;
        height: 36px;
        font-size: 0.875rem;
    }
}

/* ============================================================================
   MENU DES FEUILLES BLANCHES
   ============================================================================ */

.blank-sheets-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    z-index: 10000;
    min-width: 400px;
    max-width: 500px;
}

.blank-sheets-menu .menu-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 2px solid #e5e7eb;
}

.blank-sheets-menu .menu-header h4 {
    margin: 0;
    font-size: 1.125rem;
    color: #1f2937;
}

.blank-sheets-menu .close-menu-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: #9ca3af;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.25rem;
    transition: all 0.2s;
}

.blank-sheets-menu .close-menu-btn:hover {
    background-color: #f3f4f6;
    color: #1f2937;
}

.blank-sheets-menu .menu-list {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: 1rem;
}

.blank-sheets-menu .sheet-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: background-color 0.2s;
    border: 1px solid transparent;
}

.blank-sheets-menu .sheet-item:hover {
    background-color: #fef3c7;
    border-color: #fbbf24;
}

.blank-sheets-menu .sheet-item i {
    font-size: 1.25rem;
    color: #f59e0b;
}

.blank-sheets-menu .sheet-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.blank-sheets-menu .sheet-title {
    font-weight: 500;
    color: #1f2937;
}

.blank-sheets-menu .sheet-date {
    font-size: 0.75rem;
    color: #6b7280;
}

.blank-sheets-menu .new-sheet-btn {
    width: 100%;
    padding: 0.75rem;
    background-color: #3b82f6;
    color: white;
    border: none;
    border-radius: 0.375rem;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    transition: background-color 0.2s;
}

.blank-sheets-menu .new-sheet-btn:hover {
    background-color: #2563eb;
}

/* Section feuilles blanches dans la liste des ressources */
.blank-sheets-section {
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid #e5e7eb;
}

.section-subtitle {
    font-size: 0.875rem;
    font-weight: 600;
    color: #6b7280;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* Bouton de suppression des feuilles blanches */
.btn-delete-blank-sheet {
    background: none;
    border: none;
    color: #dc2626;
    padding: 0.5rem;
    cursor: pointer;
    border-radius: 0.375rem;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    opacity: 0.6;
}

.btn-delete-blank-sheet:hover {
    background-color: #fee2e2;
    opacity: 1;
}

.resource-item.blank-sheet {
    position: relative;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    background-color: #fef3c7;
    border-left: 3px solid #f59e0b;
}

.resource-item.blank-sheet .resource-info {
    flex: 1;
    cursor: pointer;
}

.resource-item.blank-sheet {
    background-color: #fef3c7;
    border-left: 3px solid #f59e0b;
}

.resource-item.blank-sheet:hover {
    background-color: #fde68a;
}
</style>
{% endblock %}

{% block content %}
{% if not lesson %}
<div style="max-width: 600px; margin: 4rem auto; text-align: center; padding: 2rem;">
    <div style="background: #FEF3C7; border: 2px solid #F59E0B; border-radius: 12px; padding: 2rem;">
        <i class="fas fa-calendar-alt" style="font-size: 3rem; color: #F59E0B; margin-bottom: 1rem;"></i>
        <h2 style="color: #92400E; margin-bottom: 0.5rem;">Aucun cours pr√©vu</h2>
        <p style="color: #78350F; margin-bottom: 1.5rem;">
            Votre horaire type n'est pas encore rempli. Configurez-le pour voir vos prochains cours ici.
        </p>
        <a href="{{ url_for('schedule.weekly_schedule') }}"
           style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1.5rem;
                  background: #F59E0B; color: white; border-radius: 8px; text-decoration: none;
                  font-size: 1rem; font-weight: 600;">
            <i class="fas fa-edit"></i> Remplir mon horaire type
        </a>
    </div>
</div>
{% else %}
<div class="lesson-container">
    <!-- En-t√™te de la le√ßon -->
    <div class="lesson-header">
        <div class="lesson-info">
            <div>
                <div class="lesson-title">
                    <h1>
                        {% if is_current %}
                        <span class="lesson-badge current">
                            <i class="fas fa-circle"></i> En cours
                        </span>
                        {% else %}
                        <span class="lesson-badge next">
                            <i class="fas fa-clock"></i> Prochain cours
                        </span>
                        {% endif %}
                        {% if lesson.classroom_id %}
                    {{ lesson.classroom.name }} - {{ lesson.classroom.subject }}
                {% elif lesson.mixed_group_id %}
                    {{ lesson.mixed_group.name }} - {{ lesson.mixed_group.subject }}
                {% else %}
                    Cours non d√©fini
                {% endif %}
                    </h1>
                </div>
                <div class="lesson-details">
                    <div class="lesson-detail">
                        <i class="fas fa-calendar"></i>
                        <span>
                            {% set day_names = {
                                'Monday': 'Lundi',
                                'Tuesday': 'Mardi', 
                                'Wednesday': 'Mercredi',
                                'Thursday': 'Jeudi',
                                'Friday': 'Vendredi',
                                'Saturday': 'Samedi',
                                'Sunday': 'Dimanche'
                            } %}
                            {% set month_names = {
                                'January': 'janvier',
                                'February': 'f√©vrier',
                                'March': 'mars',
                                'April': 'avril',
                                'May': 'mai',
                                'June': 'juin',
                                'July': 'juillet',
                                'August': 'ao√ªt',
                                'September': 'septembre',
                                'October': 'octobre',
                                'November': 'novembre',
                                'December': 'd√©cembre'
                            } %}
                            {{ day_names[lesson_date.strftime('%A')] }} {{ lesson_date.strftime('%d') }} {{ month_names[lesson_date.strftime('%B')] }} {{ lesson_date.strftime('%Y') }}
                        </span>
                    </div>
                    <div class="lesson-detail">
                        <i class="fas fa-clock"></i>
                        <span>
                            {% if lesson.is_merged and lesson.end_period_number and lesson.end_period_number != lesson.period_number %}
                                P√©riode {{ lesson.period_number }}-{{ lesson.end_period_number }} ({{ lesson.start_time.strftime('%H:%M') }} - {{ lesson.end_time.strftime('%H:%M') }})
                            {% else %}
                                P√©riode {{ lesson.period_number }} ({{ lesson.start_time.strftime('%H:%M') }} - {{ lesson.end_time.strftime('%H:%M') }})
                            {% endif %}
                        </span>
                    </div>
                </div>
            </div>

            <div class="lesson-controls">
                <!-- Contr√¥les de disposition -->
                <div class="layout-controls">
                    <span class="layout-label">Disposition :</span>
                    <div class="layout-buttons">
                        <button class="layout-btn active" data-layout="default" title="Disposition par d√©faut (3 colonnes)">
                            <i class="fas fa-columns"></i>
                        </button>
                        <button class="layout-btn" data-layout="planning-focus" title="Focus planification (planification large)">
                            <i class="fas fa-list-alt"></i>
                        </button>
                        <button class="layout-btn" data-layout="resources-focus" title="Focus ressources (ressources large)">
                            <i class="fas fa-folder-open"></i>
                        </button>
                        <button class="layout-btn" data-layout="attendance-focus" title="Focus pr√©sences (pr√©sences large)">
                            <i class="fas fa-user-check"></i>
                        </button>
                        <button class="layout-btn" data-layout="vertical" title="Disposition verticale (1 colonne)">
                            <i class="fas fa-bars"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Horloge actuelle -->
                <div class="clock-widget">
                    <div class="clock-display" id="currentClock">--:--</div>
                    <div class="clock-label">Heure actuelle</div>
                </div>
                
                {% if is_current %}
                <div class="timer-widget">
                    <div class="timer-display" id="lessonTimer">{{ time_remaining }}</div>
                    <div class="timer-controls">
                        <button class="timer-btn" onclick="toggleTimer()" title="Pause/Reprendre">
                            <i class="fas fa-pause" id="timerIcon"></i>
                        </button>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Contenu principal -->
    <div class="lesson-main">
        <!-- Section planification -->
        <div class="planning-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-clipboard-list"></i> Planification du cours
                </h2>
                <div style="display:flex;gap:0.5rem;">
                    <button class="edit-planning-btn" onclick="showAddResourceModal()" title="Ajouter un fichier ou exercice" style="background:#10b981;color:white;border:none;padding:0.4rem 0.8rem;border-radius:8px;cursor:pointer;font-weight:600;font-size:0.85rem;">
                        <i class="fas fa-file-upload"></i> Ajout de fichiers
                    </button>
                    <button class="edit-planning-btn" onclick="togglePlanningEdit()">
                        <i class="fas fa-edit"></i> <span id="editBtnText">Modifier</span>
                    </button>
                </div>
            </div>

            <div class="planning-content">
                <!-- Vue de lecture -->
                <div id="planningView" {% if not planning %}style="display: none;"{% endif %}>
                    <div class="planning-item">
                        <h3 id="planningTitleDisplay">{{ planning.title if planning else 'Cours sans titre' }}</h3>
                        <div class="planning-description" id="planningDescriptionDisplay">
                            {% if planning %}
                                {{ render_planning_with_checkboxes(planning) | safe }}
                            {% else %}
                                Aucune description
                            {% endif %}
                        </div>

                        <!-- Section des ressources de planification -->
                        {% if planning and planning.resources.count() > 0 %}
                        <div id="planning-resources-section" style="margin-top:1.5rem;padding-top:1.5rem;border-top:2px solid #e5e7eb;">
                            <h4 style="margin:0 0 1rem 0;font-size:0.95rem;color:#374151;"><i class="fas fa-file-alt" style="margin-right:0.5rem;color:#10b981;"></i> Ressources du cours</h4>
                            <div id="planning-resources-list" style="display:flex;flex-direction:column;gap:0.5rem;">
                                {% for resource in planning.resources.all() %}
                                <div class="planning-resource-item"
                                     data-resource-id="{{ resource.id }}"
                                     data-resource-type="{{ resource.resource_type }}"
                                     style="padding:0.8rem;border:1px solid #e5e7eb;border-radius:10px;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;gap:0.6rem;"
                                     {% if resource.resource_type == 'file' %}
                                     onclick="openResourceFile({{ resource.resource_id }}, '{{ resource.display_name|e }}')"
                                     {% elif resource.resource_type == 'exercise' %}
                                     onclick="showModeModal({{ resource.resource_id }}, '{{ resource.display_name|e }}', 'publish', {{ resource.id }})"
                                     {% endif %}>

                                    {% if resource.resource_type == 'file' %}
                                        <i class="fas fa-{{ resource.display_icon or 'file' }}" style="color:{{ '#dc2626' if resource.display_icon == 'file-pdf' else '#3b82f6' if resource.display_icon == 'file-image' else '#6b7280' }};font-size:1.1rem;"></i>
                                        <div style="flex:1;">
                                            <div style="font-weight:600;font-size:0.9rem;color:#1f2937;">{{ resource.display_name }}</div>
                                            <div style="font-size:0.75rem;color:#9ca3af;">PDF/Document</div>
                                        </div>
                                        <i class="fas fa-external-link-alt" style="color:#10b981;font-size:0.9rem;"></i>
                                        <button onclick="event.stopPropagation(); deleteResource({{ resource.id }}, this)" class="btn-icon" style="background:none;border:none;cursor:pointer;padding:0.3rem;margin-left:0.3rem;" title="Supprimer"><i class="fas fa-trash-alt" style="color:#ef4444;font-size:0.85rem;"></i></button>
                                    {% elif resource.resource_type == 'exercise' %}
                                        <i class="fas fa-gamepad" style="color:#667eea;font-size:1.1rem;"></i>
                                        <div style="flex:1;">
                                            <div style="font-weight:600;font-size:0.9rem;color:#1f2937;">{{ resource.display_name }}</div>
                                            <div style="font-size:0.75rem;color:#9ca3af;">
                                                {% if resource.status == 'published' %}
                                                    <span style="background:{{ '#fef2f2' if resource.mode == 'combat' else '#eef2ff' }};color:{{ '#ef4444' if resource.mode == 'combat' else '#10b981' }};padding:0.1rem 0.4rem;border-radius:4px;font-weight:600;">
                                                        {{ '‚öîÔ∏è Combat' if resource.mode == 'combat' else 'üìñ Classique' }}
                                                    </span>
                                                {% else %}
                                                    <span style="background:#f0fdf4;color:#10b981;padding:0.1rem 0.4rem;border-radius:4px;font-weight:600;">Non publi√©</span>
                                                {% endif %}
                                            </div>
                                        </div>
                                        <i class="fas fa-play-circle" style="color:#667eea;font-size:0.9rem;"></i>
                                        <button onclick="event.stopPropagation(); deleteResource({{ resource.id }}, this)" class="btn-icon" style="background:none;border:none;cursor:pointer;padding:0.3rem;margin-left:0.3rem;" title="Supprimer"><i class="fas fa-trash-alt" style="color:#ef4444;font-size:0.85rem;"></i></button>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}
                    </div>
                </div>

                <!-- M√©mos et remarques en mode lecture seule - TOUJOURS VISIBLE -->
                <div id="memosViewContainer" class="memos-view-container" style="margin-top: 2rem;">
                    <!-- Les m√©mos/remarques seront affich√©s ici par JavaScript -->
                </div>

                <!-- Formulaire d'√©dition -->
                <div id="planningEdit" style="display: none;">
                    <form id="planningForm" onsubmit="savePlanning(event)">
                        <div class="form-group">
                            <label class="form-label">Titre du cours</label>
                            <input type="text"
                                   id="planningTitle"
                                   class="form-control"
                                   placeholder="Ex: Introduction aux fractions"
                                   value="{{ planning.title if planning else '' }}">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Planification</label>
                            <textarea id="planningDescription"
                                      class="form-control"
                                      rows="8"
                                      placeholder="Objectifs du cours, activit√©s pr√©vues, exercices, devoirs...">{{ planning.description if planning else '' }}</textarea>
                            <div class="checklist-help">
                                Astuce : Commencez une ligne par "-" pour cr√©er une case √† cocher
                            </div>
                        </div>

                        <!-- M√©mos et remarques - Nouveau design -->
                        <div class="form-group">
                            <label class="form-label">M√©mos et remarques</label>

                            <div class="memos-actions">
                                <button type="button" class="btn btn-memo" onclick="openMemoCreation()">
                                    <i class="fas fa-sticky-note"></i> Enregistrer m√©mo
                                </button>
                                <button type="button" class="btn btn-remark" onclick="openRemarkCreation()">
                                    <i class="fas fa-user-edit"></i> Enregistrer remarque √©l√®ve
                                </button>
                            </div>

                            <!-- Formulaire cr√©ation m√©mo -->
                            <div id="memoCreationForm" class="memo-form" style="display: none;">
                                <div class="form-group">
                                    <label class="form-label">Choisir une date de rappel</label>
                                    <select id="memoDateType" class="form-control" onchange="handleMemoDateTypeChange()">
                                        <option value="">-- S√©lectionner --</option>
                                        <option value="next_lesson">Cours suivant</option>
                                        <option value="next_week">Semaine prochaine</option>
                                        <option value="custom">Date personnalis√©e</option>
                                        <option value="no_date">Sans date</option>
                                    </select>
                                </div>

                                <div id="memoCustomDateDiv" class="form-group" style="display: none;">
                                    <label class="form-label">Date personnalis√©e</label>
                                    <input type="date" id="memoCustomDate" class="form-control">
                                </div>

                                <div id="memoContentDiv" class="form-group" style="display: none;">
                                    <label class="form-label">Contenu du m√©mo</label>
                                    <textarea id="memoContent" class="form-control" rows="3" placeholder="Entrez le contenu du m√©mo..."></textarea>
                                    <div class="memo-form-actions">
                                        <button type="button" class="btn btn-primary" onclick="submitMemo()">
                                            <i class="fas fa-plus"></i> Ajouter
                                        </button>
                                        <button type="button" class="btn btn-outline" onclick="cancelMemoCreation()">
                                            Annuler
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Formulaire cr√©ation remarque -->
                            <div id="remarkCreationForm" class="memo-form" style="display: none;">
                                <div class="form-group">
                                    <label class="form-label">S√©lectionner un ou plusieurs √©l√®ves</label>
                                    <input type="text"
                                           id="remarkStudentInput"
                                           class="form-control"
                                           placeholder="Commencez √† taper le nom d'un √©l√®ve..."
                                           autocomplete="off">
                                    <div id="remarkStudentAutocomplete" class="memo-autocomplete" style="display: none;"></div>

                                    <div id="selectedStudentsDiv" class="selected-students" style="display: none;">
                                        <label class="form-label">√âl√®ves s√©lectionn√©s :</label>
                                        <div id="selectedStudentsList"></div>
                                        <button type="button" class="btn btn-primary btn-sm" onclick="confirmStudentSelection()">
                                            <i class="fas fa-check"></i> OK
                                        </button>
                                    </div>
                                </div>

                                <div id="remarkContentDiv" class="form-group" style="display: none;">
                                    <label class="form-label">Contenu de la remarque</label>
                                    <textarea id="remarkContent" class="form-control" rows="3" placeholder="Entrez la remarque..."></textarea>

                                    <div class="form-check" style="margin-top: 1rem; margin-bottom: 1rem;">
                                        <input type="checkbox" class="form-check-input" id="sendToParentAndStudent">
                                        <label class="form-check-label" for="sendToParentAndStudent">
                                            <i class="fas fa-paper-plane"></i> Envoyer aux parents et √† l'√©l√®ve
                                        </label>
                                    </div>

                                    <div class="memo-form-actions">
                                        <button type="button" class="btn btn-primary" onclick="submitRemark()">
                                            <i class="fas fa-plus"></i> Ajouter
                                        </button>
                                        <button type="button" class="btn btn-outline" onclick="cancelRemarkCreation()">
                                            Annuler
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Liste des m√©mos et remarques existants -->
                        <div id="memosListContainer" class="memos-list-container">
                            <!-- Les m√©mos/remarques seront affich√©s ici -->
                        </div>

                        <div class="form-actions">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Enregistrer
                            </button>
                            <button type="button" class="btn btn-outline" onclick="cancelPlanningEdit()">
                                Annuler
                            </button>
                        </div>
                    </form>
                </div>

                <!-- √âtat vide -->
                {% if not planning %}
                <div id="emptyPlanning" class="no-resources">
                    <i class="fas fa-clipboard"></i>
                    <p>Aucune planification pour ce cours</p>
                    <button class="btn btn-primary" onclick="togglePlanningEdit()">
                        <i class="fas fa-plus"></i> Cr√©er une planification
                    </button>
                </div>
                {% endif %}
            </div>
        </div>


        <!-- Section pr√©sences -->
        <div class="attendance-section"
             data-classroom-id="{{ lesson_classroom.id if lesson_classroom else '' }}"
             data-lesson-date="{{ lesson_date.strftime('%Y-%m-%d') }}"
             data-period-number="{{ lesson.period_number }}">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-user-check"></i> Suivi des √©l√®ves
                </h2>
            </div>

            <!-- Onglets de suivi -->
            <div class="tracking-tabs">
                <button class="tracking-tab active" onclick="showTrackingTab('attendance')">
                    <i class="fas fa-user-check"></i> Pr√©sences
                </button>
                {% if imported_sanctions %}
                <button class="tracking-tab" onclick="showTrackingTab('sanctions')">
                    <i class="fas fa-exclamation-triangle"></i> Coches ({{ imported_sanctions|length }})
                </button>
                {% endif %}
                {% if seating_plan %}
                <button class="tracking-tab" onclick="showTrackingTab('seating-plan')">
                    <i class="fas fa-th"></i> Plan de classe
                </button>
                {% endif %}
            </div>

            <div class="attendance-content tracking-content active" id="attendance-content">
                <!-- Statistiques -->
                <div class="attendance-stats">
                    <div class="stat-item present">
                        <div class="stat-value" id="presentCount">0</div>
                        <div class="stat-label">Pr√©sents</div>
                    </div>
                    <div class="stat-item absent">
                        <div class="stat-value" id="absentCount">0</div>
                        <div class="stat-label">Absents</div>
                    </div>
                    <div class="stat-item late">
                        <div class="stat-value" id="lateCount">0</div>
                        <div class="stat-label">Retards</div>
                    </div>
                </div>

                <!-- Liste des √©l√®ves -->
                {% if current_group %}
                <div style="margin-bottom: 1rem; padding: 0.5rem; background-color: #f8f9fa; border-radius: 0.375rem; border-left: 4px solid {{ current_group.color }};">
                    <h4 style="margin: 0; font-size: 0.875rem; color: #374151; display: flex; align-items: center;">
                        <i class="fas fa-users" style="margin-right: 0.5rem; color: {{ current_group.color }};"></i>
                        Groupe : {{ current_group.name }}
                        {% if current_group.description %}
                        <span style="font-weight: normal; color: #6b7280; margin-left: 0.5rem;">({{ current_group.description }})</span>
                        {% endif %}
                    </h4>
                    <p style="margin: 0.25rem 0 0 0; font-size: 0.75rem; color: #6b7280;">
                        {{ students|length }} √©l√®ve(s) dans ce groupe
                    </p>
                </div>
                {% else %}
                <div style="margin-bottom: 1rem; padding: 0.5rem; background-color: #f8f9fa; border-radius: 0.375rem;">
                    <h4 style="margin: 0; font-size: 0.875rem; color: #374151; display: flex; align-items: center;">
                        <i class="fas fa-users" style="margin-right: 0.5rem; color: #6b7280;"></i>
                        Classe enti√®re
                    </h4>
                    <p style="margin: 0.25rem 0 0 0; font-size: 0.75rem; color: #6b7280;">
                        {{ students|length }} √©l√®ve(s) dans la classe
                    </p>
                </div>
                {% endif %}
                <div class="students-list">
                    {% for student in students %}
                    {% set attendance = attendance_records.get(student.id, None) %}
                    {% set status = attendance.status if attendance else 'present' %}
                    {% set late_minutes = attendance.late_minutes if attendance else 0 %}

                    <div class="student-attendance {{ status }}"
                         id="student-{{ student.id }}"
                         data-student-id="{{ student.id }}"
                         data-status="{{ status }}">

                        <div class="student-info" onclick="toggleAttendance({{ student.id }})">
                            <div class="student-avatar">
                                {{ student.first_name[0] }}{{ student.last_name[0] if student.last_name else '' }}
                            </div>
                            <div class="student-name-container">
                                <span class="student-name">{{ student.full_name }}</span>
                                {% if accommodation_display != 'none' and student_accommodations.get(student.id) %}
                                <div class="student-accommodations">
                                    {% for accommodation in student_accommodations[student.id] %}
                                        {% if accommodation_display == 'emoji' %}
                                            <span class="accommodation-emoji" title="{{ accommodation.name }}">{{ accommodation.emoji }}</span>
                                        {% elif accommodation_display == 'name' %}
                                            <span class="accommodation-name">{{ accommodation.emoji }} {{ accommodation.name }}</span>
                                        {% endif %}
                                    {% endfor %}
                                </div>
                                {% endif %}
                            </div>
                        </div>

                        <div class="late-controls">
                            <button class="late-btn decrease"
                                    onclick="adjustLateMinutes({{ student.id }}, -1)"
                                    title="Diminuer de 1 minute">
                                <i class="fas fa-minus"></i>
                            </button>
                            <input type="number"
                                   class="late-minutes"
                                   id="late-{{ student.id }}"
                                   value="{{ late_minutes if status == 'late' else '' }}"
                                   min="1"
                                   max="120"
                                   placeholder="min"
                                   onchange="setLateStatus({{ student.id }})">
                            <button class="late-btn increase"
                                    onclick="adjustLateMinutes({{ student.id }}, 1)"
                                    title="Augmenter de 1 minute">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button class="btn-late"
                                    onclick="setLateStatus({{ student.id }})"
                                    title="Marquer en retard">
                                <i class="fas fa-clock"></i>
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>

            <!-- Section sanctions -->
            {% if imported_sanctions %}
            <div class="sanctions-content tracking-content" id="sanctions-content">
                <div class="sanctions-table-container">
                    <table class="sanctions-table">
                        <thead>
                            <tr>
                                <th class="student-column">√âl√®ve</th>
                                {% for sanction in imported_sanctions %}
                                <th class="sanction-column">{{ sanction.name }}</th>
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for student in students %}
                            <tr>
                                <td class="student-name">{{ student.full_name }}</td>
                                {% for sanction in imported_sanctions %}
                                <td class="sanction-count">
                                    <div class="count-controls">
                                        <button class="count-btn decrease" onclick="updateSanctionCount({{ student.id }}, {{ sanction.id }}, -1)">
                                            <i class="fas fa-minus"></i>
                                        </button>
                                        <span class="count-display" data-student="{{ student.id }}" data-sanction="{{ sanction.id }}">
                                            {{ sanctions_data[student.id][sanction.id] }}
                                        </span>
                                        <button class="count-btn increase" onclick="updateSanctionCount({{ student.id }}, {{ sanction.id }}, 1)">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                    </div>
                                </td>
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
            {% endif %}
            
            <!-- Section plan de classe -->
            {% if seating_plan %}
            <div class="seating-plan-content tracking-content" id="seating-plan-content">
                <div class="seating-plan-header">
                    <div class="seating-plan-info">
                        <h3><i class="fas fa-th"></i> Plan de classe</h3>
                        <p>Cliquez sur les tables pour ajouter des avertissements : jaune ‚Üí rouge ‚Üí noir</p>
                    </div>
                    <button id="undo-warning-btn" class="btn btn-primary" onclick="undoLastWarning()" disabled>
                        <i class="fas fa-undo"></i> Annuler
                    </button>
                </div>
                <div class="seating-plan-container">
                    <div class="seating-plan-viewer" id="seating-plan-viewer">
                        <div class="seating-workspace" id="seating-workspace">
                            <!-- Le plan de classe sera affich√© ici -->
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}
        </div>
        <!-- Fin de attendance-section -->

        <!-- Section ressources -->
        <div class="resources-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-folder-open"></i> Ressources du cours
                </h2>
                <div class="resource-controls">
                    <button class="resource-btn" onclick="refreshResources()" title="Actualiser">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="add-resource-btn" onclick="showBlankSheetsMenu()" title="Cr√©er ou ouvrir des feuilles blanches" style="margin-right: 0.5rem;">
                        <i class="fas fa-file-medical"></i> Feuilles blanches
                    </button>
                    <a href="{{ url_for('file_manager.index') }}" class="add-resource-btn" target="_blank">
                        <i class="fas fa-plus"></i> Gestionnaire
                    </a>
                </div>
            </div>

            <div class="resources-content" id="resourcesContent">
                <!-- Chargement initial -->
                <div class="resources-loading" id="resourcesLoading">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Chargement des ressources...</p>
                </div>

                <!-- Ressources √©pingl√©es -->
                <div class="pinned-resources" id="pinnedResources" style="display: none;">
                    <div class="pinned-header">
                        <i class="fas fa-thumbtack"></i>
                        <span>Ressources √©pingl√©es</span>
                    </div>
                    <div class="pinned-list" id="pinnedList">
                        <!-- Les ressources √©pingl√©es seront charg√©es ici -->
                    </div>
                </div>

                <!-- Navigation des dossiers -->
                <div class="folder-navigation" id="folderNavigation" style="display: none;">
                    <div class="breadcrumb" id="resourceBreadcrumb">
                        <span class="breadcrumb-item active" data-path="" onclick="navigateToFolder('')">
                            <i class="fas fa-home"></i> Racine
                        </span>
                    </div>
                </div>

                <!-- Arborescence des ressources -->
                <div class="resources-tree" id="resourcesTree" style="display: none;">
                    <!-- L'arborescence sera charg√©e ici -->
                </div>

                <!-- √âtat vide -->
                <div class="no-resources" id="noResources" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <p>Aucune ressource dans cette classe</p>
                    <p style="font-size: 0.875rem; margin-top: 0.5rem;">
                        Utilisez le gestionnaire de fichiers pour ajouter des ressources √† cette classe
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Indicateur de sauvegarde -->
<div class="saving-indicator" id="savingIndicator">
    <i class="fas fa-spinner fa-spin"></i>
    <span id="savingText">Sauvegarde...</span>
</div>

<!-- Vue c√¥te-√†-c√¥te pour √©dition avec PDF -->
<div class="split-view-container" id="splitViewContainer">
    <div class="split-view-left">
        <div class="split-view-header">
            <h2>√âditer la planification</h2>
        </div>
        <div id="splitViewPlanningEdit">
            <!-- Le contenu du formulaire sera copi√© ici -->
        </div>
    </div>
    <div class="split-view-right" id="splitViewRight">
        <button class="split-view-close" onclick="closeSplitView()" title="Fermer la vue c√¥te-√†-c√¥te">
            <i class="fas fa-times"></i>
        </button>
        <!-- Le viewer PDF sera int√©gr√© ici -->
    </div>
</div>

<!-- Modal Viewer/Annotateur avec Lecteur PDF Unifi√© -->
<div class="file-viewer-modal" id="fileViewerModal">
    <div class="unified-pdf-viewer-wrapper">
        <!-- Le lecteur PDF unifi√© sera inject√© ici -->
        <div id="unified-pdf-viewer-container"></div>
    </div>
</div>

<script>
// Variables globales
const lessonDate = '{{ lesson_date.strftime("%Y-%m-%d") }}';
const periodNumber = {{ lesson.period_number }};
const endPeriodNumber = {% if lesson.end_period_number %}{{ lesson.end_period_number }}{% else %}{{ lesson.period_number }}{% endif %};
const classroomId = {{ lesson_classroom.id if lesson_classroom else 'null' }};
const mixedGroupId = {{ lesson.mixed_group_id if lesson.mixed_group_id else 'null' }};
let isEditingPlanning = false;
let isSplitViewActive = false;

// Liste des √©l√®ves pour l'autocompl√©tion
const lessonStudents = [
    {% for student in students %}
    {
        id: {{ student.id }},
        first_name: {{ student.first_name | tojson }},
        last_name: {{ student.last_name | tojson }}
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];

// Variables pour le syst√®me de sanctions
let initialSanctionCounts = {};
let sanctionCheckTimer = null;
let sanctionNotificationShown = false;
const NOTIFICATION_TIME_BEFORE_END = 3 * 60 * 1000; // 3 minutes en millisecondes
let checklistStates = {{ (planning.get_checklist_states() if planning else {}) | tojson }};
let checkboxUpdateTimeout = null;
let currentLayout = 'default';

// Fonction pour changer la disposition
function changeLayout(layout) {
    console.log('Changement de disposition vers:', layout);
    currentLayout = layout;
    
    const lessonMain = document.querySelector('.lesson-main');
    const layoutButtons = document.querySelectorAll('.layout-btn');
    const body = document.body;
    
    if (!lessonMain) {
        console.error('Element .lesson-main non trouv√©');
        return;
    }
    
    // Supprimer toutes les classes de layout
    lessonMain.classList.remove('layout-planning-focus', 'layout-resources-focus', 'layout-attendance-focus', 'layout-vertical');
    
    // Ajouter la nouvelle classe si ce n'est pas default
    if (layout !== 'default') {
        const className = `layout-${layout}`;
        console.log('Ajout de la classe:', className);
        lessonMain.classList.add(className);
        
        console.log('Classes actuelles:', lessonMain.className);
        
        // V√©rifier les styles calcul√©s
        const computedStyle = window.getComputedStyle(lessonMain);
        console.log('Grid template columns calcul√©:', computedStyle.gridTemplateColumns);
        console.log('Largeur √©cran:', window.innerWidth + 'px');
    } else {
        console.log('Disposition par d√©faut - aucune classe ajout√©e');
        const computedStyle = window.getComputedStyle(lessonMain);
        console.log('Grid template columns par d√©faut:', computedStyle.gridTemplateColumns);
    }
    
    // Mettre √† jour les boutons actifs
    layoutButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.layout === layout) {
            btn.classList.add('active');
        }
    });
    
    // Sauvegarder la pr√©f√©rence
    localStorage.setItem('lessonLayout', layout);
    
    // Animation de confirmation visuelle
    lessonMain.style.transform = 'scale(0.98)';
    setTimeout(() => {
        lessonMain.style.transform = 'scale(1)';
    }, 150);
    
    // Recalculer la taille du plan de classe si l'onglet est actif
    setTimeout(() => {
        const seatingPlanContent = document.getElementById('seating-plan-content');
        if (seatingPlanContent && seatingPlanContent.classList.contains('active')) {
            console.log('Recalcul de la taille du plan de classe apr√®s changement de layout');
            adjustSeatingScale();
        }
    }, 200);
}

// Initialiser les contr√¥les de disposition
function initLayoutControls() {
    console.log('Initialisation des contr√¥les de disposition');
    
    // Charger la disposition sauvegard√©e
    const savedLayout = localStorage.getItem('lessonLayout') || 'default';
    console.log('Disposition sauvegard√©e:', savedLayout);
    changeLayout(savedLayout);
    
    // Ajouter les event listeners
    const layoutButtons = document.querySelectorAll('.layout-btn');
    console.log('Boutons de disposition trouv√©s:', layoutButtons.length);
    
    layoutButtons.forEach((btn, index) => {
        console.log(`Bouton ${index}:`, btn.dataset.layout);
        btn.addEventListener('click', () => {
            const layout = btn.dataset.layout;
            console.log('Clic sur bouton:', layout);
            changeLayout(layout);
        });
    });
}

// Fonction pour basculer l'√©dition de la planification
function togglePlanningEdit() {
    isEditingPlanning = !isEditingPlanning;

    const planningView = document.getElementById('planningView');
    const planningEdit = document.getElementById('planningEdit');
    const emptyPlanning = document.getElementById('emptyPlanning');
    const memosViewContainer = document.getElementById('memosViewContainer');
    const editBtn = document.querySelector('.edit-planning-btn');
    const editBtnText = document.getElementById('editBtnText');

    if (isEditingPlanning) {
        // Sauvegarder la position de scroll avant toute modification
        const scrollY = window.scrollY;
        const scrollX = window.scrollX;

        // Passer en mode √©dition
        if (planningView) planningView.style.display = 'none';
        if (emptyPlanning) emptyPlanning.style.display = 'none';
        if (memosViewContainer) memosViewContainer.style.display = 'none';
        planningEdit.style.display = 'block';
        editBtnText.textContent = 'Fermer';

        // Attacher la conversion des tirets en checkboxes
        attachDashConversion();

        // Ne pas faire de focus automatique pour √©viter le scroll
        // L'utilisateur peut cliquer o√π il veut

        // Forcer la restauration du scroll apr√®s toutes les op√©rations du navigateur
        requestAnimationFrame(() => {
            window.scrollTo(scrollX, scrollY);
            // Double protection avec un second requestAnimationFrame
            requestAnimationFrame(() => {
                window.scrollTo(scrollX, scrollY);
            });
        });
    } else {
        // Passer en mode lecture
        planningEdit.style.display = 'none';

        // V√©rifier s'il y a du contenu de planification en regardant le titre
        const titleDisplay = document.getElementById('planningTitleDisplay');
        const hasPlanning = titleDisplay && titleDisplay.textContent.trim() &&
                           titleDisplay.textContent !== 'Cours sans titre';

        if (hasPlanning) {
            // Il y a une planification, afficher la vue de lecture
            if (planningView) planningView.style.display = 'block';
            if (emptyPlanning) emptyPlanning.style.display = 'none';
        } else {
            // Pas de planification, afficher l'√©tat vide
            if (planningView) planningView.style.display = 'none';
            if (emptyPlanning) emptyPlanning.style.display = 'block';
        }

        // Toujours afficher les m√©mos en mode lecture
        if (memosViewContainer) memosViewContainer.style.display = 'block';

        editBtnText.textContent = 'Modifier';

        // Recharger les m√©mos/remarques pour la vue en lecture seule
        if (typeof lessonMemosManager !== 'undefined' && lessonMemosManager) {
            lessonMemosManager.loadExistingMemosAndRemarks();
        }
    }
}

// Fonction pour attacher l'auto-conversion des tirets en checkboxes
function attachDashConversion() {
    console.log('üîß attachDashConversion called');
    const textarea = document.getElementById('planningDescription');
    if (!textarea) {
        console.error('‚ùå planningDescription textarea not found!');
        return;
    }
    console.log('‚úÖ Textarea found:', textarea);

    // Sauvegarder le scroll avant clonage
    const windowScrollY = window.scrollY;
    const windowScrollX = window.scrollX;

    // Supprimer les anciens listeners pour √©viter les doublons
    const newTextarea = textarea.cloneNode(true);
    textarea.parentNode.replaceChild(newTextarea, textarea);

    // Restaurer le scroll apr√®s clonage
    window.scrollTo(windowScrollX, windowScrollY);
    console.log('üîÑ Textarea cloned and replaced, scroll restored');

    newTextarea.addEventListener('input', function(e) {
        console.log('‚å®Ô∏è Input event:', {
            inputType: e.inputType,
            data: e.data,
            value: this.value,
            cursorPos: this.selectionStart
        });

        const cursorPos = this.selectionStart;
        const value = this.value;

        // V√©rifier si on vient de taper un tiret en d√©but de ligne
        if (e.inputType === 'insertText' && e.data === '-') {
            console.log('‚ûñ Dash detected!');
            const lines = value.substring(0, cursorPos).split('\n');
            const currentLine = lines[lines.length - 1];
            console.log('üìù Current line:', currentLine, 'trimmed:', currentLine.trim());

            // Si le tiret est au d√©but de la ligne (avec √©ventuellement des espaces avant)
            if (currentLine.trim() === '-') {
                console.log('‚ú® Converting dash to checkbox');
                // Sauvegarder la position de scroll avant modification
                const scrollTop = this.scrollTop;
                const scrollLeft = this.scrollLeft;
                const windowScrollY = window.scrollY;

                // Remplacer le tiret par [ ]
                const beforeCursor = value.substring(0, cursorPos - 1);
                const afterCursor = value.substring(cursorPos);
                const spaces = currentLine.match(/^\s*/)[0]; // Pr√©server l'indentation

                this.value = beforeCursor + spaces + '[ ] ' + afterCursor;

                // Placer le curseur apr√®s [ ]
                const newCursorPos = cursorPos - 1 + spaces.length + 4;
                this.setSelectionRange(newCursorPos, newCursorPos);

                // Restaurer la position de scroll
                this.scrollTop = scrollTop;
                this.scrollLeft = scrollLeft;
                window.scrollTo(0, windowScrollY);
                console.log('‚úÖ Conversion complete, scroll restored');
            }
        }
    });
    console.log('üëÇ Event listener attached');
}

// Fonction pour √©chapper le HTML
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

// Fonction pour mettre √† jour l'√©tat d'une checkbox
async function updateCheckboxState(index, checked) {
    // Mettre √† jour l'√©tat local imm√©diatement
    checklistStates[index] = checked;

    // Afficher l'indicateur de sauvegarde
    showSavingIndicator();

    // Annuler le timeout pr√©c√©dent s'il existe
    if (checkboxUpdateTimeout) {
        clearTimeout(checkboxUpdateTimeout);
    }

    // Sauvegarder avec un petit d√©lai pour √©viter trop de requ√™tes
    checkboxUpdateTimeout = setTimeout(async () => {
        try {
            const response = await fetch('{{ url_for("planning.update_checklist_states") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    date: lessonDate,
                    period_number: periodNumber,
                    checklist_states: checklistStates
                })
            });

            const result = await response.json();

            if (result.success) {
                showSavingIndicator('success', 'Sauvegard√©');
            } else {
                // En cas d'erreur, r√©tablir l'√©tat pr√©c√©dent
                checklistStates[index] = !checked;
                const checkbox = document.getElementById(`checkbox-${index}`);
                if (checkbox) {
                    checkbox.checked = !checked;
                }
                showSavingIndicator('error', 'Erreur de sauvegarde');
            }
        } catch (error) {
            console.error('Erreur:', error);
            // En cas d'erreur, r√©tablir l'√©tat pr√©c√©dent
            checklistStates[index] = !checked;
            const checkbox = document.getElementById(`checkbox-${index}`);
            if (checkbox) {
                checkbox.checked = !checked;
            }
            showSavingIndicator('error', 'Erreur de connexion');
        }
    }, 500); // D√©lai de 500ms pour regrouper les changements
}

// Fonction pour afficher l'indicateur de sauvegarde
function showSavingIndicator(status = 'saving', message = 'Sauvegarde...') {
    const indicator = document.getElementById('savingIndicator');
    const text = document.getElementById('savingText');
    const icon = indicator.querySelector('i');

    // R√©initialiser les classes
    indicator.className = 'saving-indicator show';

    if (status === 'saving') {
        icon.className = 'fas fa-spinner fa-spin';
        text.textContent = message;
    } else if (status === 'success') {
        indicator.classList.add('success');
        icon.className = 'fas fa-check';
        text.textContent = message;
    } else if (status === 'error') {
        indicator.classList.add('error');
        icon.className = 'fas fa-exclamation-triangle';
        text.textContent = message;
    }

    // Masquer apr√®s 2 secondes si c'est un succ√®s ou une erreur
    if (status !== 'saving') {
        setTimeout(() => {
            indicator.classList.remove('show');
        }, 2000);
    }
}

// Fonction pour annuler l'√©dition
function cancelPlanningEdit() {
    // Restaurer les valeurs d'origine
    const titleDisplay = document.getElementById('planningTitleDisplay');
    const descriptionDisplay = document.getElementById('planningDescriptionDisplay');

    if (titleDisplay && titleDisplay.textContent !== 'Cours sans titre') {
        document.getElementById('planningTitle').value = titleDisplay.textContent;

        // R√©cup√©rer la description originale depuis les donn√©es du serveur
        {% if planning %}
        document.getElementById('planningDescription').value = {{ planning.description | tojson }};
        {% else %}
        document.getElementById('planningDescription').value = '';
        {% endif %}
    }

    togglePlanningEdit();
}

// Fonction pour sauvegarder la planification
async function savePlanning(event) {
    event.preventDefault();

    const title = document.getElementById('planningTitle').value.trim();
    const description = document.getElementById('planningDescription').value.trim();

    const submitButton = event.target.querySelector('button[type="submit"]');
    const originalText = submitButton.innerHTML;

    // D√©sactiver le bouton et afficher un loader
    submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Enregistrement...';

    try {
        const response = await fetch('{{ url_for("planning.save_lesson_planning") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                date: lessonDate,
                period_number: periodNumber,
                classroom_id: classroomId,
                title: title,
                description: description,
                checklist_states: checklistStates
            })
        });

        const result = await response.json();

        if (result.success) {
            // Recharger la page pour afficher les changements
            window.location.reload();
        } else {
            showPlanningNotification('error', result.message || 'Erreur lors de l\'enregistrement');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showPlanningNotification('error', 'Erreur lors de la communication avec le serveur');
    } finally {
        submitButton.disabled = false;
        submitButton.innerHTML = originalText;
    }
}

// Fonction pour afficher une notification
function showPlanningNotification(type, message) {
    // Cr√©er le conteneur de notifications s'il n'existe pas
    let container = document.querySelector('.notifications-container');
    if (!container) {
        container = document.createElement('div');
        container.className = 'notifications-container';
        container.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 1000;';
        document.body.appendChild(container);
    }

    // Cr√©er la notification
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        background-color: ${type === 'success' ? '#D1FAE5' : '#FEE2E2'};
        color: ${type === 'success' ? '#065F46' : '#991B1B'};
        padding: 1rem 1.5rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideInNotification 0.3s ease;
        max-width: 400px;
    `;

    const icon = document.createElement('i');
    icon.className = `fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}`;

    const text = document.createElement('span');
    text.textContent = message;

    notification.appendChild(icon);
    notification.appendChild(text);
    container.appendChild(notification);

    // Supprimer la notification apr√®s 5 secondes
    setTimeout(() => {
        notification.style.animation = 'slideOutNotification 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 5000);
}

// Fonction pour basculer entre pr√©sent/absent
async function toggleAttendance(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const currentStatus = studentElement.dataset.status;
    let newStatus;

    // Cycle: present -> absent -> present (ignorer late dans le cycle)
    if (currentStatus === 'present' || currentStatus === 'late') {
        newStatus = 'absent';
    } else {
        newStatus = 'present';
    }

    // R√©initialiser le champ de retard
    const lateInput = document.getElementById(`late-${studentId}`);
    lateInput.value = '';

    await updateAttendance(studentId, newStatus, null);
}

// Fonction pour ajuster les minutes de retard avec les boutons +/-
async function adjustLateMinutes(studentId, delta) {
    const lateInput = document.getElementById(`late-${studentId}`);
    const currentValue = parseInt(lateInput.value) || 0;
    const newValue = Math.max(0, Math.min(120, currentValue + delta));

    lateInput.value = newValue > 0 ? newValue : '';

    // Si la valeur est > 0, marquer automatiquement en retard
    if (newValue > 0) {
        await updateAttendance(studentId, 'late', newValue);
    } else {
        // Si on descend √† 0, remettre pr√©sent
        await updateAttendance(studentId, 'present', null);
    }
}

// Fonction pour marquer un √©l√®ve en retard (toggle)
async function setLateStatus(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const lateInput = document.getElementById(`late-${studentId}`);

    // V√©rifier le statut actuel de l'√©l√®ve
    const isCurrentlyLate = studentElement.classList.contains('late');

    if (isCurrentlyLate) {
        // Si d√©j√† en retard, remettre pr√©sent
        await updateAttendance(studentId, 'present', null);
    } else {
        // Sinon, marquer en retard
        const minutes = lateInput.value;

        if (!minutes || minutes <= 0) {
            alert('Veuillez entrer le nombre de minutes de retard');
            return;
        }

        await updateAttendance(studentId, 'late', parseInt(minutes));
    }
}

// Fonction pour mettre √† jour l'apparence des boutons selon le statut
function updateAttendanceButtons(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const lateButton = studentElement.querySelector('.btn-late');
    
    if (studentElement.classList.contains('late')) {
        // √âl√®ve en retard - bouton pour remettre pr√©sent
        lateButton.title = 'Remettre pr√©sent';
        lateButton.innerHTML = '<i class="fas fa-undo"></i>';
    } else {
        // √âl√®ve pr√©sent ou absent - bouton pour marquer en retard
        lateButton.title = 'Marquer en retard';
        lateButton.innerHTML = '<i class="fas fa-clock"></i>';
    }
}

// Fonction pour envoyer la mise √† jour au serveur
async function updateAttendance(studentId, status, lateMinutes) {
    try {
        const response = await fetch('{{ url_for("planning.update_attendance") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                student_id: studentId,
                classroom_id: classroomId,
                date: lessonDate,
                period_number: periodNumber,
                status: status,
                late_minutes: lateMinutes
            })
        });

        const result = await response.json();

        if (result.success) {
            // Mettre √† jour l'interface
            const studentElement = document.getElementById(`student-${studentId}`);
            const lateInput = document.getElementById(`late-${studentId}`);

            // Retirer toutes les classes de statut
            studentElement.classList.remove('present', 'absent', 'late');

            // Ajouter la nouvelle classe
            studentElement.classList.add(status);
            studentElement.dataset.status = status;

            // Si ce n'est pas un retard, vider le champ
            if (status !== 'late') {
                lateInput.value = '';
            }

            // Mettre √† jour l'apparence des boutons
            updateAttendanceButtons(studentId);

            // Mettre √† jour les statistiques
            updateStats();

            // Afficher une notification visuelle
            showQuickNotification(studentElement, status);
        } else {
            alert('Erreur lors de la mise √† jour de la pr√©sence');
        }
    } catch (error) {
        console.error('Erreur:', error);
        alert('Erreur lors de la communication avec le serveur');
    }
}

// Fonction pour afficher une notification rapide
function showQuickNotification(element, status) {
    element.style.transform = 'scale(0.95)';
    setTimeout(() => {
        element.style.transform = 'scale(1)';
    }, 200);
}

// Permettre d'entrer le retard avec Enter
document.addEventListener('DOMContentLoaded', function() {
    // D√©tecter si on est sur iOS/iPad
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // Variable pour stocker la position de scroll avant l'apparition du clavier
    let savedScrollPosition = 0;
    let savedScrollContainer = null;

    // Emp√™cher le scroll automatique lors du focus sur les inputs
    const preventScrollOnFocus = (e) => {
        if (e.target.matches('input, textarea, select')) {
            // Sauvegarder la position de scroll actuelle
            if (isIOS) {
                savedScrollContainer = document.querySelector('.lesson-container') || window;
                savedScrollPosition = savedScrollContainer === window ?
                    window.scrollY : savedScrollContainer.scrollTop;
            } else {
                const scrollY = window.scrollY;
                const scrollX = window.scrollX;
                setTimeout(() => {
                    window.scrollTo(scrollX, scrollY);
                }, 0);
            }
        }
    };

    // Sur iOS, restaurer la position apr√®s que le clavier soit apparu
    const restoreScrollOnBlur = (e) => {
        if (isIOS && e.target.matches('input, textarea, select')) {
            setTimeout(() => {
                if (savedScrollContainer) {
                    if (savedScrollContainer === window) {
                        window.scrollTo(0, savedScrollPosition);
                    } else {
                        savedScrollContainer.scrollTop = savedScrollPosition;
                    }
                }
            }, 100);
        }
    };

    document.addEventListener('focus', preventScrollOnFocus, true);
    document.addEventListener('blur', restoreScrollOnBlur, true);

    // Emp√™cher le resize du viewport de provoquer un scroll sur iOS
    if (isIOS) {
        let lastHeight = window.innerHeight;
        window.addEventListener('resize', () => {
            const currentHeight = window.innerHeight;
            // Le clavier appara√Æt (viewport r√©duit)
            if (currentHeight < lastHeight) {
                // Ne rien faire, garder la position
                if (savedScrollContainer) {
                    if (savedScrollContainer === window) {
                        window.scrollTo(0, savedScrollPosition);
                    } else {
                        savedScrollContainer.scrollTop = savedScrollPosition;
                    }
                }
            }
            lastHeight = currentHeight;
        });
    }

    // Red√©finir la m√©thode focus pour tous les inputs avec preventScroll
    document.querySelectorAll('input, textarea, select').forEach(element => {
        const originalFocus = element.focus;
        element.focus = function(options) {
            originalFocus.call(this, { ...options, preventScroll: true });
        };
    });

    // Initialiser les contr√¥les de disposition
    initLayoutControls();

    // Initialiser les statistiques
    updateStats();

    // Ajouter l'√©v√©nement Enter sur tous les champs de retard
    document.querySelectorAll('.late-minutes').forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const studentId = this.id.replace('late-', '');
                setLateStatus(parseInt(studentId));
            }
        });
    });

    // G√©rer les raccourcis clavier pour la planification
    document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + E pour √©diter la planification
        if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
            e.preventDefault();
            if (!isEditingPlanning) {
                togglePlanningEdit();
            }
        }

        // Escape pour annuler l'√©dition
        if (e.key === 'Escape' && isEditingPlanning) {
            cancelPlanningEdit();
        }
    });
});

// Fonction pour mettre √† jour les statistiques
// IMPORTANT: Cibler uniquement .attendance-section pour √©viter de compter
// en double les √©l√©ments dupliqu√©s dans le modal de gestion de classe du PDF viewer
function updateStats() {
    let present = 0;
    let absent = 0;
    let late = 0;

    document.querySelectorAll('.attendance-section .student-attendance').forEach(student => {
        const status = student.dataset.status;
        if (status === 'present') present++;
        else if (status === 'absent') absent++;
        else if (status === 'late') late++;
    });

    document.getElementById('presentCount').textContent = present;
    document.getElementById('absentCount').textContent = absent;
    document.getElementById('lateCount').textContent = late;
}

// Variables pour la gestion des ressources
let currentFolderPath = '';
let classResources = [];

// Charger les ressources de la classe au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    loadClassResources();
});

// Fonction pour charger les ressources de la classe
async function loadClassResources() {
    try {
        showResourcesLoading(true);
        
        // V√©rifier qu'on a un classroomId valide
        if (!classroomId || classroomId === 'null') {
            showNoResources();
            return;
        }
        
        const response = await fetch(`{{ url_for('planning.get_class_resources', classroom_id=0) }}`.replace('0', classroomId));
        const result = await response.json();
        
        if (result.success) {
            classResources = result.files || [];
            await renderResources(result.pinned_files || [], classResources);
        } else {
            showNoResources();
        }
    } catch (error) {
        console.error('Erreur lors du chargement des ressources:', error);
        showNoResources();
    } finally {
        showResourcesLoading(false);
    }
}

// Fonction pour afficher/masquer le chargement
function showResourcesLoading(show) {
    const loadingElement = document.getElementById('resourcesLoading');
    if (loadingElement) {
        loadingElement.style.display = show ? 'block' : 'none';
    }
}

// Fonction pour afficher l'√©tat vide
function showNoResources() {
    const noResourcesElement = document.getElementById('noResources');
    const pinnedElement = document.getElementById('pinnedResources');
    const navigationElement = document.getElementById('folderNavigation');
    const treeElement = document.getElementById('resourcesTree');
    
    if (noResourcesElement) noResourcesElement.style.display = 'block';
    if (pinnedElement) pinnedElement.style.display = 'none';
    if (navigationElement) navigationElement.style.display = 'none';
    if (treeElement) treeElement.style.display = 'none';
}

// Fonction pour rendre les ressources
async function renderResources(pinnedFiles, allFiles) {
    const pinnedElement = document.getElementById('pinnedResources');
    const navigationElement = document.getElementById('folderNavigation');
    const treeElement = document.getElementById('resourcesTree');
    const noResourcesElement = document.getElementById('noResources');

    // Masquer l'√©tat vide
    if (noResourcesElement) noResourcesElement.style.display = 'none';

    // Afficher les ressources √©pingl√©es
    if (pinnedFiles && pinnedFiles.length > 0) {
        renderPinnedResources(pinnedFiles);
        if (pinnedElement) pinnedElement.style.display = 'block';
    } else {
        if (pinnedElement) pinnedElement.style.display = 'none';
    }

    // √Ä la racine, passer tous les fichiers √† renderResourceTree pour qu'elle puisse extraire les dossiers
    // Dans un dossier sp√©cifique, filtrer seulement les fichiers de ce dossier
    let filesToDisplay;
    if (!currentFolderPath) {
        // √Ä la racine : passer tous les fichiers
        filesToDisplay = allFiles;
    } else {
        // Dans un dossier : filtrer
        filesToDisplay = filterFilesByFolder(allFiles, currentFolderPath);
    }

    // Afficher la navigation
    renderBreadcrumb();
    if (navigationElement) navigationElement.style.display = 'block';

    // Afficher les feuilles blanches (uniquement √† la racine)
    if (!currentFolderPath) {
        await renderBlankSheets();
    }

    // Afficher l'arborescence
    renderResourceTree(filesToDisplay);
    if (treeElement) treeElement.style.display = 'block';
}

// Fonction pour rendre les ressources √©pingl√©es
function renderPinnedResources(pinnedFiles) {
    const pinnedList = document.getElementById('pinnedList');
    if (!pinnedList) return;
    
    pinnedList.innerHTML = pinnedFiles.map(file => {
        const isAnnotatable = ['pdf', 'png', 'jpg', 'jpeg'].includes(file.file_type.toLowerCase());
        
        return `
            <div class="resource-item pinned" data-file-id="${file.id}">
                <div class="resource-icon ${getResourceIconClass(file.file_type)}">
                    <i class="fas ${getResourceIcon(file.file_type)}"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name ${isAnnotatable ? 'clickable-file' : ''}" 
                             ${isAnnotatable ? `onclick="openFileViewer(${file.id}, '${file.original_filename}', '${file.file_type}')"` : ''}>
                            ${file.original_filename}
                        </div>
                        <div class="resource-meta">
                            <span>${formatFileSize(file.file_size)}</span>
                            <span>√âpingl√©</span>
                            ${isAnnotatable ? '<span class="annotatable-badge">‚úèÔ∏è Annotable</span>' : ''}
                        </div>
                    </div>
                    <div class="resource-actions">
                        <button class="resource-action-btn pinned" onclick="togglePinResource(${file.id})" title="D√©s√©pingler">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Fonction pour filtrer les fichiers par dossier
function filterFilesByFolder(files, folderPath) {
    return files.filter(file => {
        if (!folderPath) {
            // Racine : fichiers sans dossier ou dossier vide
            return !file.folder_path || file.folder_path === '';
        } else {
            // Dossier sp√©cifique : fichiers dans ce dossier exact OU dans ses sous-dossiers
            return file.folder_path === folderPath || 
                   (file.folder_path && file.folder_path.startsWith(folderPath + '/'));
        }
    });
}

// Fonction pour rendre le fil d'ariane
function renderBreadcrumb() {
    const breadcrumb = document.getElementById('resourceBreadcrumb');
    if (!breadcrumb) return;
    
    let html = `
        <span class="breadcrumb-item ${currentFolderPath === '' ? 'active' : ''}" 
              data-path="" onclick="navigateToFolder('')">
            <i class="fas fa-home"></i> Racine
        </span>
    `;
    
    if (currentFolderPath) {
        const pathParts = currentFolderPath.split('/');
        let currentPath = '';
        
        pathParts.forEach((part, index) => {
            currentPath += (index > 0 ? '/' : '') + part;
            const isLast = index === pathParts.length - 1;
            
            html += `
                <span class="breadcrumb-separator">/</span>
                <span class="breadcrumb-item ${isLast ? 'active' : ''}" 
                      data-path="${currentPath}" onclick="navigateToFolder('${currentPath}')">
                    ${part}
                </span>
            `;
        });
    }
    
    breadcrumb.innerHTML = html;
}

// Fonction pour rendre l'arborescence des ressources
function renderResourceTree(files) {
    const treeElement = document.getElementById('resourcesTree');
    if (!treeElement) return;
    
    // Organiser les fichiers par dossiers et fichiers
    const folders = new Set();
    const regularFiles = [];
    
    files.forEach(file => {
        if (file.folder_path) {
            if (!currentFolderPath) {
                // √Ä la racine : extraire le premier niveau de dossier
                const topLevelFolder = file.folder_path.split('/')[0];
                folders.add(topLevelFolder);
            } else if (file.folder_path.startsWith(currentFolderPath + '/') || file.folder_path === currentFolderPath) {
                // Dans un dossier : v√©rifier si le fichier est exactement dans ce dossier ou dans un sous-dossier
                if (file.folder_path === currentFolderPath) {
                    // Fichier directement dans ce dossier
                    regularFiles.push(file);
                } else {
                    // Extraire le dossier suivant
                    const relativePath = file.folder_path.substring(currentFolderPath.length + 1);
                    const nextFolder = relativePath.split('/')[0];
                    if (nextFolder && nextFolder !== '') {
                        folders.add(nextFolder);
                    }
                }
            }
        } else {
            // Fichier sans dossier (directement √† la racine)
            if (!currentFolderPath) {
                regularFiles.push(file);
            }
        }
    });
    
    let html = '';
    
    // Afficher les dossiers
    Array.from(folders).sort().forEach(folderName => {
        const folderPath = currentFolderPath ? `${currentFolderPath}/${folderName}` : folderName;
        html += `
            <div class="resource-item folder" onclick="navigateToFolder('${folderPath}')">
                <div class="resource-icon folder">
                    <i class="fas fa-folder"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name">${folderName}</div>
                        <div class="resource-meta">
                            <span>Dossier</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    
    // Afficher les fichiers
    regularFiles.forEach(file => {
        const isPinned = file.is_pinned;
        const isAnnotatable = ['pdf', 'png', 'jpg', 'jpeg'].includes(file.file_type.toLowerCase());
        
        html += `
            <div class="resource-item ${isPinned ? 'pinned' : ''}" data-file-id="${file.id}">
                <div class="resource-icon ${getResourceIconClass(file.file_type)}">
                    <i class="fas ${getResourceIcon(file.file_type)}"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name ${isAnnotatable ? 'clickable-file' : ''}" 
                             ${isAnnotatable ? `onclick="openFileViewer(${file.id}, '${file.original_filename}', '${file.file_type}')"` : ''}>
                            ${file.original_filename}
                        </div>
                        <div class="resource-meta">
                            <span>${formatFileSize(file.file_size)}</span>
                            ${file.uploaded_at ? `<span>${formatDate(file.uploaded_at)}</span>` : ''}
                            ${isAnnotatable ? '<span class="annotatable-badge">‚úèÔ∏è Annotable</span>' : ''}
                        </div>
                    </div>
                    <div class="resource-actions">
                        <button class="resource-action-btn ${isPinned ? 'pinned' : ''}" 
                                onclick="togglePinResource(${file.id})" 
                                title="${isPinned ? 'D√©s√©pingler' : '√âpingler'}">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    });
    
    treeElement.innerHTML = html || '<p style="text-align: center; color: #6B7280; padding: 2rem;">Aucun fichier dans ce dossier</p>';
}

// Fonction pour charger et afficher les feuilles blanches de la le√ßon
async function renderBlankSheets() {
    const lessonDate = '{{ lesson_date.strftime("%Y-%m-%d") if lesson_date else "" }}';
    const periodNumber = {{ lesson.period_number if lesson else 0 }};
    const classroomId = {{ lesson_classroom.id if lesson_classroom else 'null' }};

    console.log('üìÑ renderBlankSheets appel√©e - date:', lessonDate, 'p√©riode:', periodNumber, 'classe:', classroomId);

    if (!lessonDate || !periodNumber) {
        console.warn('‚ö†Ô∏è renderBlankSheets: lessonDate ou periodNumber manquant');
        return;
    }

    try {
        const response = await fetch(`/planning/api/blank-sheets/list?date=${lessonDate}&period=${periodNumber}&classroom_id=${classroomId}`);
        const data = await response.json();

        console.log('üìã renderBlankSheets: Donn√©es re√ßues:', data);

        if (data.success && data.sheets && data.sheets.length > 0) {
            console.log('‚úÖ renderBlankSheets: Affichage de', data.sheets.length, 'feuilles blanches');
            const resourcesTree = document.getElementById('resourcesTree');
            if (!resourcesTree) return;

            // Cr√©er la section des feuilles blanches
            const blankSheetsSection = document.createElement('div');
            blankSheetsSection.className = 'blank-sheets-section';
            blankSheetsSection.innerHTML = `
                <h4 class="section-subtitle">
                    <i class="fas fa-file"></i> Feuilles blanches
                </h4>
                <div class="blank-sheets-list">
                    ${data.sheets.map(sheet => `
                        <div class="resource-item blank-sheet" data-sheet-id="${sheet.id}">
                            <div class="resource-icon blank-sheet-icon">
                                <i class="fas fa-file"></i>
                            </div>
                            <div class="resource-info">
                                <div class="resource-main">
                                    <div class="resource-name clickable-file">${escapeHtml(sheet.title)}</div>
                                    <div class="resource-meta">
                                        <span>${formatDateTime(sheet.created_at)}</span>
                                        <span class="annotatable-badge">‚úèÔ∏è Annotable</span>
                                    </div>
                                </div>
                            </div>
                            <button class="btn-delete-blank-sheet" data-sheet-id="${sheet.id}" title="Supprimer la feuille blanche">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `).join('')}
                </div>
            `;

            // Ins√©rer avant le contenu actuel (au d√©but de l'arborescence)
            resourcesTree.insertBefore(blankSheetsSection, resourcesTree.firstChild);
            console.log('‚úÖ renderBlankSheets: Section ajout√©e au DOM');

            // Attacher les event listeners apr√®s l'insertion dans le DOM
            blankSheetsSection.querySelectorAll('.resource-item.blank-sheet').forEach(item => {
                const sheetId = parseInt(item.dataset.sheetId);
                const icon = item.querySelector('.resource-icon');
                const info = item.querySelector('.resource-info');

                // Click sur l'ic√¥ne ou les infos pour ouvrir la feuille
                if (icon) {
                    icon.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Click sur feuille blanche ID:', sheetId);
                        openExistingBlankSheet(sheetId);
                    });
                }
                if (info) {
                    info.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Click sur feuille blanche ID:', sheetId);
                        openExistingBlankSheet(sheetId);
                    });
                }
            });

            // Attacher les event listeners pour les boutons de suppression
            blankSheetsSection.querySelectorAll('.btn-delete-blank-sheet').forEach(btn => {
                const sheetId = parseInt(btn.dataset.sheetId);
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    deleteBlankSheet(sheetId);
                });
            });
        } else {
            console.log('‚ÑπÔ∏è renderBlankSheets: Aucune feuille blanche √† afficher');
        }
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement des feuilles blanches:', error);
    }
}

// Fonction utilitaire pour √©chapper le HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Fonction pour formater une date ISO en format lisible
function formatDateTime(isoString) {
    if (!isoString) return '';
    const date = new Date(isoString);
    const options = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' };
    return date.toLocaleDateString('fr-FR', options);
}

// Fonction pour naviguer vers un dossier
async function navigateToFolder(folderPath) {
    currentFolderPath = folderPath;

    // Utiliser la m√™me logique que dans renderResources
    let filesToDisplay;
    if (!currentFolderPath) {
        // √Ä la racine : passer tous les fichiers
        filesToDisplay = classResources;
    } else {
        // Dans un dossier : filtrer
        filesToDisplay = filterFilesByFolder(classResources, currentFolderPath);
    }

    renderBreadcrumb();

    // Afficher les feuilles blanches seulement √† la racine
    if (!currentFolderPath) {
        await renderBlankSheets();
    }

    renderResourceTree(filesToDisplay);
}

// Fonction pour √©pingler/d√©s√©pingler une ressource
async function togglePinResource(fileId) {
    try {
        const response = await fetch('{{ url_for("planning.toggle_pin_resource") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_id: fileId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Recharger les ressources pour refl√©ter les changements
            await loadClassResources();
        } else {
            console.error('Erreur lors de l\'√©pinglage:', result.message);
        }
    } catch (error) {
        console.error('Erreur lors de l\'√©pinglage:', error);
    }
}

// Fonction pour actualiser les ressources
function refreshResources() {
    loadClassResources();
}

// Fonctions utilitaires
function getResourceIcon(fileType) {
    switch(fileType) {
        case 'pdf': return 'fa-file-pdf';
        case 'png':
        case 'jpg':
        case 'jpeg': return 'fa-file-image';
        default: return 'fa-file';
    }
}

function getResourceIconClass(fileType) {
    switch(fileType) {
        case 'pdf': return 'pdf';
        case 'png':
        case 'jpg':
        case 'jpeg': return 'image';
        default: return '';
    }
}

function formatFileSize(bytes) {
    if (!bytes) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('fr-FR');
}

{% if is_current %}
// Gestion du timer
let timerInterval;
let isPaused = false;
let remainingSeconds = {{ remaining_seconds }};

function updateTimer() {
    if (!isPaused && remainingSeconds > 0) {
        remainingSeconds--;

        const hours = Math.floor(remainingSeconds / 3600);
        const minutes = Math.floor((remainingSeconds % 3600) / 60);
        const seconds = remainingSeconds % 60;

        let display = '';
        if (hours > 0) {
            display = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } else {
            display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        document.getElementById('lessonTimer').textContent = display;

        if (remainingSeconds === 0) {
            clearInterval(timerInterval);
            alert('Le cours est termin√© !');
        }
    }
}

function toggleTimer() {
    isPaused = !isPaused;
    const icon = document.getElementById('timerIcon');
    icon.className = isPaused ? 'fas fa-play' : 'fas fa-pause';
}

// D√©marrer le timer
timerInterval = setInterval(updateTimer, 1000);
{% endif %}

// =================== HORLOGE EN TEMPS R√âEL ===================
function updateClock() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    
    const clockElement = document.getElementById('currentClock');
    if (clockElement) {
        clockElement.textContent = `${hours}:${minutes}:${seconds}`;
    }
}

// Mettre √† jour l'horloge toutes les secondes
setInterval(updateClock, 1000);
// Afficher l'heure imm√©diatement
updateClock();

{% if is_current %}
// Nettoyer √† la fermeture de la page
window.addEventListener('beforeunload', () => {
    clearInterval(timerInterval);
    
    // Sauvegarder les annotations si le viewer est ouvert
    if (currentFileId && annotations.length > 0) {
        // Utiliser sendBeacon pour une sauvegarde synchrone lors de la fermeture
        const data = JSON.stringify({
            file_id: currentFileId,
            annotations: annotations
        });
        
        // sendBeacon est plus fiable que fetch lors de beforeunload
        navigator.sendBeacon('/planning/save_file_annotations', new Blob([data], {type: 'application/json'}));
    }
});
{% endif %}

// =================== SYST√àME D'ANNOTATION ===================

// Variables globales pour l'annotation am√©lior√©e
let currentFileId = null;
let currentAnnotationTool = 'pen';
let currentTool = 'pen'; // Variable manquante
let currentColor = '#000000';
let currentAnnotationColor = '#ff0000'; // Variable pour les annotations
let currentStrokeWidth = 3;
let isDrawing = false;
let isNavigating = false; // Nouveau: indique qu'on est en train de naviguer entre pages
let isLoadingInitialAnnotations = false; // Indique qu'on charge les annotations initiales
let annotations = []; // Annotations de la page actuelle (pour compatibilit√©)
let annotationsByPage = {}; // Nouveau: annotations organis√©es par num√©ro de page
let currentStroke = [];
let undoHistory = [];
let undoHistoryByPage = {}; // Historique d'annulation par page
let saveTimeout = null;

// Variables simplifi√©es

// Variables PDF
let pdfDoc = null;
let currentPageNum = 1;
let pageIsRendering = false;
let pageNumIsPending = null;
let currentScale = 1.0;
let pdfCanvas = null;
let pdfCtx = null;
let annotationCanvas = null;
let annotationCtx = null;
// Variables de compatibilit√©
let canvas = null;
let ctx = null;

// Charger PDF.js si pas d√©j√† fait
if (typeof pdfjsLib === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
    script.onload = () => {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    };
    document.head.appendChild(script);
}

// Fonction openFileViewer redirig√©e vers le nouveau lecteur unifi√©
async function openFileViewer(fileId, filename, fileType) {
    console.log('üîÑ Redirection vers le lecteur unifi√©:', filename, fileType);
    
    // Si l'√©diteur de planification est actif, ouvrir en vue split
    if (isEditingPlanning) {
        openSplitView(fileId, filename, fileType);
        return;
    }
    
    // Pour les PDF, utiliser le nouveau lecteur unifi√©
    if (fileType.toLowerCase() === 'pdf') {
        openFileWithUnifiedViewer(fileId, filename);
        return;
    }
    
    // Pour les autres types de fichiers, rediriger vers l'ouverture simple
    window.open(`/file_manager/serve_file/${encodeURIComponent(fileId)}`, '_blank');
}

// Initialiser les canvas
function initializeCanvases() {
    // En mode multi-pages, les canvas sont cr√©√©s dynamiquement
    // Cette fonction reste pour la compatibilit√©
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (pagesContainer) {
        // Mode multi-pages - rien √† faire ici
        return;
    }
    
    // Mode single page (ancien mode)
    pdfCanvas = document.getElementById('pdfCanvas');
    annotationCanvas = document.getElementById('annotationCanvas');
    
    if (pdfCanvas && annotationCanvas) {
        pdfCtx = pdfCanvas.getContext('2d');
        annotationCtx = annotationCanvas.getContext('2d');
        
        // Variables de compatibilit√© pour les autres fonctions
        canvas = annotationCanvas;
        ctx = annotationCtx;
        
        // Am√©liorer la qualit√© du rendu
        pdfCtx.imageSmoothingEnabled = true;
        pdfCtx.imageSmoothingQuality = 'high';
        annotationCtx.imageSmoothingEnabled = true;
        annotationCtx.imageSmoothingQuality = 'high';
        
        // Forcer le bon positionnement du canvas d'annotation
        forceCanvasPositioning();
    }
}

// Fonction pour forcer le bon positionnement du canvas
function forceCanvasPositioning() {
    if (!annotationCanvas || !pdfCanvas) return;
    
    console.log('üîß Aligning annotation canvas with PDF canvas...');
    
    // Assurer que les canvas ont exactement les m√™mes dimensions logiques
    annotationCanvas.width = pdfCanvas.width;
    annotationCanvas.height = pdfCanvas.height;
    
    // Obtenir les rectangles de position pour diagnostic
    const pdfRect = pdfCanvas.getBoundingClientRect();
    
    // Copier TOUS les styles computed du PDF canvas pour garantir un alignement parfait
    const pdfComputedStyle = window.getComputedStyle(pdfCanvas);
    
    // Assurer que les canvas ont exactement les m√™mes styles CSS
    annotationCanvas.style.position = 'absolute';
    annotationCanvas.style.top = '0px';
    annotationCanvas.style.left = '0px';
    
    // IMPORTANT: Copier les dimensions exactement du PDF canvas
    // Les dimensions CSS doivent √™tre les dimensions logiques (avant transformation)
    if (pdfCanvas.style.width) {
        annotationCanvas.style.width = pdfCanvas.style.width;
    } else {
        // Si pas de style explicite, utiliser les dimensions logiques
        annotationCanvas.style.width = pdfCanvas.width + 'px';
    }
    
    if (pdfCanvas.style.height) {
        annotationCanvas.style.height = pdfCanvas.style.height;
    } else {
        // Si pas de style explicite, utiliser les dimensions logiques
        annotationCanvas.style.height = pdfCanvas.height + 'px';
    }
    
    // Copier la transformation et l'origine exactement
    annotationCanvas.style.transform = pdfComputedStyle.transform;
    annotationCanvas.style.transformOrigin = pdfComputedStyle.transformOrigin;
    
    annotationCanvas.style.zIndex = '100'; // Au-dessus du PDF
    annotationCanvas.style.pointerEvents = 'auto';
    
    // S'assurer que le conteneur est configur√© correctement
    const container = pdfCanvas.parentElement;
    if (container) {
        container.style.position = 'relative';
    }
    
    // V√©rifier l'alignement apr√®s positionnement
    requestAnimationFrame(() => {
        const annotationRect = annotationCanvas.getBoundingClientRect();
        const pdfRectAfter = pdfCanvas.getBoundingClientRect();
        
        console.log('‚úÖ Canvas alignment completed');
        console.log('  üìè PDF Canvas logical:', pdfCanvas.width, 'x', pdfCanvas.height);
        console.log('  üìè PDF Canvas visible:', Math.round(pdfRectAfter.width), 'x', Math.round(pdfRectAfter.height));
        console.log('  üìè Annotation Canvas logical:', annotationCanvas.width, 'x', annotationCanvas.height);
        console.log('  üìè Annotation Canvas visible:', Math.round(annotationRect.width), 'x', Math.round(annotationRect.height));
        console.log('  üé® CSS width match:', annotationCanvas.style.width, '===', pdfCanvas.style.width || pdfComputedStyle.width);
        console.log('  üé® CSS height match:', annotationCanvas.style.height, '===', pdfCanvas.style.height || pdfComputedStyle.height);
        console.log('  üìç Position alignment:', 
            Math.abs(pdfRectAfter.left - annotationRect.left) < 1 && Math.abs(pdfRectAfter.top - annotationRect.top) < 1);
        console.log('  üìç Size alignment:', 
            Math.abs(pdfRectAfter.width - annotationRect.width) < 1 && Math.abs(pdfRectAfter.height - annotationRect.height) < 1);
        console.log('  ‚öñÔ∏è  Scale factor X:', Math.round(annotationCanvas.width / annotationRect.width * 100) / 100);
        console.log('  ‚öñÔ∏è  Scale factor Y:', Math.round(annotationCanvas.height / annotationRect.height * 100) / 100);
        
        // Si les tailles ne correspondent pas, forcer la correction
        if (Math.abs(pdfRectAfter.width - annotationRect.width) > 1) {
            console.warn('‚ö†Ô∏è  Size mismatch detected! Forcing correction...');
            annotationCanvas.style.width = pdfRectAfter.width + 'px';
            annotationCanvas.style.height = pdfRectAfter.height + 'px';
        }
        
        // üî• CRITIQUE: Redessiner les annotations apr√®s l'alignement car le redimensionnement les efface
        if (annotations.length > 0) {
            console.log('üé® REDESSINAGE APR√àS ALIGNEMENT:', annotations.length, 'annotations');
            redrawAnnotations();
        }
    });
}

// Charger PDF.js de mani√®re asynchrone
function loadPDFJS() {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        script.onload = () => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            resolve();
        };
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Charger un PDF avec qualit√© am√©lior√©e
async function loadPDF(fileId) {
    const pdfUrl = `/file_manager/serve_file/${fileId}`;
    
    // Initialiser les variables d'annotation
    currentTool = 'pen';
    currentColor = '#000000';
    currentAnnotationColor = '#ff0000';
    currentStrokeWidth = 3;
    
    // V√©rifier que PDF.js est charg√©
    if (typeof pdfjsLib === 'undefined') {
        await loadPDFJS();
    }
    
    try {
        // Charger le PDF avec qualit√© am√©lior√©e
        const loadingTask = pdfjsLib.getDocument({
            url: pdfUrl,
            cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
            cMapPacked: true,
            useSystemFonts: true
        });
        
        pdfDoc = await loadingTask.promise;
        console.log('PDF charg√©, nombre de pages:', pdfDoc.numPages);
        
        // Mettre √† jour l'interface
        updatePageInfo();
        
        // G√©n√©rer les miniatures
        await generateThumbnails();
        
        // Rendre toutes les pages en mode scroll
        await renderAllPages();
        
    } catch (error) {
        console.error('Erreur lors du chargement du PDF:', error);
        throw error;
    }
}

// Rendre toutes les pages du PDF en mode scroll
async function renderAllPages() {
    console.log('üîç DEBUG: renderAllPages - D√©but');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (!pagesContainer) {
        console.error('‚ùå pdfPagesContainer non trouv√©!');
        return;
    }
    
    pagesContainer.innerHTML = ''; // Nettoyer le conteneur
    console.log(`üìÑ Nombre de pages √† rendre: ${pdfDoc.numPages}`);
    
    // R√©initialiser currentPageNum √† 1
    currentPageNum = 1;
    
    // Cr√©er les √©l√©ments pour chaque page
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'pdf-page-wrapper';
        pageWrapper.id = `page-wrapper-${pageNum}`;
        
        // Ajouter le num√©ro de page
        const pageNumber = document.createElement('div');
        pageNumber.className = 'pdf-page-number';
        pageNumber.textContent = `Page ${pageNum}`;
        pageWrapper.appendChild(pageNumber);
        
        // Cr√©er les canvas pour le PDF et les annotations
        const pdfCanvas = document.createElement('canvas');
        pdfCanvas.className = 'pdf-canvas';
        pdfCanvas.id = `pdf-canvas-${pageNum}`;
        
        const annotationCanvas = document.createElement('canvas');
        annotationCanvas.className = 'annotation-canvas';
        annotationCanvas.id = `annotation-canvas-${pageNum}`;
        
        pageWrapper.appendChild(pdfCanvas);
        pageWrapper.appendChild(annotationCanvas);
        pagesContainer.appendChild(pageWrapper);
        
        // Rendre la page
        await renderSinglePage(pageNum, pdfCanvas, annotationCanvas);
    }
    
    // Configurer les √©v√©nements d'annotation pour toutes les pages
    setupMultiPageAnnotations();
    
    // Observer le scroll pour mettre √† jour la page courante
    setupScrollObserver();
    
    // Appliquer automatiquement la correction du probl√®me de scroll apr√®s un petit d√©lai
    setTimeout(() => {
        console.log('üîß Application automatique de la correction de scroll...');
        applyScrollFix();
    }, 200);
    
    
    console.log('‚úÖ renderAllPages - Termin√©');
}

// === FONCTIONS DE TEST ET DEBUG ===
window.pdfDebug = {
    // Tester la navigation
    testNavigation: function() {
        console.log('üß™ Test de navigation');
        console.log(`Pages disponibles: 1-${pdfDoc ? pdfDoc.numPages : 'PDF non charg√©'}`);
        console.log(`Page actuelle: ${currentPageNum}`);
        
        // Tester le scroll vers la page 1
        const firstPage = document.getElementById('page-wrapper-1');
        if (firstPage) {
            console.log('‚úÖ page-wrapper-1 trouv√©');
            firstPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } else {
            console.error('‚ùå page-wrapper-1 non trouv√©');
        }
    },
    
    // V√©rifier les canvas
    checkCanvases: function() {
        console.log('üß™ V√©rification des canvas');
        const pagesContainer = document.getElementById('pdfPagesContainer');
        if (!pagesContainer) {
            console.error('‚ùå pdfPagesContainer non trouv√©');
            return;
        }
        
        console.log(`üìÑ Conteneur: ${pagesContainer.children.length} enfants`);
        console.log('Enfants du conteneur:', Array.from(pagesContainer.children).map(c => c.id));
        
        for (let i = 1; i <= (pdfDoc ? pdfDoc.numPages : 10); i++) {
            const pageWrapper = document.getElementById(`page-wrapper-${i}`);
            const pdfCanvas = document.getElementById(`pdf-canvas-${i}`);
            const annotCanvas = document.getElementById(`annotation-canvas-${i}`);
            
            console.log(`Page ${i}: Wrapper ${pageWrapper ? '‚úÖ' : '‚ùå'}, PDF canvas ${pdfCanvas ? '‚úÖ' : '‚ùå'}, Annotation canvas ${annotCanvas ? '‚úÖ' : '‚ùå'}`);
            
            if (annotCanvas) {
                const rect = annotCanvas.getBoundingClientRect();
                console.log(`  - Taille: ${rect.width}x${rect.height}, Position: ${rect.top}`);
            }
        }
    },
    
    // Tester le dessin
    testDrawing: function() {
        console.log('üß™ Test du syst√®me de dessin');
        console.log(`Outil actuel: ${currentTool}`);
        console.log(`Couleur: ${currentColor}`);
        console.log(`√âpaisseur: ${currentStrokeWidth}`);
        console.log(`Mode dessin: ${isDrawing ? 'ACTIF' : 'INACTIF'}`);
    },
    
    // Forcer le scroll vers la premi√®re page
    goToFirst: function() {
        console.log('üîß Force scroll vers page 1');
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (viewerContainer && firstPage) {
            viewerContainer.scrollTop = 0;
            firstPage.scrollIntoView({ behavior: 'auto', block: 'start' });
            currentPageNum = 1;
            updatePageInfo();
                    updateActiveThumbnail();
            console.log('‚úÖ Navigation forc√©e vers page 1');
        }
    },
    
    // Aller √† une page sp√©cifique
    goToPage: function(pageNum) {
        console.log(`üîß DEBUG Navigation vers page ${pageNum}`);
        const viewerContainer = document.getElementById('viewerContainer');
        const targetPage = document.getElementById(`page-wrapper-${pageNum}`);
        
        if (viewerContainer && targetPage && pageNum >= 1 && pageNum <= (pdfDoc ? pdfDoc.numPages : 0)) {
            // Utiliser la fonction principale goToPage
            goToPage(pageNum);
        } else {
            console.error(`‚ùå Page ${pageNum} non trouv√©e ou invalide`);
            console.log('V√©rifications:');
            console.log('- viewerContainer:', !!viewerContainer);
            console.log('- targetPage:', !!targetPage);
            console.log('- pageNum range:', pageNum >= 1 && pageNum <= (pdfDoc ? pdfDoc.numPages : 0));
            console.log('- Total pages:', pdfDoc ? pdfDoc.numPages : 'PDF non charg√©');
        }
    },
    
    // Test de navigation compl√®te
    testFullNavigation: function() {
        console.log('üß™ Test de navigation compl√®te');
        const totalPages = pdfDoc ? pdfDoc.numPages : 0;
        console.log(`Pages disponibles: 1-${totalPages}`);
        
        if (totalPages === 0) {
            console.error('‚ùå Aucun PDF charg√©');
            return;
        }
        
        // Test aller √† la page 1
        this.goToPage(1);
        
        setTimeout(() => {
            // Test aller √† la derni√®re page
            console.log(`üß™ Test navigation vers page ${totalPages}`);
            this.goToPage(totalPages);
            
            setTimeout(() => {
                // Retour √† la page 1
                console.log('üß™ Retour √† la page 1');
                this.goToPage(1);
            }, 2000);
        }, 2000);
    },
    
    // Relancer le rendu si √ßa a √©chou√©
    retryRender: async function() {
        console.log('üîß Relance du rendu...');
        if (pdfDoc) {
            currentTool = 'pen'; // S'assurer que currentTool est d√©fini
            await renderAllPages();
        } else {
            console.error('‚ùå PDF non charg√©');
        }
    },
    
    // Test sp√©cifique pour le probl√®me de scroll
    testScrollIssue: function() {
        console.log('üß™ Test sp√©cifique du probl√®me de scroll');
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (!viewerContainer || !firstPage) {
            console.error('‚ùå Elements non trouv√©s');
            return;
        }
        
        console.log('üìä √âtat actuel:');
        console.log('  - Container scrollTop:', viewerContainer.scrollTop);
        console.log('  - Container scrollHeight:', viewerContainer.scrollHeight);
        console.log('  - Container clientHeight:', viewerContainer.clientHeight);
        console.log('  - Page courante d√©tect√©e:', currentPageNum);
        
        // Position de la page 1
        const rect = firstPage.getBoundingClientRect();
        const containerRect = viewerContainer.getBoundingClientRect();
        console.log('üìç Position de la page 1:');
        console.log('  - Page offsetTop:', firstPage.offsetTop);
        console.log('  - Page getBoundingClientRect top:', rect.top);
        console.log('  - Container getBoundingClientRect top:', containerRect.top);
        console.log('  - Diff√©rence:', rect.top - containerRect.top);
        
        // Test du scroll forc√©
        console.log('üîß Test du scroll forc√© √† 0...');
        viewerContainer.scrollTop = 0;
        
        setTimeout(() => {
            console.log('üìä Apr√®s scroll forc√©:');
            console.log('  - Container scrollTop:', viewerContainer.scrollTop);
            
            const newRect = firstPage.getBoundingClientRect();
            const newContainerRect = viewerContainer.getBoundingClientRect();
            console.log('  - Nouvelle position page 1:', newRect.top - newContainerRect.top);
            
            // Test si la page 1 est maintenant visible
            const isVisible = newRect.top >= newContainerRect.top - 50 && newRect.top <= newContainerRect.bottom;
            console.log('  - Page 1 visible:', isVisible);
            
            if (!isVisible) {
                console.log('üö® La page 1 n\'est toujours pas visible apr√®s scroll = 0');
                console.log('üîß Tentative avec scrollTo...');
                viewerContainer.scrollTo(0, 0);
                
                setTimeout(() => {
                    const finalRect = firstPage.getBoundingClientRect();
                    const finalContainerRect = viewerContainer.getBoundingClientRect();
                    console.log('üìä Apr√®s scrollTo:');
                    console.log('  - Container scrollTop:', viewerContainer.scrollTop);
                    console.log('  - Position page 1:', finalRect.top - finalContainerRect.top);
                }, 100);
            }
        }, 100);
    },
    
    // Forcer la navigation vers page 1 avec debug d√©taill√©
    forceGoToPage1: function() {
        console.log('üö® FORCE navigation vers page 1');
        
        // Arr√™ter l'observer temporairement
        if (window.currentPageObserver) {
            window.currentPageObserver.disconnect();
            console.log('üîß Observer arr√™t√©');
        }
        
        // Force la page √† 1
        currentPageNum = 1;
        updatePageInfo();
        updateActiveThumbnail();
        
        // Force le scroll
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (viewerContainer && firstPage) {
            viewerContainer.scrollTop = 0;
            console.log('üîß Scroll forc√© √† 0');
            
            // Red√©marrer l'observer apr√®s un d√©lai
            setTimeout(() => {
                setupScrollObserver();
                console.log('üîß Observer red√©marr√©');
            }, 500);
        }
    },
    
    // Diagnostic CSS complet
    diagnoseCSSIssue: function() {
        console.log('üî¨ DIAGNOSTIC CSS COMPLET');
        
        const viewerContainer = document.getElementById('viewerContainer');
        const pagesContainer = document.getElementById('pdfPagesContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        const page7 = document.getElementById('page-wrapper-7');
        
        if (!viewerContainer || !pagesContainer || !firstPage) {
            console.error('‚ùå √âl√©ments manquants');
            return;
        }
        
        console.log('üìä PROPRI√âT√âS DU CONTAINER:');
        const containerStyle = window.getComputedStyle(viewerContainer);
        console.log('  - height:', containerStyle.height);
        console.log('  - max-height:', containerStyle.maxHeight);
        console.log('  - overflow-y:', containerStyle.overflowY);
        console.log('  - position:', containerStyle.position);
        console.log('  - scrollTop actuel:', viewerContainer.scrollTop);
        console.log('  - scrollHeight total:', viewerContainer.scrollHeight);
        console.log('  - clientHeight:', viewerContainer.clientHeight);
        
        console.log('üìä PROPRI√âT√âS DU PAGES CONTAINER:');
        const pagesStyle = window.getComputedStyle(pagesContainer);
        console.log('  - height:', pagesStyle.height);
        console.log('  - min-height:', pagesStyle.minHeight);
        console.log('  - padding-top:', pagesStyle.paddingTop);
        console.log('  - margin-top:', pagesStyle.marginTop);
        console.log('  - transform:', pagesStyle.transform);
        console.log('  - offsetTop:', pagesContainer.offsetTop);
        
        console.log('üìä POSITIONS DES PAGES:');
        for (let i = 1; i <= Math.min(8, pdfDoc ? pdfDoc.numPages : 0); i++) {
            const page = document.getElementById(`page-wrapper-${i}`);
            if (page) {
                const rect = page.getBoundingClientRect();
                const containerRect = viewerContainer.getBoundingClientRect();
                console.log(`  - Page ${i}: offsetTop=${page.offsetTop}, getBoundingClientRect.top=${Math.round(rect.top - containerRect.top)}`);
            }
        }
        
        console.log('üîß TEST DE SCROLL R√âEL:');
        console.log('  - scrollTop avant test:', viewerContainer.scrollTop);
        viewerContainer.scrollTop = 0;
        console.log('  - scrollTop apr√®s scrollTop=0:', viewerContainer.scrollTop);
        
        // V√©rifier si le scroll est bloqu√© par du CSS
        setTimeout(() => {
            console.log('  - scrollTop apr√®s 100ms:', viewerContainer.scrollTop);
            
            if (viewerContainer.scrollTop !== 0) {
                console.log('üö® PROBL√àME D√âTECT√â: scrollTop ne reste pas √† 0 !');
                console.log('üîß Tentative de correction CSS...');
                
                // Forcer les styles
                viewerContainer.style.scrollBehavior = 'auto';
                viewerContainer.style.overflow = 'auto';
                viewerContainer.scrollTop = 0;
                
                // Reset du container des pages
                pagesContainer.style.paddingTop = '0px';
                pagesContainer.style.marginTop = '0px';
                pagesContainer.style.transform = 'none';
                
                setTimeout(() => {
                    console.log('  - scrollTop apr√®s correction CSS:', viewerContainer.scrollTop);
                    
                    if (viewerContainer.scrollTop !== 0) {
                        console.log('üö® √âCHEC: Le scroll est forc√© par autre chose !');
                        console.log('üîç Investigation des √©l√©ments parents...');
                        
                        let element = viewerContainer.parentElement;
                        while (element && element !== document.body) {
                            const style = window.getComputedStyle(element);
                            if (style.overflow !== 'visible' || style.position === 'fixed' || style.position === 'absolute') {
                                console.log(`üîç Parent suspect: ${element.className || element.tagName} - overflow:${style.overflow}, position:${style.position}`);
                            }
                            element = element.parentElement;
                        }
                    }
                }, 100);
            } else {
                console.log('‚úÖ Scroll fonctionne - probl√®me probablement dans la logique JavaScript');
            }
        }, 100);
    },
    
    // Correction automatique du probl√®me d√©tect√©
    fixScrollIssue: function() {
        console.log('üõ†Ô∏è CORRECTION AUTOMATIQUE DU PROBL√àME DE SCROLL');
        
        const viewerContainer = document.getElementById('viewerContainer');
        const pagesContainer = document.getElementById('pdfPagesContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (!viewerContainer || !pagesContainer || !firstPage) {
            console.error('‚ùå √âl√©ments manquants');
            return;
        }
        
        console.log('üîß √âtape 1: Reset complet du CSS');
        
        // Reset du viewer container
        viewerContainer.style.scrollBehavior = 'auto';
        viewerContainer.style.height = '100%';
        viewerContainer.style.minHeight = '500px'; // Forcer une hauteur minimum
        viewerContainer.style.maxHeight = 'none';
        viewerContainer.style.overflow = 'auto';
        viewerContainer.style.position = 'relative';
        
        // Reset du pages container
        pagesContainer.style.paddingTop = '16px'; // Padding minimum
        pagesContainer.style.marginTop = '0px';
        pagesContainer.style.transform = 'none';
        pagesContainer.style.position = 'relative';
        pagesContainer.style.top = '0px';
        pagesContainer.style.left = '0px';
        
        console.log('üîß √âtape 2: Repositionnement forc√©');
        
        // Forcer la restructuration du layout
        viewerContainer.style.display = 'none';
        viewerContainer.offsetHeight; // Force reflow
        viewerContainer.style.display = 'block';
        
        setTimeout(() => {
            console.log('üîß √âtape 3: Test du scroll apr√®s correction');
            viewerContainer.scrollTop = 0;
            
            setTimeout(() => {
                const rect = firstPage.getBoundingClientRect();
                const containerRect = viewerContainer.getBoundingClientRect();
                const newPosition = rect.top - containerRect.top;
                
                console.log('üìä Apr√®s correction:');
                console.log('  - Container height:', viewerContainer.clientHeight);
                console.log('  - Container scrollTop:', viewerContainer.scrollTop);
                console.log('  - Page 1 position:', newPosition);
                
                if (newPosition < -100 || newPosition > viewerContainer.clientHeight) {
                    console.log('üö® Position toujours incorrecte, tentative manuelle...');
                    
                    // Calcul de la position correcte
                    const targetScrollTop = firstPage.offsetTop - 16; // 16px de padding
                    console.log(`üîß Scroll calcul√© vers: ${targetScrollTop}px`);
                    
                    viewerContainer.scrollTop = Math.max(0, targetScrollTop);
                    
                    setTimeout(() => {
                        const finalRect = firstPage.getBoundingClientRect();
                        const finalContainerRect = viewerContainer.getBoundingClientRect();
                        const finalPosition = finalRect.top - finalContainerRect.top;
                        
                        console.log('üìä Position finale:');
                        console.log('  - scrollTop final:', viewerContainer.scrollTop);
                        console.log('  - Position page 1 finale:', finalPosition);
                        
                        if (finalPosition >= 0 && finalPosition <= 100) {
                            console.log('‚úÖ CORRECTION R√âUSSIE !');
                            
                            // Reset de l'observer pour qu'il d√©tecte la page 1
                            if (window.currentPageObserver) {
                                window.currentPageObserver.disconnect();
                            }
                            
                            currentPageNum = 1;
                            updatePageInfo();
                            updateActiveThumbnail();
                            
                            setTimeout(() => {
                                setupScrollObserver();
                                console.log('üîß Observer red√©marr√© avec page 1 active');
                            }, 200);
                            
                        } else {
                            console.log('‚ùå CORRECTION √âCHEC - Position encore incorrecte');
                        }
                    }, 100);
                } else {
                    console.log('‚úÖ CORRECTION R√âUSSIE - Page 1 maintenant visible !');
                    currentPageNum = 1;
                    updatePageInfo();
                    updateActiveThumbnail();
                }
            }, 100);
        }, 100);
    }
};

console.log('üîß Fonctions de debug disponibles: window.pdfDebug');
console.log('   - testNavigation() : Tester la navigation');
console.log('   - checkCanvases() : V√©rifier les canvas');  
console.log('   - testDrawing() : Tester le dessin');
console.log('   - goToFirst() : Aller √† la page 1');
console.log('   - goToPage(n) : Aller √† la page n');
console.log('   - testFullNavigation() : Test navigation compl√®te');
console.log('   - testScrollIssue() : Test diagnostic du scroll');
console.log('   - diagnoseCSSIssue() : Diagnostic CSS complet');
console.log('   - fixScrollIssue() : NOUVEAU - Correction automatique du probl√®me');
console.log('   - forceGoToPage1() : Force page 1 avec reset observer');
console.log('   - retryRender() : Relancer le rendu si √©chec');

// Fonctions de d√©bogage pour les outils d'annotation
window.annotationDebug = {
    // Tester l'√©tat des variables d'annotation
    checkVariables: function() {
        console.log('üé® === √âTAT DES VARIABLES D\'ANNOTATION ===');
        console.log('  - currentTool:', currentTool);
        console.log('  - currentAnnotationTool:', currentAnnotationTool);
        console.log('  - currentStrokeWidth:', currentStrokeWidth);
        console.log('  - currentAnnotationColor:', currentAnnotationColor);
        console.log('  - Les deux tools sont synchronis√©s:', currentTool === currentAnnotationTool);
    },
    
    // Tester tous les √©l√©ments DOM des outils
    checkDOMElements: function() {
        console.log('üîç === V√âRIFICATION DES √âL√âMENTS DOM ===');
        
        // Boutons d'outils
        const penTool = document.getElementById('penTool');
        const highlighterTool = document.getElementById('highlighterTool');
        const eraserTool = document.getElementById('eraserTool');
        
        console.log('  Boutons d\'outils:');
        console.log('    - penTool:', penTool ? 'trouv√©' : 'MANQUANT', penTool);
        console.log('    - highlighterTool:', highlighterTool ? 'trouv√©' : 'MANQUANT', highlighterTool);
        console.log('    - eraserTool:', eraserTool ? 'trouv√©' : 'MANQUANT', eraserTool);
        
        if (penTool) console.log('    - penTool classList:', penTool.classList.toString());
        if (highlighterTool) console.log('    - highlighterTool classList:', highlighterTool.classList.toString());
        if (eraserTool) console.log('    - eraserTool classList:', eraserTool.classList.toString());
        
        // S√©lecteur de couleur
        const colorPicker = document.getElementById('annotationColor');
        console.log('  - colorPicker:', colorPicker ? 'trouv√©' : 'MANQUANT', colorPicker);
        if (colorPicker) {
            console.log('    - value:', colorPicker.value);
            console.log('    - disabled:', colorPicker.disabled);
        }
        
        // Curseur d'√©paisseur
        const strokeWidthSlider = document.getElementById('strokeWidth');
        const strokeWidthValue = document.getElementById('strokeWidthValue');
        console.log('  - strokeWidthSlider:', strokeWidthSlider ? 'trouv√©' : 'MANQUANT', strokeWidthSlider);
        console.log('  - strokeWidthValue:', strokeWidthValue ? 'trouv√©' : 'MANQUANT', strokeWidthValue);
        
        if (strokeWidthSlider) {
            console.log('    - value:', strokeWidthSlider.value);
            console.log('    - min:', strokeWidthSlider.min);
            console.log('    - max:', strokeWidthSlider.max);
            console.log('    - disabled:', strokeWidthSlider.disabled);
            console.log('    - step:', strokeWidthSlider.step);
        }
        
        if (strokeWidthValue) {
            console.log('    - textContent:', strokeWidthValue.textContent);
        }
    },
    
    // Tester les √©v√©nements
    testEvents: function() {
        console.log('üéØ === TEST DES √âV√âNEMENTS ===');
        
        console.log('  Test de changement d\'outil vers pen...');
        setAnnotationTool('pen');
        this.checkVariables();
        
        setTimeout(() => {
            console.log('  Test de changement d\'outil vers highlighter...');
            setAnnotationTool('highlighter');
            this.checkVariables();
            
            setTimeout(() => {
                console.log('  Test de changement d\'outil vers eraser...');
                setAnnotationTool('eraser');
                this.checkVariables();
                
                setTimeout(() => {
                    console.log('  Test de changement de couleur...');
                    setAnnotationColor('#00ff00');
                    this.checkVariables();
                    
                    setTimeout(() => {
                        console.log('  Test de changement d\'√©paisseur...');
                        setStrokeWidth(8);
                        this.checkVariables();
                    }, 500);
                }, 500);
            }, 500);
        }, 500);
    },
    
    // Tester les √©v√©nements des sliders manuellement
    testSliderEvents: function() {
        console.log('üéöÔ∏è === TEST MANUEL DU SLIDER ===');
        
        const strokeWidthSlider = document.getElementById('strokeWidth');
        if (!strokeWidthSlider) {
            console.error('‚ùå Slider non trouv√©');
            return;
        }
        
        console.log('  Valeur initiale du slider:', strokeWidthSlider.value);
        console.log('  Variable currentStrokeWidth:', currentStrokeWidth);
        
        // Simuler un changement de valeur
        console.log('  Simulation changement vers 7...');
        strokeWidthSlider.value = 7;
        
        // D√©clencher l'√©v√©nement manuellement
        const inputEvent = new Event('input', { bubbles: true });
        strokeWidthSlider.dispatchEvent(inputEvent);
        
        setTimeout(() => {
            console.log('  Apr√®s √©v√©nement input:');
            console.log('    - slider.value:', strokeWidthSlider.value);
            console.log('    - currentStrokeWidth:', currentStrokeWidth);
            console.log('    - strokeWidthValue.textContent:', document.getElementById('strokeWidthValue')?.textContent);
        }, 100);
    },
    
    // V√©rifier l'√©tat des boutons d'outils
    checkToolButtons: function() {
        console.log('üîò === √âTAT DES BOUTONS D\'OUTILS ===');
        
        ['penTool', 'highlighterTool', 'eraserTool'].forEach(toolId => {
            const btn = document.getElementById(toolId);
            if (btn) {
                console.log(`  ${toolId}:`);
                console.log(`    - active: ${btn.classList.contains('active')}`);
                console.log(`    - disabled: ${btn.disabled}`);
                console.log(`    - onclick: ${btn.onclick ? 'd√©fini' : 'NON D√âFINI'}`);
                console.log(`    - classList: ${btn.classList.toString()}`);
            } else {
                console.log(`  ${toolId}: INTROUVABLE`);
            }
        });
    },
    
    // Test complet
    fullTest: function() {
        console.log('üß™ === TEST COMPLET DES OUTILS D\'ANNOTATION ===');
        this.checkVariables();
        this.checkDOMElements();
        this.checkToolButtons();
        
        setTimeout(() => {
            this.testSliderEvents();
        }, 1000);
        
        setTimeout(() => {
            this.testEvents();
        }, 2000);
    },
    
    // Surveiller en temps r√©el qui efface les annotations
    watchAnnotations: function() {
        console.log('üîç === SURVEILLANCE DES ANNOTATIONS ACTIV√âE ===');
        
        // Intercepter les appels √† clearRect (qui efface le canvas)
        if (annotationCtx) {
            const originalClearRect = annotationCtx.clearRect;
            annotationCtx.clearRect = function(...args) {
                console.log('üßπ CANVAS EFFAC√â ! Par qui ?');
                console.trace('üìç Trace de l\'effacement:');
                return originalClearRect.apply(this, args);
            };
            console.log('‚úÖ Surveillance clearRect activ√©e');
        }
        
        // Surveiller les changements de la variable annotations
        let annotationsLength = annotations.length;
        const checkAnnotations = () => {
            if (annotations.length !== annotationsLength) {
                console.log(`üìä CHANGEMENT D√âTECT√â: annotations.length ${annotationsLength} ‚Üí ${annotations.length}`);
                console.trace('üìç Trace du changement:');
                annotationsLength = annotations.length;
            }
            
            // Surveiller aussi annotationsByPage
            if (annotationsByPage[currentPageNum]) {
                const pageAnnotationsLength = annotationsByPage[currentPageNum].length;
                setTimeout(() => {
                    if (annotationsByPage[currentPageNum] && annotationsByPage[currentPageNum].length !== pageAnnotationsLength) {
                        console.log(`üìä CHANGEMENT annotationsByPage[${currentPageNum}]: ${pageAnnotationsLength} ‚Üí ${annotationsByPage[currentPageNum].length}`);
                        console.trace('üìç Trace du changement annotationsByPage:');
                    }
                }, 10);
            }
        };
        
        // V√©rifier toutes les 100ms
        const interval = setInterval(checkAnnotations, 100);
        
        console.log('‚úÖ Surveillance des variables activ√©e (toutes les 100ms)');
        console.log('Pour arr√™ter: clearInterval(' + interval + ')');
        
        return interval;
    },
    
    // Forcer la r√©initialisation des outils
    resetTools: function() {
        console.log('üîÑ === R√âINITIALISATION FORC√âE DES OUTILS ===');
        
        // R√©initialiser les variables
        currentTool = 'pen';
        currentAnnotationTool = 'pen';
        currentStrokeWidth = 3;
        currentColor = '#ff0000';
        currentAnnotationColor = '#ff0000';
        
        // R√©initialiser l'interface
        setAnnotationTool('pen');
        setStrokeWidth(3);
        setAnnotationColor('#ff0000');
        
        console.log('‚úÖ Outils r√©initialis√©s');
        this.checkVariables();
    },
    
    // Reconfigurer manuellement les √©v√©nements
    rebindEvents: function() {
        console.log('üîÑ === RECONFIGURATION DES √âV√âNEMENTS ===');
        
        // Supprimer les anciens √©v√©nements en clonant les √©l√©ments
        const toolButtons = document.querySelectorAll('[data-tool]');
        console.log('üîò Reconfiguration de', toolButtons.length, 'boutons d\'outils');
        
        toolButtons.forEach((btn, index) => {
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', () => {
                console.log('üñ±Ô∏è [REBOUND] Clic sur bouton outil:', newBtn.dataset.tool);
                setAnnotationTool(newBtn.dataset.tool);
            });
            
            console.log(`  ‚úÖ Bouton ${index} reconfigur√©: ${newBtn.id} (${newBtn.dataset.tool})`);
        });
        
        // Reconfigurer les couleurs
        const colorButtons = document.querySelectorAll('.color-btn');
        console.log('üé® Reconfiguration de', colorButtons.length, 'boutons de couleur');
        
        colorButtons.forEach(btn => {
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', () => {
                console.log('üñ±Ô∏è [REBOUND] Clic sur couleur:', newBtn.dataset.color);
                setAnnotationColor(newBtn.dataset.color);
            });
        });
        
        // Reconfigurer le slider d'√©paisseur
        const strokeWidthSlider = document.getElementById('strokeWidth');
        if (strokeWidthSlider) {
            console.log('üìè Reconfiguration du slider d\'√©paisseur');
            
            // Cloner le slider pour supprimer les anciens √©v√©nements
            const newSlider = strokeWidthSlider.cloneNode(true);
            strokeWidthSlider.parentNode.replaceChild(newSlider, strokeWidthSlider);
            
            // R√©attacher les √©v√©nements
            newSlider.addEventListener('input', (e) => {
                console.log('üñ±Ô∏è [REBOUND] Slider input:', e.target.value);
                setStrokeWidth(e.target.value);
            });
            
            newSlider.addEventListener('change', (e) => {
                console.log('üñ±Ô∏è [REBOUND] Slider change:', e.target.value);
                setStrokeWidth(e.target.value);
            });
            
            console.log('‚úÖ Slider d\'√©paisseur reconfigur√©');
        } else {
            console.warn('‚ö†Ô∏è Slider d\'√©paisseur non trouv√©');
        }
        
        // Reconfigurer le color picker
        const colorPicker = document.getElementById('annotationColor');
        if (colorPicker) {
            console.log('üé® Reconfiguration du color picker');
            
            const newColorPicker = colorPicker.cloneNode(true);
            colorPicker.parentNode.replaceChild(newColorPicker, colorPicker);
            
            newColorPicker.addEventListener('change', (e) => {
                console.log('üñ±Ô∏è [REBOUND] Color picker:', e.target.value);
                setAnnotationColor(e.target.value);
            });
            
            console.log('‚úÖ Color picker reconfigur√©');
        }
        
        console.log('‚úÖ Tous les √©v√©nements reconfigur√©s');
    },
    
    // Forcer l'affichage des annotations de la page actuelle
    forceShowAnnotations: function() {
        console.log('üé® === AFFICHAGE FORC√â DES ANNOTATIONS ===');
        console.log(`üìÑ Page actuelle: ${currentPageNum}`);
        console.log(`üìä Annotations disponibles: ${annotations.length}`);
        console.log(`üìä Canvas disponible: ${!!annotationCtx}`);
        console.log(`üìä isDrawing: ${isDrawing}`);
        
        if (annotationCtx) {
            const wasDrawing = isDrawing;
            isDrawing = false; // Forcer isDrawing √† false
            console.log('üîÑ For√ßage du redessinage...');
            redrawAnnotations(true);
            isDrawing = wasDrawing; // Restaurer l'√©tat
            console.log('‚úÖ Redessinage forc√© termin√©');
        } else {
            console.log('‚ùå Canvas non disponible');
        }
    }
};

console.log('üé® Fonctions de debug annotation disponibles: window.annotationDebug');
console.log('   - checkVariables() : V√©rifier l\'√©tat des variables');
console.log('   - checkDOMElements() : V√©rifier les √©l√©ments DOM');
console.log('   - testEvents() : Tester les changements d\'outils');
console.log('   - testSliderEvents() : Tester le slider manuellement');
console.log('   - checkToolButtons() : V√©rifier l\'√©tat des boutons');
console.log('   - fullTest() : Test complet de tous les outils');
console.log('   - resetTools() : R√©initialiser tous les outils');
console.log('   - rebindEvents() : Reconfigurer les √©v√©nements des boutons');
console.log('   - watchAnnotations() : Surveiller qui efface les annotations');
console.log('   - forceShowAnnotations() : NOUVEAU - Forcer l\'affichage des annotations');

// Fonction de correction automatique du scroll (appliqu√©e √† chaque chargement de PDF)
function applyScrollFix() {
    console.log('üõ†Ô∏è Application automatique de la correction de scroll...');
    
    const viewerContainer = document.getElementById('viewerContainer');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    const firstPage = document.getElementById('page-wrapper-1');
    
    if (!viewerContainer || !pagesContainer || !firstPage) {
        console.warn('‚ö†Ô∏è √âl√©ments non trouv√©s pour la correction - retry dans 100ms');
        setTimeout(applyScrollFix, 100);
        return;
    }
    
    // V√©rifier si la correction est n√©cessaire
    const rect = firstPage.getBoundingClientRect();
    const containerRect = viewerContainer.getBoundingClientRect();
    const pagePosition = rect.top - containerRect.top;
    
    console.log(`üìä Position actuelle de la page 1: ${Math.round(pagePosition)}px`);
    
    // Si la page 1 est tr√®s mal positionn√©e, appliquer la correction
    if (pagePosition < -100 || pagePosition > viewerContainer.clientHeight) {
        console.log('üö® Correction n√©cessaire - page 1 mal positionn√©e');
        
        // Appliquer les corrections CSS
        viewerContainer.style.scrollBehavior = 'auto';
        viewerContainer.style.height = '100%';
        viewerContainer.style.minHeight = '500px';
        viewerContainer.style.maxHeight = 'none';
        viewerContainer.style.overflow = 'auto';
        viewerContainer.style.position = 'relative';
        
        // Reset du pages container
        pagesContainer.style.paddingTop = '16px';
        pagesContainer.style.marginTop = '0px';
        pagesContainer.style.transform = 'none';
        pagesContainer.style.position = 'relative';
        pagesContainer.style.top = '0px';
        pagesContainer.style.left = '0px';
        
        // Forcer le reflow
        viewerContainer.style.display = 'none';
        viewerContainer.offsetHeight; // Force reflow
        viewerContainer.style.display = 'block';
        
        setTimeout(() => {
            // V√©rifier et ajuster le scroll
            const newRect = firstPage.getBoundingClientRect();
            const newContainerRect = viewerContainer.getBoundingClientRect();
            const newPosition = newRect.top - newContainerRect.top;
            
            console.log(`üìä Position apr√®s correction CSS: ${Math.round(newPosition)}px`);
            
            if (newPosition < -50 || newPosition > 100) {
                // Correction manuelle du scroll
                const targetScrollTop = firstPage.offsetTop - 16;
                viewerContainer.scrollTop = Math.max(0, targetScrollTop);
                console.log(`üîß Scroll manuel appliqu√©: ${viewerContainer.scrollTop}px`);
            }
            
            // Forcer la page courante √† 1
            currentPageNum = 1;
            updatePageInfo();
            updateActiveThumbnail();
            
            // Red√©marrer l'observer apr√®s correction
            if (window.currentPageObserver) {
                window.currentPageObserver.disconnect();
                setTimeout(() => {
                    setupScrollObserver();
                    console.log('‚úÖ Correction automatique termin√©e - Page 1 active');
                }, 100);
            }
        }, 50);
    } else {
        console.log('‚úÖ Position correcte - aucune correction n√©cessaire');
        // Juste s'assurer qu'on est √† la page 1
        viewerContainer.scrollTop = 0;
        currentPageNum = 1;
        updatePageInfo();
        updateActiveThumbnail();
    }
}

// Rendre une page individuelle dans le mode multi-pages
async function renderSinglePage(pageNum, pdfCanvas, annotationCanvas) {
    try {
        const page = await pdfDoc.getPage(pageNum);
        const defaultScale = 1.5;
        const viewport = page.getViewport({ scale: defaultScale * currentScale });
        
        // Ajuster les dimensions du canvas
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        annotationCanvas.width = viewport.width;
        annotationCanvas.height = viewport.height;
        
        // Ajuster les styles
        pdfCanvas.style.width = viewport.width + 'px';
        pdfCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.width = viewport.width + 'px';
        annotationCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.position = 'absolute';
        annotationCanvas.style.top = '0';
        annotationCanvas.style.left = '0';
        
        const ctx = pdfCanvas.getContext('2d');
        
        // Rendre la page PDF
        const renderContext = {
            canvasContext: ctx,
            viewport: viewport,
            renderTextLayer: false,
            renderAnnotationLayer: false
        };
        
        await page.render(renderContext).promise;
        
        // Dessiner les annotations existantes pour cette page
        const annotCtx = annotationCanvas.getContext('2d');
        if (annotationsByPage[pageNum]) {
            redrawAnnotations(annotCtx, annotationsByPage[pageNum]);
        }
        
    } catch (error) {
        console.error(`Erreur lors du rendu de la page ${pageNum}:`, error);
    }
}

// Configurer les √©v√©nements d'annotation pour le mode multi-pages
function setupMultiPageAnnotations() {
    console.log('üîç DEBUG: setupMultiPageAnnotations - D√©but');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (!pagesContainer) {
        console.error('‚ùå pdfPagesContainer non trouv√© dans setupMultiPageAnnotations');
        return;
    }
    
    let canvasCount = 0;
    
    // Ajouter les √©v√©nements √† chaque canvas d'annotation
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const annotationCanvas = document.getElementById(`annotation-canvas-${pageNum}`);
        if (annotationCanvas) {
            canvasCount++;
            // Ajouter les attributs de page
            annotationCanvas.dataset.pageNum = pageNum;
            
            // S'assurer que le canvas est bien positionn√©
            annotationCanvas.style.pointerEvents = 'auto';
            annotationCanvas.style.cursor = currentTool === 'eraser' ? 'crosshair' : 'default';
            
            // √âv√©nements souris
            annotationCanvas.addEventListener('mousedown', (e) => startDrawingMultiPage(e, pageNum));
            annotationCanvas.addEventListener('mousemove', (e) => drawMultiPage(e, pageNum));
            annotationCanvas.addEventListener('mouseup', (e) => stopDrawingMultiPage(e, pageNum));
            annotationCanvas.addEventListener('mouseleave', (e) => stopDrawingMultiPage(e, pageNum));
            
            // √âv√©nements tactiles
            annotationCanvas.addEventListener('touchstart', (e) => handleTouchMultiPage(e, pageNum), { passive: false });
            annotationCanvas.addEventListener('touchmove', (e) => handleTouchMultiPage(e, pageNum), { passive: false });
            annotationCanvas.addEventListener('touchend', (e) => handleTouchMultiPage(e, pageNum), { passive: false });
        } else {
            console.warn(`‚ö†Ô∏è Canvas d'annotation non trouv√© pour la page ${pageNum}`);
        }
    }
    
    console.log(`‚úÖ setupMultiPageAnnotations - ${canvasCount} canvas configur√©s sur ${pdfDoc.numPages} pages`);
}

// G√©rer le d√©but du dessin en mode multi-pages
function startDrawingMultiPage(e, pageNum) {
    console.log(`üñäÔ∏è DEBUG: startDrawingMultiPage - Page ${pageNum}, Tool: ${currentTool}`);
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    isDrawing = true;
    currentPageNum = pageNum;
    annotationCanvas = e.target;
    annotationCtx = annotationCanvas.getContext('2d');
    
    // Configurer le contexte d'annotation
    annotationCtx.lineCap = 'round';
    annotationCtx.lineJoin = 'round';
    annotationCtx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
    annotationCtx.lineWidth = currentStrokeWidth;
    annotationCtx.strokeStyle = currentColor;
    
    if (currentTool === 'eraser') {
        console.log('üîç Mode gomme activ√©');
        eraseAt(x, y);
    } else {
        console.log('‚úèÔ∏è Mode dessin activ√© - D√©but du trait');
        // Commencer un nouveau trait
        currentAnnotation = {
            type: currentTool,
            color: currentColor,
            strokeWidth: currentStrokeWidth,
            points: [{ x, y }],
            page: pageNum
        };
        
        annotationCtx.beginPath();
        annotationCtx.moveTo(x, y);
    }
}

// G√©rer le dessin en mode multi-pages
function drawMultiPage(e, pageNum) {
    if (!isDrawing || pageNum !== currentPageNum) return;
    
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (currentTool === 'eraser') {
        eraseAt(x, y);
    } else {
        // Continuer le trait
        if (currentAnnotation) {
            currentAnnotation.points.push({ x, y });
            annotationCtx.lineTo(x, y);
            annotationCtx.stroke();
        }
    }
}

// Arr√™ter le dessin en mode multi-pages
function stopDrawingMultiPage(e, pageNum) {
    if (!isDrawing) return;
    
    isDrawing = false;
    
    // Sauvegarder l'annotation pour cette page
    if (currentAnnotation && currentAnnotation.points.length > 0) {
        currentAnnotation.page = pageNum;
        
        if (!annotationsByPage[pageNum]) {
            annotationsByPage[pageNum] = [];
        }
        annotationsByPage[pageNum].push(currentAnnotation);
        
        // Ajouter √† la liste globale
        annotations.push(currentAnnotation);
    }
    
    currentAnnotation = null;
    
    // Programmer la sauvegarde automatique
    if (typeof scheduleAutoSave === 'function') {
        scheduleAutoSave();
    } else {
        // Sauvegarde imm√©diate si la fonction n'existe pas
        setTimeout(() => {
            saveAnnotations();
        }, 1000);
    }
}

// G√©rer les √©v√©nements tactiles en mode multi-pages
function handleTouchMultiPage(e, pageNum) {
    e.preventDefault();
    
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(
            e.type === 'touchstart' ? 'mousedown' : 
            e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
            {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            }
        );
        
        if (e.type === 'touchstart') {
            startDrawingMultiPage(mouseEvent, pageNum);
        } else if (e.type === 'touchmove') {
            drawMultiPage(mouseEvent, pageNum);
        } else if (e.type === 'touchend') {
            stopDrawingMultiPage(mouseEvent, pageNum);
        }
    }
}

// Observer le scroll pour d√©tecter la page visible
function setupScrollObserver() {
    const viewerContainer = document.getElementById('viewerContainer');
    if (!viewerContainer) return;
    
    // Configuration plus permissive pour d√©tecter toutes les pages, y compris celles du haut
    const observerOptions = {
        root: viewerContainer,
        rootMargin: '0px 0px 0px 0px', // Pas de marge pour garantir la d√©tection des pages du haut
        threshold: [0.1, 0.3, 0.5, 0.7, 0.9] // Plus de seuils pour une d√©tection plus pr√©cise
    };
    
    const pageObserver = new IntersectionObserver((entries) => {
        let maxIntersectionRatio = 0;
        let mostVisiblePage = currentPageNum;
        
        entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > maxIntersectionRatio) {
                maxIntersectionRatio = entry.intersectionRatio;
                const pageWrapper = entry.target;
                const pageNum = parseInt(pageWrapper.id.replace('page-wrapper-', ''));
                if (pageNum) {
                    mostVisiblePage = pageNum;
                }
            }
        });
        
        // Mettre √† jour seulement si la page la plus visible a chang√© ET si le ratio d'intersection est significatif
        // ET si on n'est pas en train de charger les annotations initiales
        if (mostVisiblePage !== currentPageNum && maxIntersectionRatio > 0.3 && !isLoadingInitialAnnotations) {
            console.log(`üîÑ === CHANGEMENT DE PAGE VIA OBSERVER ===`);
            console.log(`üìÑ Page visible chang√©e: ${currentPageNum} ‚Üí ${mostVisiblePage} (ratio: ${maxIntersectionRatio.toFixed(2)})`);
            
            const oldPageNum = currentPageNum;
            currentPageNum = mostVisiblePage;
            
            console.log(`üìä Avant changement - annotations page ${oldPageNum}: ${annotations.length}`);
            console.log(`üîÑ Chargement des annotations pour la nouvelle page ${currentPageNum}...`);
            
            // IMPORTANT: R√©initialiser les variables de dessin liss√© lors du changement de page
            resetSmoothDrawingVariables();
            
            // Charger les annotations de la nouvelle page
            loadPageAnnotations(currentPageNum);
            
            // NOUVEAU: Forcer le redessinage apr√®s changement de page
            setTimeout(() => {
                if (annotationCtx && annotations.length > 0) {
                    console.log(`üé® REDESSINAGE POST-CHANGEMENT PAGE - ${annotations.length} annotations pour page ${currentPageNum}`);
                    const wasDrawing = isDrawing;
                    isDrawing = false; // Temporairement d√©sactiver isDrawing
                    redrawAnnotations(true);
                    isDrawing = wasDrawing; // Restaurer l'√©tat pr√©c√©dent
                } else {
                    console.log(`‚ÑπÔ∏è Aucune annotation √† redessiner pour la page ${currentPageNum}`);
                }
            }, 100);
            
            updatePageInfo();
            updateActiveThumbnail();
            
            console.log(`üèÅ === FIN CHANGEMENT DE PAGE ===`);
        } else if (isLoadingInitialAnnotations) {
            console.log(`‚è∏Ô∏è Observer en pause - chargement initial des annotations en cours`);
        }
    }, observerOptions);
    
    // Stocker une r√©f√©rence globale pour pouvoir le r√©initialiser
    window.currentPageObserver = pageObserver;
    
    // Observer toutes les pages
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
        if (pageWrapper) {
            pageObserver.observe(pageWrapper);
            console.log(`üìÑ Observing page ${pageNum}`);
        }
    }
    
    // Ajouter un listener de scroll de secours pour garantir la navigation
    let scrollTimeout;
    viewerContainer.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            // D√©tecter manuellement quelle page est la plus visible
            let mostVisiblePage = 1;
            let maxVisibleArea = 0;
            
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
                if (pageWrapper) {
                    const rect = pageWrapper.getBoundingClientRect();
                    const containerRect = viewerContainer.getBoundingClientRect();
                    
                    // Calculer la surface visible
                    const visibleTop = Math.max(rect.top, containerRect.top);
                    const visibleBottom = Math.min(rect.bottom, containerRect.bottom);
                    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                    const visibleArea = visibleHeight * rect.width;
                    
                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        mostVisiblePage = pageNum;
                    }
                }
            }
            
            if (mostVisiblePage !== currentPageNum) {
                console.log(`üìÑ Scroll detection: Page ${currentPageNum} ‚Üí ${mostVisiblePage}`);
                currentPageNum = mostVisiblePage;
                updatePageInfo();
                updateActiveThumbnail();
            }
        }, 100);
    });
}

// Rendre une page PDF (fonction originale pour compatibilit√©)
async function renderPage(pageNum) {
    if (pageIsRendering) {
        pageNumIsPending = pageNum;
        return;
    }
    
    // Ne pas rerender si on est en train de dessiner
    if (isDrawing) {
        console.log('renderPage delayed - currently drawing');
        pageNumIsPending = pageNum;
        return;
    }
    
    pageIsRendering = true;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        
        // Calculer la viewport avec une √©chelle plus √©lev√©e pour la qualit√©
        const baseScale = 2.0; // Base scale pour la qualit√©
        const displayScale = currentScale;
        const renderScale = baseScale * displayScale;
        
        const viewport = page.getViewport({ scale: renderScale });
        
        // Configurer les canvas
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        
        // Ne redimensionner le canvas d'annotation que si n√©cessaire
        if (annotationCanvas.width !== viewport.width || annotationCanvas.height !== viewport.height) {
            console.log('üìê Resizing annotation canvas from', annotationCanvas.width, 'x', annotationCanvas.height, 'to', viewport.width, 'x', viewport.height);
            
            // Si on est en train de dessiner, arr√™ter le trait en cours
            if (isDrawing) {
                console.warn('‚ö†Ô∏è Canvas resize during drawing! Stopping current stroke...');
                isDrawing = false;
                currentStroke = [];
            }
            
            annotationCanvas.width = viewport.width;
            annotationCanvas.height = viewport.height;
            
            // R√©cr√©er le contexte apr√®s redimensionnement
            annotationCtx = annotationCanvas.getContext('2d');
            ctx = annotationCtx; // Variable de compatibilit√©
            
            // Forcer le repositionnement apr√®s redimensionnement
            forceCanvasPositioning();
        }
        
        // Appliquer le scale CSS pour l'affichage
        const cssScale = displayScale / baseScale;
        const transform = `scale(${cssScale})`;
        
        // D'abord d√©finir les dimensions CSS explicites AVANT la transformation
        pdfCanvas.style.width = viewport.width + 'px';
        pdfCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.width = viewport.width + 'px';
        annotationCanvas.style.height = viewport.height + 'px';
        
        // Ensuite appliquer la transformation
        pdfCanvas.style.transform = transform;
        annotationCanvas.style.transform = transform;
        pdfCanvas.style.transformOrigin = '0 0';
        annotationCanvas.style.transformOrigin = '0 0';
        
        // Ajuster la taille du conteneur pour contenir les canvas transform√©s
        const container = pdfCanvas.parentElement;
        const containerWidth = viewport.width * cssScale;
        const containerHeight = viewport.height * cssScale;
        
        container.style.width = containerWidth + 'px';
        container.style.height = containerHeight + 'px';
        
        // Rendre la page
        const renderContext = {
            canvasContext: pdfCtx,
            viewport: viewport
        };
        
        await page.render(renderContext).promise;
        
        // Redessiner les annotations (seulement si on n'est pas en train de charger les annotations initiales)
        if (!isLoadingInitialAnnotations) {
            redrawAnnotations();
        } else {
            console.log('üìÑ Redessinage d\'annotations saut√© - chargement initial en cours');
        }
        
        // Forcer l'alignement parfait des canvas apr√®s le rendu
        forceCanvasPositioning();
        
        pageIsRendering = false;
        
        // Rendre une page en attente si n√©cessaire
        if (pageNumIsPending !== null) {
            const pending = pageNumIsPending;
            pageNumIsPending = null;
            await renderPage(pending);
        }
        
    } catch (error) {
        console.error('Erreur lors du rendu de la page:', error);
        pageIsRendering = false;
    }
}

// Charger une image avec qualit√© am√©lior√©e
async function loadImage(fileId) {
    const imageUrl = `/file_manager/serve_file/${fileId}`;
    
    try {
        const img = new Image();
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = imageUrl;
        });
        
        // Configurer les canvas pour l'image
        const scale = Math.min(800 / img.width, 600 / img.height, 2.0);
        const width = img.width * scale;
        const height = img.height * scale;
        
        pdfCanvas.width = width;
        pdfCanvas.height = height;
        annotationCanvas.width = width;
        annotationCanvas.height = height;
        
        // Dessiner l'image avec anti-aliasing
        pdfCtx.imageSmoothingEnabled = true;
        pdfCtx.imageSmoothingQuality = 'high';
        pdfCtx.drawImage(img, 0, 0, width, height);
        
        // Masquer les contr√¥les PDF (supprim√©s)
        
    } catch (error) {
        console.error('Erreur lors du chargement de l\'image:', error);
        throw error;
    }
}

// ===== FONCTIONS DE NAVIGATION PDF =====

// Navigation entre pages
// Fonction previousPage() supprim√©e - navigation via scroll uniquement
/*
function previousPage() {
    if (currentPageNum <= 1 || !pdfDoc) return;
    if (isDrawing) {
        console.log('previousPage delayed - currently drawing');
        return;
    }
    
    isNavigating = true; // Marquer le d√©but de la navigation
    
    // En mode multi-pages, faire d√©filer jusqu'√† la page
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (pagesContainer) {
        currentPageNum--;
        const targetPage = document.getElementById(`page-wrapper-${currentPageNum}`);
        if (targetPage) {
            targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    } else {
        // Mode single page - ancien comportement
        // Sauvegarder les annotations de la page actuelle avant de changer
        console.log(`üìÑ Changement de page ${currentPageNum} vers ${currentPageNum - 1}`);
        saveCurrentPageAnnotations();
        
        currentPageNum--;
        
        // Charger les annotations de la nouvelle page AVANT de rendre
        loadPageAnnotations(currentPageNum);
        
        renderPage(currentPageNum);
    }
    
    updatePageInfo();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}
*/

// Fonction nextPage() supprim√©e - navigation via scroll uniquement  
/*
function nextPage() {
    if (currentPageNum >= pdfDoc.numPages || !pdfDoc) return;
    if (isDrawing) {
        console.log('nextPage delayed - currently drawing');
        return;
    }
    
    isNavigating = true; // Marquer le d√©but de la navigation
    
    // En mode multi-pages, faire d√©filer jusqu'√† la page
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (pagesContainer) {
        currentPageNum++;
        const targetPage = document.getElementById(`page-wrapper-${currentPageNum}`);
        if (targetPage) {
            targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    } else {
        // Mode single page - ancien comportement
        // Sauvegarder les annotations de la page actuelle avant de changer
        console.log(`üìÑ Changement de page ${currentPageNum} vers ${currentPageNum + 1}`);
        saveCurrentPageAnnotations();
        
        currentPageNum++;
        
        // Charger les annotations de la nouvelle page AVANT de rendre
        loadPageAnnotations(currentPageNum);
        
        renderPage(currentPageNum);
    }
    
    updatePageInfo();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}
*/

function goToPage(pageNum) {
    console.log(`üîç DEBUG: goToPage - Aller √† la page ${pageNum}`);
    if (pageNum < 1 || pageNum > pdfDoc.numPages) {
        console.warn(`‚ö†Ô∏è Page ${pageNum} hors limites (1-${pdfDoc.numPages})`);
        return;
    }
    if (pageNum === currentPageNum) {
        console.log('‚ÑπÔ∏è D√©j√† sur cette page');
        return; // D√©j√† sur cette page
    }
    
    isNavigating = true; // Marquer le d√©but de la navigation
    
    // En mode multi-pages, faire d√©filer jusqu'√† la page
    const pagesContainer = document.getElementById('pdfPagesContainer');
    const viewerContainer = document.getElementById('viewerContainer');
    
    if (pagesContainer && pagesContainer.children.length > 0 && viewerContainer) {
        console.log('üìÑ Mode multi-pages - Navigation vers la page', pageNum);
        const targetPage = document.getElementById(`page-wrapper-${pageNum}`);
        
        if (targetPage) {
            // M√©thode 1: ScrollIntoView avec behavior instant pour √©viter les blocages
            console.log('üéØ ScrollIntoView instant');
            targetPage.scrollIntoView({ behavior: 'instant', block: 'start' });
            
            // M√©thode 2: Calcul manuel de la position si scrollIntoView √©choue
            setTimeout(() => {
                const targetRect = targetPage.getBoundingClientRect();
                const containerRect = viewerContainer.getBoundingClientRect();
                
                // Si la page n'est pas visible apr√®s scrollIntoView, utiliser offsetTop
                if (targetRect.top < containerRect.top - 50 || targetRect.top > containerRect.bottom + 50) {
                    console.log('üö® ScrollIntoView √©chou√©, calcul manuel de la position');
                    const targetOffset = targetPage.offsetTop;
                    const containerPadding = 16; // padding du container
                    const scrollPosition = Math.max(0, targetOffset - containerPadding);
                    
                    console.log(`üìä Target offset: ${targetOffset}, scroll to: ${scrollPosition}`);
                    viewerContainer.scrollTop = scrollPosition;
                    
                    // V√©rification finale
                    setTimeout(() => {
                        const finalRect = targetPage.getBoundingClientRect();
                        const finalContainerRect = viewerContainer.getBoundingClientRect();
                        const isVisible = finalRect.top >= finalContainerRect.top && finalRect.top <= finalContainerRect.bottom;
                        console.log(`‚úÖ Page ${pageNum} ${isVisible ? 'visible' : 'TOUJOURS INVISIBLE'} apr√®s navigation manuelle`);
                        
                        if (!isVisible) {
                            // Derni√®re tentative: scroll avec scrollTo
                            viewerContainer.scrollTo(0, scrollPosition);
                            console.log('üîß Tentative scrollTo finale');
                        }
                    }, 50);
                }
            }, 50);
            
            // Mettre √† jour l'√©tat de la page
            currentPageNum = pageNum;
            updatePageInfo();
            updateActiveThumbnail();
            
            console.log(`‚úÖ Navigation vers page ${pageNum} initi√©e`);
        } else {
            console.error(`‚ùå page-wrapper-${pageNum} non trouv√©`);
            console.log('Pages disponibles:', Array.from(pagesContainer.children).map(c => c.id));
        }
    } else {
        // Mode single page - ancien comportement
        console.log('üìÑ Mode single page - Render page');
        console.log('pagesContainer trouv√©:', !!pagesContainer, 'Enfants:', pagesContainer ? pagesContainer.children.length : 0);
        
        // Sauvegarder les annotations de la page actuelle avant de changer
        saveCurrentPageAnnotations();
        
        currentPageNum = pageNum;
        
        // Charger les annotations de la nouvelle page AVANT de rendre
        loadPageAnnotations(currentPageNum);
        
        renderPage(currentPageNum);
    }
    
    updatePageInfo();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}

// Fonction pour calculer les coordonn√©es du canvas - corrig√©e pour la scale CSS
function getCanvasCoordinates(e) {
    try {
        // Utiliser getBoundingClientRect pour obtenir la position et taille actuelles du canvas
        const rect = annotationCanvas.getBoundingClientRect();
        
        // V√©rifier si la souris est au-dessus du canvas
        const isOverCanvas = (
            e.clientX >= rect.left && 
            e.clientX <= rect.right && 
            e.clientY >= rect.top && 
            e.clientY <= rect.bottom
        );
        
        // Calculer les coordonn√©es relatives au canvas visible
        // Important: utiliser rect.width/height (taille visible) plut√¥t que canvas.width/height (taille logique)
        const x = (e.clientX - rect.left) * (annotationCanvas.width / rect.width);
        const y = (e.clientY - rect.top) * (annotationCanvas.height / rect.height);
        
        // Debug temporaire pour v√©rifier les calculs
        if (Math.random() < 0.05) { // Log 5% des √©v√©nements pour √©viter le spam
            console.log('üîç Coordinate calculation:');
            console.log('  Mouse screen:', e.clientX, e.clientY);
            console.log('  Canvas rect (visible):', Math.round(rect.left), Math.round(rect.top), Math.round(rect.width), Math.round(rect.height));
            console.log('  Canvas logical:', annotationCanvas.width, annotationCanvas.height);
            console.log('  Scale factors:', Math.round(annotationCanvas.width / rect.width * 100) / 100, Math.round(annotationCanvas.height / rect.height * 100) / 100);
            console.log('  Calculated coords:', Math.round(x), Math.round(y));
            console.log('  Within bounds:', x >= 0 && x <= annotationCanvas.width && y >= 0 && y <= annotationCanvas.height);
        }
        
        // Retourner les coordonn√©es, en s'assurant qu'elles restent dans les limites du canvas logique
        return { 
            x: Math.max(0, Math.min(x, annotationCanvas.width - 1)),
            y: Math.max(0, Math.min(y, annotationCanvas.height - 1)),
            isOverCanvas: isOverCanvas
        };
        
    } catch (error) {
        console.error('‚ùå Erreur dans getCanvasCoordinates:', error);
        
        // Retourner une coordonn√©e s√ªre en cas d'erreur
        return { x: 0, y: 0, isOverCanvas: false };
    }
}

// Fonctions de zoom supprim√©es - non utilis√©es

// Mettre √† jour les informations de page
function updatePageInfo() {
    // Fonction simplifi√©e - plus d'affichage d'info de page dans l'interface
    // Les informations de page sont g√©r√©es via les miniatures et le scroll
    if (pdfDoc) {
        console.log(`üìÑ Page actuelle: ${currentPageNum} / ${pdfDoc.numPages}`);
    }
}

// Fonction de navigation supprim√©e - plus utilis√©e

// G√©n√©rer les miniatures
async function generateThumbnails() {
    if (!pdfDoc) return;
    
    const thumbnailsContainer = document.getElementById('pageThumbnails');
    thumbnailsContainer.innerHTML = '';
    
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const thumbnailItem = document.createElement('div');
        thumbnailItem.className = 'thumbnail-item';
        if (pageNum === currentPageNum) thumbnailItem.classList.add('active');
        
        const thumbnailCanvas = document.createElement('canvas');
        thumbnailCanvas.className = 'thumbnail-canvas';
        thumbnailCanvas.onclick = () => goToPage(pageNum);
        
        try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 0.3 });
            
            thumbnailCanvas.width = viewport.width;
            thumbnailCanvas.height = viewport.height;
            
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            await page.render({
                canvasContext: thumbnailCtx,
                viewport: viewport
            }).promise;
            
        } catch (error) {
            console.error(`Erreur lors de la g√©n√©ration de la miniature ${pageNum}:`, error);
        }
        
        const pageLabel = document.createElement('div');
        pageLabel.textContent = pageNum;
        pageLabel.style.textAlign = 'center';
        pageLabel.style.color = '#e2e8f0';
        pageLabel.style.fontSize = '0.8rem';
        pageLabel.style.marginTop = '0.25rem';
        
        thumbnailItem.appendChild(thumbnailCanvas);
        thumbnailItem.appendChild(pageLabel);
        thumbnailsContainer.appendChild(thumbnailItem);
    }
}

function updateActiveThumbnail() {
    document.querySelectorAll('.thumbnail-item').forEach((item, index) => {
        item.classList.toggle('active', index + 1 === currentPageNum);
    });
}

// Barre lat√©rale permanente - plus besoin de toggle

// ===== SYST√àME D'ANNOTATION AM√âLIOR√â =====

// Syst√®me d'annotation am√©lior√©
function setupAnnotationTools() {
    if (!annotationCanvas) {
        console.error('annotationCanvas not found!');
        return;
    }
    
    console.log('Setting up annotation tools on canvas:', annotationCanvas);
    
    // Debug des styles CSS
    const computedStyle = window.getComputedStyle(annotationCanvas);
    console.log('Canvas CSS styles:');
    console.log('  pointer-events:', computedStyle.pointerEvents);
    console.log('  z-index:', computedStyle.zIndex);
    console.log('  position:', computedStyle.position);
    console.log('  display:', computedStyle.display);
    console.log('  visibility:', computedStyle.visibility);
    
    // √âv√©nements de dessin simplifi√©s
    console.log('Attaching mousedown event listener...');
    annotationCanvas.addEventListener('mousedown', (e) => {
        console.log('üîΩ MOUSEDOWN EVENT');
        startDrawing(e);
    });
    
    console.log('Attaching mousemove event listener to DOCUMENT (for global coverage)...');
    document.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            draw(e);
        }
    });
    
    console.log('Attaching mouseup event listener to DOCUMENT (for global coverage)...');
    document.addEventListener('mouseup', (e) => {
        console.log('üîº MOUSEUP EVENT');
        stopDrawing(e);
    });
    
    console.log('Attaching mouseout event listener (for debugging only)...');
    annotationCanvas.addEventListener('mouseout', (e) => {
        console.log('üö™ MOUSEOUT EVENT (ignored)');
        // NE PAS appeler stopDrawing() ici - l'utilisateur doit pouvoir dessiner hors du canvas
    });
    
    // Support tactile
    annotationCanvas.addEventListener('touchstart', handleTouch, { passive: false });
    annotationCanvas.addEventListener('touchmove', handleTouch, { passive: false });
    annotationCanvas.addEventListener('touchend', handleTouch, { passive: false });
    
    console.log('Event listeners attached successfully');
    
    // Test de d√©bogage AM√âLIOR√â : v√©rifier quel √©l√©ment re√ßoit les clics
    document.addEventListener('mousedown', (e) => {
        if (!annotationCanvas) return;
        
        // V√©rifier si le clic est sur un √©l√©ment d'interface (√† exclure de l'interception)
        const isUIElement = e.target.matches('input, button, select, textarea, .tool-btn, .color-btn, .stroke-width-container, .stroke-width-container *, .annotation-toolbar, .annotation-toolbar *');
        
        if (isUIElement) {
            console.log('üéõÔ∏è Click on UI element, allowing normal behavior:', e.target);
            return; // Laisser le comportement normal pour les √©l√©ments d'interface
        }
        
        const rect = annotationCanvas.getBoundingClientRect();
        const isOverCanvas = e.clientX >= rect.left && e.clientX <= rect.right && 
                           e.clientY >= rect.top && e.clientY <= rect.bottom;
        
        if (isOverCanvas) {
            console.log('üéØ CLICK ANALYSIS:');
            console.log('  üìç Mouse position:', e.clientX, e.clientY);
            console.log('  üì¶ Canvas bounds:', rect);
            console.log('  üéØ Target element:', e.target);
            console.log('  ‚ùì Is annotation canvas?', e.target === annotationCanvas);
            console.log('  üîç Element at point:', document.elementFromPoint(e.clientX, e.clientY));
            console.log('  üìä Target classes:', e.target.className);
            console.log('  üè∑Ô∏è Target ID:', e.target.id);
            console.log('  üå≥ Target parent:', e.target.parentElement);
            
            // CSS debugging
            const targetStyle = window.getComputedStyle(e.target);
            console.log('  üé® Target z-index:', targetStyle.zIndex);
            console.log('  üëÜ Target pointer-events:', targetStyle.pointerEvents);
            console.log('  üìê Target position:', targetStyle.position);
            
            const canvasStyle = window.getComputedStyle(annotationCanvas);
            console.log('  üé® Canvas z-index:', canvasStyle.zIndex);
            console.log('  üëÜ Canvas pointer-events:', canvasStyle.pointerEvents);
            
            console.log('üéØ Click intercepted and will be redirected to canvas');
            
            // Si le clic n'est pas directement sur le canvas, forcer l'√©v√©nement
            if (e.target !== annotationCanvas) {
                console.log('üîÑ FORCING click to annotation canvas...');
                e.preventDefault();
                e.stopPropagation();
                
                const canvasEvent = new MouseEvent('mousedown', {
                    clientX: e.clientX,
                    clientY: e.clientY,
                    button: e.button,
                    buttons: e.buttons,
                    bubbles: true
                });
                annotationCanvas.dispatchEvent(canvasEvent);
            }
        }
    }, true); // Utiliser capture phase pour intercepter t√¥t
    
    // D√©marrer le monitoring
    // Monitoring d√©sactiv√© pour simplifier
    
    // D√©tecteurs de clics globaux supprim√©s pour simplifier
    
    // √âv√©nements des outils configur√©s maintenant dans le bon ordre apr√®s loadAnnotations()
}

// Fonctions de diagnostic supprim√©es pour simplifier le code

function setupToolEvents() {
    console.log('üîß === CONFIGURATION DES √âV√âNEMENTS D\'OUTILS ===');
    
    // Outils de dessin
    const toolButtons = document.querySelectorAll('[data-tool]');
    console.log('üîò Boutons d\'outils trouv√©s:', toolButtons.length);
    
    toolButtons.forEach((btn, index) => {
        console.log(`  Bouton ${index}: ${btn.id || 'sans ID'} (data-tool: ${btn.dataset.tool})`);
        btn.addEventListener('click', () => {
            console.log('üñ±Ô∏è Clic sur bouton outil:', btn.dataset.tool);
            setAnnotationTool(btn.dataset.tool);
        });
    });
    
    // Couleurs
    const colorButtons = document.querySelectorAll('.color-btn');
    console.log('üé® Boutons de couleur trouv√©s:', colorButtons.length);
    
    colorButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            console.log('üñ±Ô∏è Clic sur couleur:', btn.dataset.color);
            setAnnotationColor(btn.dataset.color);
        });
    });
    
    const colorPicker = document.getElementById('annotationColor');
    if (colorPicker) {
        console.log('üé® Color picker trouv√© et configur√©');
        colorPicker.addEventListener('change', (e) => {
            console.log('üñ±Ô∏è Changement color picker:', e.target.value);
            setAnnotationColor(e.target.value);
        });
    } else {
        console.warn('‚ö†Ô∏è Color picker non trouv√©');
    }
    
    // √âpaisseur
    const strokeWidthSlider = document.getElementById('strokeWidth');
    const strokeWidthValue = document.getElementById('strokeWidthValue');
    
    if (strokeWidthSlider) {
        console.log('üìè Stroke width slider found:', strokeWidthSlider);
        console.log('üìè Initial value:', strokeWidthSlider.value);
        console.log('üìè Min:', strokeWidthSlider.min, 'Max:', strokeWidthSlider.max);
        console.log('üìè Disabled:', strokeWidthSlider.disabled);
        
        strokeWidthSlider.addEventListener('input', (e) => {
            setStrokeWidth(e.target.value);
        });
        
        // Ajouter aussi l'√©v√©nement 'change' pour les navigateurs qui ne supportent pas bien 'input'
        strokeWidthSlider.addEventListener('change', (e) => {
            setStrokeWidth(e.target.value);
        });
        
        // Test si le curseur est accessible
        strokeWidthSlider.addEventListener('mousedown', (e) => {
            console.log('üñ±Ô∏è Mouse down on slider');
        });
        
        strokeWidthSlider.addEventListener('click', (e) => {
            console.log('üñ±Ô∏è Click on slider at position:', e.offsetX);
        });
    } else {
        console.error('‚ùå Stroke width slider not found!');
    }
    
    // Actions
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);
}

// Changer d'outil d'annotation
function setAnnotationTool(tool) {
    // Synchroniser les deux variables pour √©viter les incoh√©rences
    currentAnnotationTool = tool;
    currentTool = tool;
    
    // R√©initialiser les variables de dessin liss√© lors du changement d'outil
    resetSmoothDrawingVariables();
    
    console.log('üîß Outil chang√© vers:', tool);
    
    // Mettre √† jour l'interface
    document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const toolBtn = document.querySelector(`[data-tool="${tool}"]`);
    if (toolBtn) {
        toolBtn.classList.add('active');
    }
    
    // Changer le curseur sur tous les canvas d'annotation
    document.querySelectorAll('.annotation-canvas').forEach(canvas => {
        canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
    });
    
    // Changer le curseur sur le canvas principal si disponible
    if (annotationCanvas) {
        annotationCanvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
    }
}

// Changer de couleur
function setAnnotationColor(color) {
    currentColor = color;
    currentAnnotationColor = color; // Synchroniser les deux variables
    
    console.log('üé® Couleur chang√©e vers:', color);
    
    // Mettre √† jour l'interface
    document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const colorBtn = document.querySelector(`[data-color="${color}"]`);
    if (colorBtn) {
        colorBtn.classList.add('active');
    }
    
    // Mettre √† jour l'input color picker
    const colorPicker = document.getElementById('annotationColor');
    if (colorPicker) {
        colorPicker.value = color;
    }
}

// Fonction pour mettre √† jour la taille du trait
function setStrokeWidth(width) {
    currentStrokeWidth = parseInt(width);
    
    console.log('üìè √âpaisseur chang√©e vers:', currentStrokeWidth);
    
    // Mettre √† jour l'affichage de la valeur
    const strokeWidthValue = document.getElementById('strokeWidthValue');
    if (strokeWidthValue) {
        strokeWidthValue.textContent = currentStrokeWidth;
    }
    
    // Mettre √† jour le slider
    const strokeWidthSlider = document.getElementById('strokeWidth');
    if (strokeWidthSlider) {
        strokeWidthSlider.value = currentStrokeWidth;
    }
}

// Fonction de dessin simple - bas√©e sur la logique de la gomme qui fonctionne
function startDrawing(e) {
    if (!annotationCtx || !annotationCanvas) {
        console.error('‚ùå Canvas ou contexte indisponible');
        return;
    }
    
    isDrawing = true;
    currentStroke = [];
    
    console.log('üé® D√©but du dessin avec outil:', currentAnnotationTool);
    
    const coords = getCanvasCoordinates(e);
    coords.timestamp = Date.now(); // Ajouter timestamp pour calculer la vitesse
    currentStroke.push(coords);
    
    if (currentAnnotationTool === 'eraser') {
        eraseAt(coords.x, coords.y);
    } else {
        // Pour le stylo : commencer un nouveau path avec le nouveau syst√®me
        initializeSmoothDrawing(coords.x, coords.y);
    }
}

// Fonction de dessin simplifi√©e
function draw(e) {
    if (!isDrawing) return;
    
    const coords = getCanvasCoordinates(e);
    coords.timestamp = Date.now(); // Ajouter timestamp pour calculer la vitesse
    currentStroke.push(coords);
    
    if (currentAnnotationTool === 'eraser') {
        eraseAt(coords.x, coords.y);
    } else {
        // Pour le stylo : continuer le trait avec lissage
        continueSmoothDrawing(coords.x, coords.y);
    }
}

// Fonction d'arr√™t simplifi√©e
function stopDrawing() {
    if (!isDrawing) return;
    
    console.log('üõë Arr√™t du dessin');
    isDrawing = false;
    
    // Finaliser le dessin liss√©
    if (currentAnnotationTool !== 'eraser') {
        finalizeSmoothDrawing();
        // PAS de restore() pour √©viter la perte de contexte
    }
    
    // Sauvegarder l'annotation si ce n'est pas la gomme
    if (currentStroke.length > 0 && currentAnnotationTool !== 'eraser') {
        const annotation = {
            type: currentAnnotationTool,
            color: currentColor,
            strokeWidth: currentStrokeWidth,
            points: [...currentStroke],
            page: currentPageNum,
            scale: currentScale,
            timestamp: Date.now()
        };
        
        annotations.push(annotation);
        undoHistory.push(annotations.length - 1);
        console.log('üíæ Annotation sauvegard√©e avec', currentStroke.length, 'points');
    }
    
    currentStroke = [];
    // R√©initialiser les variables de dessin pour le prochain trait
    resetSmoothDrawingVariables();
}

// Fonction de dessin simple - inspir√©e d'eraseAt qui fonctionne bien
// === SYST√àME DE DESSIN LISS√â (STYLE PROCREATE) ===

// Variables pour le dessin liss√© style Procreate
let lastPoint = null;
let lastVelocity = 0;
let strokePressure = 1.0;
let smoothDrawingInitialized = false;
let currentPath = null; // Stocke le path en cours
let drawingPoints = []; // Buffer des points pour le lissage
let isRealTimeSmoothing = true;

// Fonction pour r√©initialiser les variables de dessin liss√©
function resetSmoothDrawingVariables() {
    lastPoint = null;
    lastVelocity = 0;
    strokePressure = 1.0;
    smoothDrawingInitialized = false;
    currentPath = null;
    drawingPoints = [];
    console.log('üîÑ Variables de dessin liss√© r√©initialis√©es');
}

// Initialiser le dessin liss√© style Procreate
function initializeSmoothDrawing(x, y) {
    // R√©initialiser les variables si c'est un nouveau trait
    if (!smoothDrawingInitialized) {
        resetSmoothDrawingVariables();
    }
    
    // Configurer le style pour ce trait - SANS save() pour √©viter les probl√®mes de contexte
    if (currentAnnotationTool === 'pen') {
        annotationCtx.globalCompositeOperation = 'source-over';
        annotationCtx.strokeStyle = currentColor;
        annotationCtx.lineCap = 'round';
        annotationCtx.lineJoin = 'round';
        annotationCtx.globalAlpha = 1.0;
    } else if (currentAnnotationTool === 'highlighter') {
        annotationCtx.globalCompositeOperation = 'multiply';
        annotationCtx.strokeStyle = currentColor;
        annotationCtx.lineCap = 'round';
        annotationCtx.lineJoin = 'round';
        annotationCtx.globalAlpha = 0.3;
    }
    
    // Calculer la largeur initiale
    const initialWidth = calculateStrokeWidth(0);
    annotationCtx.lineWidth = initialWidth;
    
    // Initialiser les variables de lissage
    lastPoint = { x: x, y: y, timestamp: Date.now() };
    lastVelocity = 0;
    strokePressure = 1.0;
    smoothDrawingInitialized = true;
    
    // Initialiser le buffer de points pour le lissage
    drawingPoints = [{ x, y, timestamp: Date.now() }];
    
    // Commencer un nouveau path continu
    annotationCtx.beginPath();
    annotationCtx.moveTo(x, y);
    
    console.log('üé® Dessin liss√© Procreate initialis√© √†', {x, y});
}

// Continuer le dessin liss√© en temps r√©el (style Procreate)
function continueSmoothDrawing(x, y) {
    if (!lastPoint || !smoothDrawingInitialized) {
        console.warn('‚ö†Ô∏è continueSmoothDrawing appel√© sans initialisation');
        return;
    }
    
    // V√©rifier que le contexte est encore valide
    if (!annotationCtx) {
        console.error('‚ùå Context d\'annotation perdu - r√©initialisation n√©cessaire');
        resetSmoothDrawingVariables();
        return;
    }
    
    const currentTime = Date.now();
    
    // Ajouter le nouveau point au buffer
    drawingPoints.push({ x, y, timestamp: currentTime });
    
    // Garder seulement les 4 derniers points pour le lissage
    if (drawingPoints.length > 4) {
        drawingPoints.shift();
    }
    
    // Dessiner en temps r√©el seulement s'il y a assez de points
    if (drawingPoints.length >= 2) {
        drawSmoothSegment();
    }
    
    // Mettre √† jour le dernier point
    lastPoint = { x: x, y: y, timestamp: currentTime };
}

// Dessiner un segment liss√© en temps r√©el
function drawSmoothSegment() {
    if (drawingPoints.length < 2) return;
    
    const len = drawingPoints.length;
    const currentPoint = drawingPoints[len - 1];
    const previousPoint = drawingPoints[len - 2];
    
    // Calculer la vitesse
    const distance = Math.sqrt(
        Math.pow(currentPoint.x - previousPoint.x, 2) + 
        Math.pow(currentPoint.y - previousPoint.y, 2)
    );
    const timeDelta = currentPoint.timestamp - previousPoint.timestamp;
    const velocity = timeDelta > 0 ? distance / Math.max(timeDelta, 1) : 0;
    
    // Lisser la vitesse
    const smoothedVelocity = lastVelocity * 0.6 + velocity * 0.4;
    lastVelocity = smoothedVelocity;
    
    // Calculer la largeur du trait
    const strokeWidth = calculateStrokeWidth(smoothedVelocity);
    annotationCtx.lineWidth = strokeWidth;
    
    // Dessiner selon le nombre de points disponibles
    if (len >= 3) {
        // Utiliser une courbe de B√©zier pour un lissage optimal
        const p0 = drawingPoints[len - 3];
        const p1 = drawingPoints[len - 2];
        const p2 = drawingPoints[len - 1];
        
        // Calculer les points de contr√¥le pour une courbe lisse
        const cp1x = p1.x + (p2.x - p0.x) * 0.2;
        const cp1y = p1.y + (p2.y - p0.y) * 0.2;
        
        // Dessiner la courbe de B√©zier quadratique
        annotationCtx.quadraticCurveTo(cp1x, cp1y, p2.x, p2.y);
    } else {
        // Pour les deux premiers points, dessiner une ligne simple
        annotationCtx.lineTo(currentPoint.x, currentPoint.y);
    }
    
    // Appliquer le stroke en temps r√©el pour voir le trait se former
    annotationCtx.stroke();
    
    // Continuer le path sans le fermer
    annotationCtx.beginPath();
    annotationCtx.moveTo(currentPoint.x, currentPoint.y);
}

// Calculer la largeur du trait bas√©e sur la vitesse (simulation de pression)
function calculateStrokeWidth(velocity) {
    const baseWidth = currentStrokeWidth * (currentScale || 1);
    const multiplier = currentAnnotationTool === 'highlighter' ? 3 : 1;
    
    // Plus la vitesse est √©lev√©e, plus le trait est fin (comme avec un vrai stylo)
    // Normaliser la vitesse (valeurs typiques entre 0 et 20 pixels/ms)
    const normalizedVelocity = Math.min(velocity / 5, 1);
    
    // Calculer la variation de largeur (20% de variation max)
    const minWidth = baseWidth * 0.8;
    const maxWidth = baseWidth * 1.2;
    
    // Vitesse faible = trait plus √©pais, vitesse √©lev√©e = trait plus fin
    const dynamicWidth = maxWidth - (normalizedVelocity * (maxWidth - minWidth));
    
    return dynamicWidth * multiplier;
}

// Finaliser le dessin liss√©
function finalizeSmoothDrawing() {
    if (drawingPoints.length > 0) {
        // Terminer le path avec une largeur stable
        const finalWidth = calculateStrokeWidth(0);
        annotationCtx.lineWidth = finalWidth;
        
        // Dessiner les derniers segments s'il y en a
        if (drawingPoints.length >= 2) {
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            annotationCtx.lineTo(lastPoint.x, lastPoint.y);
            annotationCtx.stroke();
        }
    }
    
    console.log('üèÅ Finalisation du dessin liss√© Procreate avec', drawingPoints.length, 'points');
    // R√©initialiser les variables SANS restore() pour √©viter les probl√®mes
    resetSmoothDrawingVariables();
}

// === FIN DU SYST√àME DE DESSIN LISS√â ===

function drawAt(x, y, isStart) {
    if (isStart) {
        // Configurer le style pour ce trait
        annotationCtx.save();
        
        if (currentAnnotationTool === 'pen') {
            annotationCtx.globalCompositeOperation = 'source-over';
            annotationCtx.strokeStyle = currentColor;
            annotationCtx.lineWidth = currentStrokeWidth * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 1.0;
        } else if (currentAnnotationTool === 'highlighter') {
            annotationCtx.globalCompositeOperation = 'multiply';
            annotationCtx.strokeStyle = currentColor;
            annotationCtx.lineWidth = currentStrokeWidth * 3 * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 0.3;
        }
        
        // Commencer un nouveau path
        annotationCtx.beginPath();
        annotationCtx.moveTo(x, y);
    } else {
        // Continuer le trait
        annotationCtx.lineTo(x, y);
        annotationCtx.stroke();
    }
}

// Fonction d'effacement am√©lior√©e
function eraseAt(x, y) {
    const eraseRadius = currentStrokeWidth * 3 * (currentScale || 1);
    
    // Effacer dans un rayon autour du point
    annotationCtx.save();
    annotationCtx.globalCompositeOperation = 'destination-out';
    annotationCtx.beginPath();
    annotationCtx.arc(x, y, eraseRadius, 0, 2 * Math.PI);
    annotationCtx.fill();
    annotationCtx.restore();
    
    // Marquer les annotations comme effac√©es dans cette zone
    annotations.forEach(annotation => {
        if (annotation.page && annotation.page !== currentPageNum) return;
        
        annotation.points = annotation.points.filter(point => {
            const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
            return distance > eraseRadius;
        });
    });
    
    // Supprimer les annotations vides
    annotations = annotations.filter(annotation => annotation.points.length > 0);
    
    // Sauvegarde d√©sactiv√©e pendant le dessin pour √©viter les blocages
    // scheduleAutoSave();
}

// Fonction stopDrawing supprim√©e - doublon

// Gestion tactile am√©lior√©e
function handleTouch(e) {
    e.preventDefault();
    
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(
            e.type === 'touchstart' ? 'mousedown' : 
            e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
            {
                clientX: touch.clientX,
                clientY: touch.clientY
            }
        );
        
        annotationCanvas.dispatchEvent(mouseEvent);
    }
}

// Redessiner les annotations
function redrawAnnotations() {
    // Ne pas redessiner si on est en train de dessiner pour √©viter d'effacer le trait en cours
    // SAUF si c'est pour charger les annotations initiales (forceRedraw = true)
    const forceRedraw = arguments[0] === true;
    if (isDrawing && !forceRedraw) {
        console.log('redrawAnnotations skipped - currently drawing (use redrawAnnotations(true) to force)');
        return;
    }
    
    if (forceRedraw) {
        console.log('üîÑ FORCE REDRAW - redessinage forc√© m√™me pendant le dessin');
    }
    
    console.log(`üé® === REDRAW ANNOTATIONS DEBUG ===`);
    console.log(`üìÑ Page actuelle: ${currentPageNum}`);
    console.log(`üìä Variable annotations.length: ${annotations.length}`);
    console.log(`üìä annotationsByPage[${currentPageNum}]?.length: ${annotationsByPage[currentPageNum]?.length || 0}`);
    console.log(`üìä Contenu annotations:`, annotations);
    console.log(`üìä Contenu annotationsByPage[${currentPageNum}]:`, annotationsByPage[currentPageNum]);
    
    // CORRECTION CRITIQUE: Toujours utiliser le canvas de la page actuelle
    const currentAnnotationCanvas = document.getElementById(`annotation-canvas-${currentPageNum}`);
    if (!currentAnnotationCanvas) {
        console.error(`‚ùå redrawAnnotations: Canvas annotation-canvas-${currentPageNum} non trouv√©!`);
        return;
    }
    
    const currentAnnotationCtx = currentAnnotationCanvas.getContext('2d');
    if (!currentAnnotationCtx) {
        console.error(`‚ùå redrawAnnotations: Impossible d'obtenir le contexte du canvas annotation-canvas-${currentPageNum}`);
        return;
    }
    
    console.log(`üéØ Utilisation du canvas correct: annotation-canvas-${currentPageNum}`);
    console.log(`üìè Dimensions canvas: ${currentAnnotationCanvas.width}x${currentAnnotationCanvas.height}`);
    
    // Effacer le canvas CORRECT
    console.log('üßπ Effacement du canvas...');
    currentAnnotationCtx.clearRect(0, 0, currentAnnotationCanvas.width, currentAnnotationCanvas.height);
    
    // Compter les annotations qui seront dessin√©es
    let drawnCount = 0;
    
    annotations.forEach((annotation, index) => {
        if (!annotation || !annotation.points || annotation.points.length === 0) {
            console.log(`‚ùå Annotation ${index} skipped - no points:`, annotation);
            return;
        }
        
        // Double v√©rification pour d√©tecter d'√©ventuels probl√®mes de filtrage
        if (annotation.page && annotation.page !== currentPageNum) {
            console.error(`üö® BUG D√âTECT√â: Annotation ${index} de la page ${annotation.page} trouv√©e dans le tableau de la page ${currentPageNum}!`, annotation);
            return;
        }
        
        console.log(`‚úèÔ∏è Drawing annotation ${index}:`, {
            type: annotation.type,
            color: annotation.color,
            strokeWidth: annotation.strokeWidth,
            pointsCount: annotation.points.length,
            page: annotation.page
        });
        
        currentAnnotationCtx.beginPath();
        currentAnnotationCtx.moveTo(annotation.points[0].x, annotation.points[0].y);
        
        // Configurer le style
        if (annotation.type === 'pen') {
            currentAnnotationCtx.globalCompositeOperation = 'source-over';
            currentAnnotationCtx.strokeStyle = annotation.color;
            currentAnnotationCtx.lineWidth = annotation.strokeWidth * (currentScale || 1);
            currentAnnotationCtx.lineCap = 'round';
            currentAnnotationCtx.lineJoin = 'round';
            currentAnnotationCtx.globalAlpha = 1.0;
        } else if (annotation.type === 'highlighter') {
            currentAnnotationCtx.globalCompositeOperation = 'multiply';
            currentAnnotationCtx.strokeStyle = annotation.color;
            currentAnnotationCtx.lineWidth = annotation.strokeWidth * 3 * (currentScale || 1);
            currentAnnotationCtx.lineCap = 'round';
            currentAnnotationCtx.lineJoin = 'round';
            currentAnnotationCtx.globalAlpha = 0.3;
        }
        
        // Dessiner le trait avec lissage quadratique pour un meilleur rendu
        if (annotation.points.length === 1) {
            // Point unique - dessiner un petit cercle
            currentAnnotationCtx.arc(annotation.points[0].x, annotation.points[0].y, currentAnnotationCtx.lineWidth / 2, 0, 2 * Math.PI);
            currentAnnotationCtx.fill();
        } else if (annotation.points.length === 2) {
            // Trait simple entre deux points
            currentAnnotationCtx.lineTo(annotation.points[1].x, annotation.points[1].y);
            currentAnnotationCtx.stroke();
        } else {
            // Trait complexe - utiliser des courbes quadratiques pour un rendu plus lisse
            for (let i = 1; i < annotation.points.length - 1; i++) {
                const currentPoint = annotation.points[i];
                const nextPoint = annotation.points[i + 1];
                
                // Point de contr√¥le au milieu pour la courbe quadratique
                const controlX = (currentPoint.x + nextPoint.x) / 2;
                const controlY = (currentPoint.y + nextPoint.y) / 2;
                
                currentAnnotationCtx.quadraticCurveTo(currentPoint.x, currentPoint.y, controlX, controlY);
            }
            
            // Finir jusqu'au dernier point
            const lastPoint = annotation.points[annotation.points.length - 1];
            currentAnnotationCtx.lineTo(lastPoint.x, lastPoint.y);
            currentAnnotationCtx.stroke();
        }
        
        if (annotation.type === 'highlighter') {
            currentAnnotationCtx.globalAlpha = 1.0;
        }
        
        drawnCount++;
    });
    
    console.log(`‚úÖ redrawAnnotations completed: ${drawnCount}/${annotations.length} annotations drawn on canvas annotation-canvas-${currentPageNum}`);
}

// Charger les annotations
async function loadAnnotations(fileId) {
    try {
        isLoadingInitialAnnotations = true;
        console.log('üìÑ Chargement des annotations depuis le serveur...');
        const response = await fetch(`/planning/get_file_annotations/${fileId}`);
        const result = await response.json();
        
        if (result.success) {
            // Utiliser le nouveau syst√®me pour charger toutes les annotations
            loadAllAnnotations(result.annotations);
            console.log('üìÑ Annotations charg√©es avec succ√®s depuis le serveur');
        } else {
            console.log('üìÑ Aucune annotation trouv√©e sur le serveur - d√©marrage avec document vierge');
            loadAllAnnotations({});
        }
    } catch (error) {
        console.error('Erreur lors du chargement des annotations:', error);
        loadAllAnnotations({});
    } finally {
        // D√©lai de s√©curit√© pour laisser le temps aux annotations de s'afficher
        setTimeout(() => {
            isLoadingInitialAnnotations = false;
            console.log('üîì Observer r√©activ√© - chargement initial termin√©');
        }, 500);
    }
}

// Annuler la derni√®re action
function undo() {
    if (annotations.length > 0) {
        // Annuler uniquement sur la page actuelle
        annotations.pop(); // Supprimer la derni√®re annotation
        redrawAnnotations();
        console.log(`‚Ü©Ô∏è Annulation effectu√©e sur la page ${currentPageNum}, ${annotations.length} annotations restantes`);
        // Les annotations seront sauvegard√©es automatiquement lors du changement de page
    }
}

// Tout effacer
function clearAll() {
    if (confirm('√ätes-vous s√ªr de vouloir effacer toutes les annotations de cette page ?')) {
        const removedCount = annotations.length;
        annotations = []; // Vider toutes les annotations de la page actuelle
        undoHistory = []; // Vider l'historique aussi
        redrawAnnotations();
        console.log(`üóëÔ∏è ${removedCount} annotations supprim√©es de la page ${currentPageNum}`);
        // Les changements seront sauvegard√©s automatiquement lors du changement de page
    }
}

// === GESTION DES ANNOTATIONS PAR PAGE ===

// Sauvegarder les annotations de la page actuelle dans la structure par page
function saveCurrentPageAnnotations() {
    if (!currentPageNum) return;
    
    // FILTRER les annotations pour ne sauvegarder que celles de la page actuelle
    const pageAnnotations = annotations.filter(annotation => {
        // Inclure les annotations sans page d√©finie (legacy) ou celles de la page actuelle
        return !annotation.page || annotation.page === currentPageNum;
    });
    
    if (pageAnnotations.length > 0) {
        annotationsByPage[currentPageNum] = [...pageAnnotations]; // Copie du tableau FILTR√â
        console.log(`üìÑ ${pageAnnotations.length} annotations sauvegard√©es pour la page ${currentPageNum}:`, pageAnnotations);
    } else {
        // Si aucune annotation, supprimer la page de la structure (√©conomise l'espace)
        if (annotationsByPage[currentPageNum]) {
            delete annotationsByPage[currentPageNum];
            console.log(`üìÑ Page ${currentPageNum} supprim√©e (aucune annotation)`);
        }
    }
    
    // Sauvegarder aussi l'historique d'annulation
    if (undoHistory.length > 0) {
        undoHistoryByPage[currentPageNum] = [...undoHistory];
    } else {
        // Nettoyer l'historique vide
        if (undoHistoryByPage[currentPageNum]) {
            delete undoHistoryByPage[currentPageNum];
        }
    }
}

// Charger les annotations d'une page sp√©cifique
function loadPageAnnotations(pageNum) {
    console.log(`üîÑ === LOAD PAGE ANNOTATIONS APPEL√âE ===`);
    console.log(`üìÑ Chargement des annotations pour la page ${pageNum}`);
    console.log(`üìÑ Annotations disponibles par page:`, Object.keys(annotationsByPage));
    console.log(`üìÑ Variable annotations avant chargement:`, annotations.length, '√©l√©ments');
    
    // Tracer qui appelle cette fonction
    console.trace('üìç Trace de l\'appel loadPageAnnotations:');
    
    // IMPORTANT: R√©initialiser les variables de dessin liss√© lors du chargement d'une nouvelle page
    resetSmoothDrawingVariables();
    
    // CORRECTION CRITIQUE: Mettre √† jour les variables globales pour pointer vers la bonne page
    annotationCanvas = document.getElementById(`annotation-canvas-${pageNum}`);
    if (annotationCanvas) {
        annotationCtx = annotationCanvas.getContext('2d');
        canvas = annotationCanvas; // Variable de compatibilit√©
        ctx = annotationCtx; // Variable de compatibilit√©
        console.log(`üéØ Variables globales mises √† jour pour la page ${pageNum}`);
    } else {
        console.error(`‚ùå Canvas annotation-canvas-${pageNum} introuvable!`);
    }
    
    // Charger les annotations de cette page
    if (annotationsByPage[pageNum]) {
        const rawAnnotations = [...annotationsByPage[pageNum]]; // Copie du tableau
        
        // DOUBLE FILTRAGE pour s'assurer qu'on n'a que les annotations de cette page
        annotations = rawAnnotations.filter(annotation => {
            // Inclure les annotations sans page d√©finie (legacy) ou celles de cette page
            return !annotation.page || annotation.page === pageNum;
        });
        
        if (rawAnnotations.length !== annotations.length) {
            console.warn(`‚ö†Ô∏è NETTOYAGE: ${rawAnnotations.length - annotations.length} annotations d'autres pages supprim√©es`);
        }
        
        console.log(`‚úÖ ${annotations.length} annotations charg√©es pour la page ${pageNum}:`, annotations);
    } else {
        annotations = [];
        console.log(`üìÑ Aucune annotation trouv√©e pour la page ${pageNum} - page vierge`);
    }
    
    // Charger l'historique d'annulation
    if (undoHistoryByPage[pageNum]) {
        undoHistory = [...undoHistoryByPage[pageNum]];
    } else {
        undoHistory = [];
    }
    
    // Redessiner les annotations sur le canvas (forc√©)
    console.log(`üé® === REDESSINAGE FORC√â ===`);
    console.log(`üìÑ Page: ${pageNum}, annotations √† dessiner: ${annotations.length}`);
    console.log(`üñºÔ∏è Canvas ready: ${!!annotationCtx}`);
    
    if (annotationCtx) {
        console.log('üîÑ Appel de redrawAnnotations() depuis loadPageAnnotations...');
        redrawAnnotations();
        console.log('‚úÖ redrawAnnotations() termin√©');
    } else {
        console.warn('‚ö†Ô∏è annotationCtx non disponible pour redessiner - report en attente du canvas');
        
        // Reporter le redessinage quand le canvas sera pr√™t
        const waitForCanvas = () => {
            if (annotationCtx) {
                console.log('üé® Canvas maintenant disponible - redessinage forc√© des annotations charg√©es');
                redrawAnnotations(true); // Force le redessinage m√™me si isDrawing = true
            } else {
                setTimeout(waitForCanvas, 100);
            }
        };
        waitForCanvas();
    }
    
    console.log(`üèÅ === FIN LOAD PAGE ANNOTATIONS ===`);
}

// Obtenir toutes les annotations de toutes les pages pour la sauvegarde
function getAllAnnotations() {
    // D'abord sauvegarder la page actuelle
    saveCurrentPageAnnotations();
    
    // Retourner toutes les annotations organis√©es par page
    return annotationsByPage;
}

// Charger toutes les annotations depuis les donn√©es sauvegard√©es
function loadAllAnnotations(savedAnnotations) {
    console.log('üìÑ Chargement de toutes les annotations:', savedAnnotations);
    
    if (savedAnnotations && typeof savedAnnotations === 'object' && !Array.isArray(savedAnnotations)) {
        // Nouveau format par page
        annotationsByPage = savedAnnotations;
        console.log(`üìÑ ${Object.keys(annotationsByPage).length} pages avec annotations trouv√©es`);
        
        // Charger les annotations de la page actuelle
        loadPageAnnotations(currentPageNum);
        
        // Forcer un redessinage imm√©diat des annotations sur la page courante
        setTimeout(() => {
            if (annotations.length > 0) {
                console.log(`üé® REDRAW INITIAL - Redessinage des annotations charg√©es (${annotations.length}) sur page ${currentPageNum}`);
                redrawAnnotations(true);
            }
        }, 100);
    } else if (Array.isArray(savedAnnotations)) {
        // Ancien format (compatibility) - toutes les annotations sur la page 1
        console.log('üìÑ Format legacy d√©tect√© - migration vers format par page');
        annotationsByPage = {};
        if (savedAnnotations.length > 0) {
            annotationsByPage[1] = savedAnnotations;
        }
        loadPageAnnotations(currentPageNum);
        
        // Forcer un redessinage imm√©diat des annotations sur la page courante
        setTimeout(() => {
            if (annotations.length > 0) {
                console.log(`üé® REDRAW INITIAL (legacy) - Redessinage des annotations charg√©es (${annotations.length}) sur page ${currentPageNum}`);
                redrawAnnotations(true);
            }
        }, 100);
    } else {
        // Aucune annotation ou format non reconnu
        console.log('üìÑ Aucune annotation ou format non reconnu - d√©marrage vierge');
        annotationsByPage = {};
        annotations = [];
        undoHistory = [];
        // S'assurer que le canvas est nettoy√©
        if (annotationCtx) {
            redrawAnnotations();
        }
    }
    
    console.log(`üìÑ Fin du chargement - page actuelle ${currentPageNum} avec ${annotations.length} annotations`);
}

// Fonction scheduleAutoSave supprim√©e - sauvegarde uniquement √† la fermeture

// Sauvegarder les annotations (appel√© uniquement √† la fermeture)
async function saveAnnotations() {
    if (!currentFileId) return;
    
    // Indicateur visuel
    const saveStatus = document.getElementById('saveStatus');
    if (saveStatus) {
        saveStatus.className = 'save-status saving';
        saveStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...';
    }
    
    try {
        // Utiliser le nouveau syst√®me : obtenir toutes les annotations de toutes les pages
        const allAnnotations = getAllAnnotations();
        
        console.log('üíæ Sauvegarde de toutes les annotations:', allAnnotations);
        
        const response = await fetch('/planning/save_file_annotations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                file_id: currentFileId,
                annotations: allAnnotations // Maintenant c'est un objet avec les pages
            })
        });
        
        const result = await response.json();
        const saveStatus = document.getElementById('saveStatus');
        
        if (result.success) {
            if (saveStatus) {
                saveStatus.className = 'save-status';
                saveStatus.innerHTML = '<i class="fas fa-check"></i> Annotations sauvegard√©es';
            }
            console.log('üíæ Annotations sauvegard√©es avec succ√®s pour toutes les pages');
        } else {
            if (saveStatus) {
                saveStatus.className = 'save-status error';
                saveStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Erreur de sauvegarde';
            }
            console.error('Erreur de sauvegarde:', result.message);
        }
    } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        if (saveStatus) {
            saveStatus.className = 'save-status error';
            saveStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Erreur de connexion';
        }
    }
}

// Afficher une erreur
function showError(message) {
    const container = document.getElementById('viewerContainer');
    container.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: #FC8181;">
            <i class="fas fa-exclamation-triangle fa-2x"></i>
            <p>${message}</p>
            <button onclick="closeFileViewer()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #4F46E5; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">
                Fermer
            </button>
        </div>
    `;
}

// Charger le contenu du fichier
async function loadFileContent(fileId, fileType, container) {
    container.innerHTML = '<div style="text-align: center; padding: 2rem;"><i class="fas fa-spinner fa-spin fa-2x"></i><p>Chargement...</p></div>';
    
    console.log('Chargement du fichier:', {fileId, fileType});
    
    try {
        if (fileType.toLowerCase() === 'pdf') {
            await loadPDF(fileId, container);
        } else if (['png', 'jpg', 'jpeg'].includes(fileType.toLowerCase())) {
            await loadImage(fileId, container);
        }
        console.log('Fichier charg√© avec succ√®s');
    } catch (error) {
        console.error('Erreur d√©taill√©e lors du chargement:', error);
        container.innerHTML = `
            <div style="color: #FC8181; text-align: center; padding: 2rem;">
                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                <h3>Erreur lors du chargement du fichier</h3>
                <p style="margin-top: 1rem; font-size: 0.9rem;">${error.message}</p>
                <button onclick="closeFileViewer()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #4F46E5; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">
                    Fermer
                </button>
            </div>
        `;
    }
}


// Charger une image
async function loadImage(fileId, container) {
    try {
        const img = document.createElement('img');
        img.src = `/file_manager/serve_file/${fileId}`;
        
        // Ajouter un timeout pour √©viter l'attente infinie
        const loadTimeout = setTimeout(() => {
            throw new Error('Timeout: L\'image prend trop de temps √† charger');
        }, 10000);
        
        img.onload = () => {
            clearTimeout(loadTimeout);
            
            // Cr√©er le conteneur
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            
            // Ajuster la taille de l'image pour qu'elle s'adapte √† l'√©cran
            const maxWidth = window.innerWidth * 0.8;
            const maxHeight = window.innerHeight * 0.6;
            
            let { width, height } = img;
            
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }
            
            img.style.width = width + 'px';
            img.style.height = height + 'px';
            
            imageContainer.appendChild(img);
            
            // Cr√©er le canvas d'annotation
            canvas = document.createElement('canvas');
            canvas.className = 'annotation-canvas';
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx = canvas.getContext('2d');
            
            imageContainer.appendChild(canvas);
            container.innerHTML = '';
            container.appendChild(imageContainer);
        };
        
        img.onerror = () => {
            clearTimeout(loadTimeout);
            throw new Error('Impossible de charger l\'image');
        };
        
    } catch (error) {
        console.error('Erreur lors du chargement de l\'image:', error);
        throw error;
    }
}

// Fonction loadAnnotations dupliqu√©e supprim√©e - utiliser celle d√©finie plus haut avec le syst√®me par page

// Code orphelin supprim√© - d√©j√† g√©r√© dans setupToolEvents()

// Fonctions de dessin supprim√©es - dupliqu√©es avec celles qui utilisent annotationCanvas

// Fonctions dupliqu√©es supprim√©es - d√©j√† d√©finies plus haut dans le fichier

// Fonction saveAnnotations dupliqu√©e supprim√©e - d√©j√† d√©finie plus haut

// Fermer le viewer am√©lior√©
async function closeFileViewer() {
    try {
        console.log('üîÑ Fermeture du viewer - d√©but');

        // IMPORTANT: Si cleanPDFViewer existe, utiliser son syst√®me de fermeture
        if (typeof cleanPDFViewer !== 'undefined' && cleanPDFViewer) {
            console.log('  üì¶ Utilisation du nouveau lecteur PDF Clean pour la fermeture');

            // Le viewer g√®re automatiquement la fermeture via son callback onClose
            try {
                await cleanPDFViewer.close();
                console.log('  ‚úÖ Lecteur PDF Clean ferm√© avec succ√®s');
            } catch (error) {
                console.error('  ‚ùå Erreur lors de la fermeture:', error);
            }

            return;
        }

        // ANCIEN SYST√àME (fallback si pas de unifiedPDFViewer)
        console.log('  üìÑ Utilisation de l\'ancien syst√®me de fermeture');

        // Si on est en vue split, fermer toute la vue split
        if (isSplitViewActive) {
            closeSplitView();
            return;
        }

        // Sauvegarder les annotations de la page actuelle avant de fermer
        console.log('üìÑ Fermeture du viewer - sauvegarde des annotations de la page actuelle...');
        saveCurrentPageAnnotations();

        // Sauvegarder toutes les annotations
        if (Object.keys(annotationsByPage).length > 0 || annotations.length > 0) {
            saveAnnotations();
        }

        const modal = document.getElementById('fileViewerModal');
        if (modal) {
            modal.classList.remove('show');
        }

        // Nettoyer les variables
        currentFileId = null;
        annotations = [];
        annotationsByPage = {}; // Nettoyer les annotations par page
        undoHistoryByPage = {}; // Nettoyer l'historique par page
        pdfDoc = null;
        currentPageNum = 1;
        currentScale = 1.0;
        pdfCanvas = null;
        pdfCtx = null;
        annotationCanvas = null;
        annotationCtx = null;

        if (saveTimeout) {
            clearTimeout(saveTimeout);
            saveTimeout = null;
        }

        // Masquer la barre lat√©rale
        document.getElementById('pageSidebar').classList.remove('show');

    } catch (error) {
        console.error('‚ùå Erreur lors de la fermeture:', error);
        const modal = document.getElementById('fileViewerModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }
}

// Fonctions pour la vue c√¥te-√†-c√¥te (split view)
async function openSplitView(fileId, filename, fileType) {
    isSplitViewActive = true;
    
    // Copier le formulaire de planification dans la vue split
    const planningEdit = document.getElementById('planningEdit');
    const splitViewPlanningEdit = document.getElementById('splitViewPlanningEdit');
    splitViewPlanningEdit.innerHTML = planningEdit.innerHTML;
    
    // Copier les valeurs actuelles
    const originalTitle = document.getElementById('planningTitle').value;
    const originalDescription = document.getElementById('planningDescription').value;
    
    setTimeout(() => {
        const splitTitle = splitViewPlanningEdit.querySelector('#planningTitle');
        const splitDescription = splitViewPlanningEdit.querySelector('#planningDescription');
        if (splitTitle) splitTitle.value = originalTitle;
        if (splitDescription) splitDescription.value = originalDescription;
        
        // Attacher les √©v√©nements au nouveau formulaire
        const splitForm = splitViewPlanningEdit.querySelector('#planningForm');
        if (splitForm) {
            splitForm.onsubmit = function(e) {
                e.preventDefault();
                savePlanningFromSplitView();
            };
        }
    }, 100);
    
    // Afficher la vue split
    const splitContainer = document.getElementById('splitViewContainer');
    splitContainer.classList.add('active');
    
    // Masquer le contenu normal
    document.querySelector('.lesson-container').style.display = 'none';
    
    // Int√©grer le viewer PDF dans la partie droite
    const modal = document.getElementById('fileViewerModal');
    const splitViewRight = document.getElementById('splitViewRight');
    
    modal.classList.add('embedded');
    splitViewRight.appendChild(modal);
    modal.classList.add('show');
    
    // Initialiser les canvas
    initializeCanvases();
    
    // Charger le fichier
    try {
        if (fileType.toLowerCase() === 'pdf') {
            await loadPDF(fileId);
            await loadAnnotations(fileId);
        } else if (['png', 'jpg', 'jpeg'].includes(fileType.toLowerCase())) {
            await loadImage(fileId);
            await loadAnnotations(fileId);
        }
        
        setupAnnotationTools();
        
    } catch (error) {
        console.error('Erreur lors du chargement du fichier:', error);
        showError('Erreur lors du chargement du fichier');
    }
}

function closeSplitView() {
    // Synchroniser les valeurs de retour
    const splitTitle = document.querySelector('#splitViewPlanningEdit #planningTitle');
    const splitDescription = document.querySelector('#splitViewPlanningEdit #planningDescription');
    const originalTitle = document.getElementById('planningTitle');
    const originalDescription = document.getElementById('planningDescription');
    
    if (splitTitle && originalTitle) {
        originalTitle.value = splitTitle.value;
    }
    if (splitDescription && originalDescription) {
        originalDescription.value = splitDescription.value;
    }
    
    // Sauvegarder les annotations avant de fermer
    if (currentFileId && (Object.keys(annotationsByPage).length > 0 || annotations.length > 0)) {
        saveCurrentPageAnnotations();
        saveAnnotations();
    }
    
    // Fermer le viewer PDF sans rappeler closeSplitView
    const modal = document.getElementById('fileViewerModal');
    if (modal) {
        modal.classList.remove('show');
        modal.classList.remove('embedded');
        document.body.appendChild(modal);
    }
    
    // Nettoyer les variables du viewer
    currentFileId = null;
    annotations = [];
    annotationsByPage = {};
    undoHistoryByPage = {};
    pdfDoc = null;
    currentPageNum = 1;
    currentScale = 1.0;
    
    // Masquer la vue split
    const splitContainer = document.getElementById('splitViewContainer');
    splitContainer.classList.remove('active');
    
    // R√©afficher le contenu normal
    document.querySelector('.lesson-container').style.display = '';
    
    // R√©initialiser le flag
    isSplitViewActive = false;
}

async function savePlanningFromSplitView() {
    const splitTitle = document.querySelector('#splitViewPlanningEdit #planningTitle');
    const splitDescription = document.querySelector('#splitViewPlanningEdit #planningDescription');
    
    if (!splitTitle || !splitDescription) return;
    
    showSavingIndicator(true);
    
    try {
        const response = await fetch('/planning/save-lesson-planning', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                date: lessonDate,
                period_number: periodNumber,
                classroom_id: classroomId,
                title: splitTitle.value,
                description: splitDescription.value,
                checklist_states: checklistStates
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            showSuccess('Planification enregistr√©e');
            
            // Synchroniser avec le formulaire original
            const originalTitle = document.getElementById('planningTitle');
            const originalDescription = document.getElementById('planningDescription');
            if (originalTitle) originalTitle.value = splitTitle.value;
            if (originalDescription) originalDescription.value = splitDescription.value;
            
            // Mettre √† jour l'affichage si n√©cessaire
            updatePlanningDisplay();
        } else {
            showError(data.message || 'Erreur lors de la sauvegarde');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showError('Erreur lors de la sauvegarde');
    } finally {
        showSavingIndicator(false);
    }
}

// √âv√©nements globaux am√©lior√©s
document.addEventListener('keydown', (e) => {
    const modal = document.getElementById('fileViewerModal');
    if (!modal.classList.contains('show')) return;
    
    if (e.key === 'Escape') {
        closeFileViewer();
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        previousPage();
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        nextPage();
    // Raccourcis zoom supprim√©s
    }
});

document.addEventListener('click', (e) => {
    const modal = document.getElementById('fileViewerModal');
    if (e.target === modal && modal.classList.contains('show')) {
        closeFileViewer();
    }
});

// Fonctions pour la gestion des onglets de suivi
function showTrackingTab(tabName) {
    // D√©sactiver tous les onglets
    document.querySelectorAll('.tracking-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Masquer tous les contenus
    document.querySelectorAll('.tracking-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Activer l'onglet cliqu√©
    event.target.closest('.tracking-tab').classList.add('active');
    
    // Afficher le contenu correspondant
    document.getElementById(tabName + '-content').classList.add('active');
    
    // Si c'est l'onglet plan de classe, charger le plan et ajuster l'√©chelle
    if (tabName === 'seating-plan') {
        setTimeout(() => {
            loadSeatingPlan();
            // Ajustement suppl√©mentaire pour s'assurer que l'√©chelle est correcte
            setTimeout(() => {
                adjustSeatingScale();
            }, 150);
        }, 100);
    }
}

// Fonctions pour l'initialisation du syst√®me de sanctions
function initializeSanctionSystem() {
    // Stocker les compteurs initiaux au d√©but de la p√©riode
    document.querySelectorAll('.count-display').forEach(element => {
        const studentId = element.getAttribute('data-student');
        const sanctionId = element.getAttribute('data-sanction');
        const count = parseInt(element.textContent) || 0;
        initialSanctionCounts[`${studentId}_${sanctionId}`] = count;
    });
    
    // D√©marrer la surveillance uniquement si on est en cours actuel
    {% if is_current and remaining_seconds > 0 %}
    startSanctionMonitoring();
    {% endif %}
}

function startSanctionMonitoring() {
    // V√©rifier 3 minutes avant la fin
    const timeToNotification = {{ remaining_seconds * 1000 }} - NOTIFICATION_TIME_BEFORE_END;
    
    if (timeToNotification > 0) {
        sanctionCheckTimer = setTimeout(() => {
            checkForSanctionThresholds();
        }, timeToNotification);
        
        console.log(`Surveillance des sanctions activ√©e. V√©rification dans ${Math.round(timeToNotification / 1000)} secondes.`);
    } else if ({{ remaining_seconds * 1000 }} > 0) {
        // Si il reste moins de 3 minutes, v√©rifier imm√©diatement
        checkForSanctionThresholds();
    }
}

async function checkForSanctionThresholds() {
    if (sanctionNotificationShown) return; // √âviter les notifications multiples
    
    try {
        const response = await fetch('{{ url_for("planning.check_sanction_thresholds") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                classroom_id: classroomId,
                initial_counts: initialSanctionCounts
            })
        });
        
        const result = await response.json();
        
        if (result.success && result.threshold_breaches.length > 0) {
            sanctionNotificationShown = true;
            await showSanctionNotification(result.threshold_breaches);
        }
    } catch (error) {
        console.error('Erreur lors de la v√©rification des seuils:', error);
    }
}

async function showSanctionNotification(breaches) {
    // Cr√©er la notification en haut de la page
    const notification = document.createElement('div');
    notification.className = 'sanction-notification';
    notification.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #FEF3C7 0%, #F59E0B 100%);
        color: #92400E;
        padding: 1rem;
        z-index: 1000;
        border-bottom: 3px solid #F59E0B;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideDown 0.5s ease;
    `;
    
    let notificationHTML = `
        <div style="max-width: 1200px; margin: 0 auto;">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                <i class="fas fa-exclamation-triangle" style="font-size: 1.5rem;"></i>
                <h3 style="margin: 0; font-size: 1.25rem; font-weight: bold;">
                    üéØ Sanctions √† attribuer - Demandez aux √©l√®ves d'apporter leur agenda
                </h3>
                <button onclick="closeSanctionNotification()" style="margin-left: auto; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #92400E;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div style="font-size: 0.95rem; line-height: 1.5;">
    `;
    
    // Traiter chaque seuil franchi
    for (const breach of breaches) {
        let dateInfo = '';
        if (breach.min_days_deadline) {
            try {
                // Calculer la prochaine date de cours
                const dateResponse = await fetch('{{ url_for("planning.calculate_next_lesson_date") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({
                        classroom_id: classroomId,
                        min_days: breach.min_days_deadline,
                        current_date: lessonDate
                    })
                });
                
                const dateResult = await dateResponse.json();
                if (dateResult.success && dateResult.next_date) {
                    dateInfo = ` - <strong>√Ä rendre le ${dateResult.formatted_date}</strong>`;
                    
                    // Ajouter √† la planification
                    await fetch('{{ url_for("planning.add_sanction_to_planning") }}', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            date: dateResult.next_date,
                            period_number: dateResult.period_number,
                            classroom_id: classroomId,
                            student_name: breach.student_name,
                            sanction_text: breach.sanction_text
                        })
                    });
                } else {
                    dateInfo = ' - <em>Date √† d√©terminer</em>';
                }
            } catch (error) {
                console.error('Erreur calcul date:', error);
                dateInfo = ' - <em>Date √† d√©terminer</em>';
            }
        }
        
        notificationHTML += `
            <div style="background: rgba(255, 255, 255, 0.3); padding: 0.75rem; margin: 0.5rem 0; border-radius: 0.5rem; border-left: 4px solid #F59E0B;">
                <strong>${breach.student_name}</strong> - ${breach.sanction_template} (${breach.threshold} coches) : 
                <strong>${breach.sanction_text}</strong>${dateInfo}
            </div>
        `;
    }
    
    notificationHTML += `
            </div>
        </div>
    `;
    
    notification.innerHTML = notificationHTML;
    document.body.appendChild(notification);
    
    // Ajouter le CSS pour l'animation
    if (!document.getElementById('sanction-notification-styles')) {
        const style = document.createElement('style');
        style.id = 'sanction-notification-styles';
        style.textContent = `
            @keyframes slideDown {
                from {
                    transform: translateY(-100%);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }
            @keyframes slideUp {
                from {
                    transform: translateY(0);
                    opacity: 1;
                }
                to {
                    transform: translateY(-100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // D√©caler le contenu principal vers le bas
    document.body.style.paddingTop = notification.offsetHeight + 'px';
}

function closeSanctionNotification() {
    const notification = document.querySelector('.sanction-notification');
    if (notification) {
        notification.style.animation = 'slideUp 0.5s ease';
        setTimeout(() => {
            notification.remove();
            document.body.style.paddingTop = '0';
        }, 500);
    }
}

// Fonctions pour la gestion des sanctions
async function updateSanctionCount(studentId, sanctionId, delta) {
    const countElement = document.querySelector(`[data-student="${studentId}"][data-sanction="${sanctionId}"]`);
    const currentCount = parseInt(countElement.textContent);
    const newCount = Math.max(0, currentCount + delta); // Ne pas aller en dessous de 0
    
    try {
        const response = await fetch('{{ url_for("planning.update_sanction_count") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                student_id: studentId,
                template_id: sanctionId,
                count: newCount
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            countElement.textContent = result.new_count;
            
            // Mettre √† jour les classes CSS selon le nombre
            countElement.className = 'count-display';
            if (result.new_count >= 6) {
                countElement.classList.add('danger');
            } else if (result.new_count >= 3) {
                countElement.classList.add('warning');
            }
            
            // Animation de mise √† jour
            countElement.style.transform = 'scale(1.2)';
            setTimeout(() => {
                countElement.style.transform = 'scale(1)';
            }, 200);
        } else {
            alert(result.message || 'Erreur lors de la mise √† jour');
        }
    } catch (error) {
        console.error('Erreur:', error);
        alert('Erreur lors de la communication avec le serveur');
    }
}

// Initialiser les classes CSS des compteurs au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Appliquer les classes CSS aux compteurs selon leur valeur
    document.querySelectorAll('.count-display').forEach(element => {
        const count = parseInt(element.textContent);
        if (count >= 6) {
            element.classList.add('danger');
        } else if (count >= 3) {
            element.classList.add('warning');
        }
    });
    
    // Initialiser le syst√®me de surveillance des sanctions
    initializeSanctionSystem();
    
    // Gestionnaire de redimensionnement pour le plan de classe
    {% if seating_plan %}
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const seatingContent = document.getElementById('seating-plan-content');
            if (seatingContent && seatingContent.classList.contains('active')) {
                adjustSeatingScale();
            }
        }, 250);
    });
    {% endif %}
});

// Fonction pour afficher des infos debug dans le panneau
function updateDebugPanel(message) {
    const debugPanel = document.getElementById('js-debug-info');
    if (debugPanel) {
        debugPanel.innerHTML += '<div>' + message + '</div>';
    }
}

// Variables globales pour le syst√®me d'avertissements et l'historique
let warningHistory = []; // Historique des changements pour le bouton "annuler"
let currentWarnings = {}; // √âtat actuel des avertissements {elementId_slotIndex: warningLevel}

// Fonction pour sauvegarder l'√©tat dans l'historique
function saveToHistory() {
    warningHistory.push(JSON.parse(JSON.stringify(currentWarnings)));
    if (warningHistory.length > 50) { // Limiter l'historique √† 50 actions
        warningHistory.shift();
    }
    updateUndoButton();
}

// Fonction pour annuler le dernier changement
function undoLastWarning() {
    if (warningHistory.length > 1) {
        warningHistory.pop(); // Enlever l'√©tat actuel
        currentWarnings = JSON.parse(JSON.stringify(warningHistory[warningHistory.length - 1]));
        applyWarningStates();
        updateUndoButton();
    } else if (warningHistory.length === 1) {
        warningHistory.pop();
        currentWarnings = {};
        applyWarningStates();
        updateUndoButton();
    }
}

// Fonction pour appliquer les √©tats d'avertissement visuellement
function applyWarningStates() {
    // R√©initialiser tous les slots
    document.querySelectorAll('.student-slot').forEach(slot => {
        slot.classList.remove('warning-1', 'warning-2', 'warning-3');
    });
    
    // Appliquer les √©tats actuels
    Object.keys(currentWarnings).forEach(key => {
        const [elementId, slotIndex] = key.split('_');
        const element = document.querySelector(`[data-element-id="${elementId}"]`);
        if (element) {
            const slots = element.querySelectorAll('.student-slot');
            const slot = slots[parseInt(slotIndex)];
            if (slot && currentWarnings[key] > 0) {
                slot.classList.add(`warning-${currentWarnings[key]}`);
            }
        }
    });
}

// Fonction pour mettre √† jour l'√©tat du bouton annuler
function updateUndoButton() {
    const undoBtn = document.getElementById('undo-warning-btn');
    if (undoBtn) {
        undoBtn.disabled = warningHistory.length === 0;
    }
}

// Fonction pour charger et afficher le plan de classe
// Fonction utilitaire pour formater le nom des √©tudiants (Pr√©nom + premi√®re lettre du nom)
function formatStudentName(fullName) {
    const parts = fullName.trim().split(' ');
    if (parts.length === 1) {
        return parts[0]; // Si qu'un seul nom, le retourner tel quel
    }
    
    const firstName = parts[0];
    const lastNameInitial = parts[parts.length - 1].charAt(0).toUpperCase();
    return `${firstName} ${lastNameInitial}.`;
}

function loadSeatingPlan() {
    console.log('=== DEBUG loadSeatingPlan called ===');
    console.log('seating_plan available:', {{ 'true' if seating_plan else 'false' }});
    {% if seating_plan %}
    console.log('seating_plan data:', {{ seating_plan | tojson | safe }});
    console.log('Chargement du plan de classe...');
    
    const workspace = document.getElementById('seating-workspace');
    const viewer = document.getElementById('seating-plan-viewer');
    
    if (!workspace || !viewer) {
        console.error('Workspace ou viewer non trouv√©');
        return;
    }
    
    // Nettoyer le workspace
    workspace.innerHTML = '';
    workspace.style.transform = 'none';
    
    // R√©cup√©rer les donn√©es du plan
    const planData = {{ seating_plan.plan_data | tojson | safe }};
    console.log('Donn√©es du plan:', planData);
    
    const elements = planData.elements || [];
    const studentsPlacement = planData.students_placement || [];
    
    // Cr√©er les √©l√©ments du plan
    elements.forEach((elementData) => {
        const element = createSeatingElement(elementData);
        if (element) {
            element.style.left = elementData.x + 'px';
            element.style.top = elementData.y + 'px';
            workspace.appendChild(element);
        }
    });
    
    // Les donn√©es des √©tudiants sont d√©j√† d√©finies globalement
    // studentsData est disponible pour tous les scripts
    
    // Placer les √©tudiants
    studentsPlacement.forEach((placement) => {
        const element = workspace.querySelector(`[data-element-id="${placement.element_id}"]`);
        if (element) {
            const slots = element.querySelectorAll('.student-slot');
            if (slots[placement.slot_index]) {
                const slot = slots[placement.slot_index];
                
                // D'abord essayer de trouver l'√©tudiant par ID (priorit√© absolue)
                let student = studentsData.find(s => 
                    s.id === placement.student_id || String(s.id) === String(placement.student_id)
                );
                
                // Si pas trouv√© par ID et qu'on a un nom dans le placement, essayer plusieurs strat√©gies
                if (!student && placement.student_name) {
                    // Strat√©gie 1: nom complet exact
                    student = studentsData.find(s => s.full_name === placement.student_name);
                    
                    if (!student) {
                        // Strat√©gie 2: pr√©nom + nom de famille
                        student = studentsData.find(s => 
                            (s.first_name + ' ' + (s.last_name || '')).trim() === placement.student_name
                        );
                    }
                    
                    if (!student) {
                        // Strat√©gie 3: nom abr√©g√© vers nom complet (nouveau format vers ancien)
                        student = studentsData.find(s => {
                            const formattedName = formatStudentName(s.full_name);
                            return formattedName === placement.student_name;
                        });
                    }
                    
                    console.log(`DEBUG lesson_view: Student ${placement.student_id} not found by ID, trying by name "${placement.student_name}": ${student ? 'found' : 'not found'}`);
                }
                
                console.log(`DEBUG lesson_view: Placement student_id=${placement.student_id}, Found student:`, student);
                console.log(`DEBUG lesson_view: Placement data:`, placement);
                console.log(`DEBUG lesson_view: Available students:`, studentsData);
                
                if (student) {
                    // Utiliser le format abr√©g√© pour l'affichage
                    const displayName = formatStudentName(student.full_name);
                    slot.innerHTML = `<div class="student-placed" draggable="true" data-student-id="${student.id}">${displayName}</div>`;
                    slot.classList.add('occupied');
                    slot.dataset.studentId = student.id;
                    console.log(`DEBUG lesson_view: Placed student ${displayName} (${student.full_name}) in slot`);
                } else {
                    // Si l'√©tudiant n'est pas trouv√©, laisser le slot vide
                    console.log(`DEBUG lesson_view: Student ${placement.student_id} (${placement.student_name || 'nom non disponible'}) not found, leaving slot empty`);
                    console.log(`DEBUG lesson_view: Available students:`, studentsData.map(s => ({id: s.id, name: s.full_name})));
                }
            }
        }
    });
    
    // Ajuster l'√©chelle apr√®s le chargement
    setTimeout(() => {
        adjustSeatingScale();
    }, 200);

    // Initialiser l'√©tat du syst√®me d'avertissements
    currentWarnings = {};
    warningHistory = [];
    updateUndoButton();

    // Initialiser le drag-and-drop pour √©changer les places
    initializeDragAndDrop();
    
    // Observer les changements de taille du conteneur
    if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target.id === 'seating-plan-viewer') {
                    console.log('Plan de classe viewer redimensionn√©, ajustement de l\'√©chelle');
                    adjustSeatingScale();
                }
            }
        });
        
        const viewer = document.getElementById('seating-plan-viewer');
        if (viewer) {
            resizeObserver.observe(viewer);
        }
    }
    
    {% else %}
    console.log('Aucun plan de classe disponible pour cette classe');
    console.log('lesson_classroom info:', '{{ lesson_classroom.name if lesson_classroom else "No classroom" }}');
    {% endif %}
}

// Fonction pour cr√©er un √©l√©ment du plan
function createSeatingElement(elementData) {
    const element = document.createElement('div');
    element.className = 'seating-element';
    element.dataset.elementId = elementData.id;
    element.style.position = 'absolute';
    
    if (elementData.type === 'desk-single') {
        element.className += ' desk-single';
        element.style.minWidth = '80px';
        element.style.width = 'auto';
        element.style.height = '60px';
        element.innerHTML = '<div class="student-slots"><div class="student-slot"></div></div>';
        
        // Ajouter les √©v√©nements de clic pour les tables d'√©l√®ves
        const slot = element.querySelector('.student-slot');
        if (slot) {
            slot.addEventListener('click', function(e) {
                e.stopPropagation();
                handleSlotClick(elementData.id, 0);
            });
            slot.style.cursor = 'pointer';
        }
    } else if (elementData.type === 'desk-double') {
        element.className += ' desk-double';
        element.style.minWidth = '140px';
        element.style.width = 'auto';
        element.style.height = '60px';
        element.innerHTML = '<div class="student-slots"><div class="student-slot"></div><div class="student-slot"></div></div>';
        
        // Ajouter les √©v√©nements de clic pour les tables doubles
        const slots = element.querySelectorAll('.student-slot');
        slots.forEach((slot, index) => {
            slot.addEventListener('click', function(e) {
                e.stopPropagation();
                handleSlotClick(elementData.id, index);
            });
            slot.style.cursor = 'pointer';
        });
    } else if (elementData.type === 'teacher-desk') {
        element.className += ' teacher-desk';
        element.style.width = '120px';
        element.style.height = '80px';
        element.innerHTML = 'Bureau du professeur';
    }
    
    return element;
}

// Fonction pour g√©rer les clics sur les slots d'√©l√®ves
function handleSlotClick(elementId, slotIndex) {
    const key = `${elementId}_${slotIndex}`;
    
    // Cycles d'avertissement : 0 (normal) -> 1 (jaune) -> 2 (rouge) -> 3 (noir) -> 0 (normal)
    const currentLevel = currentWarnings[key] || 0;
    const nextLevel = (currentLevel + 1) % 4;
    
    if (nextLevel === 0) {
        delete currentWarnings[key];
    } else {
        currentWarnings[key] = nextLevel;
    }
    
    // Sauvegarder l'√©tat actuel dans l'historique APR√àS la modification
    saveToHistory();
    
    // Appliquer visuellement les changements
    applyWarningStates();
    
    console.log(`Slot cliqu√©: ${elementId}, index: ${slotIndex}, niveau: ${nextLevel}`);
}

// Variables pour le drag-and-drop
let draggedStudent = null;
let sourceSlot = null;

// Fonction pour initialiser le drag-and-drop
function initializeDragAndDrop() {
    const workspace = document.getElementById('seating-workspace');
    if (!workspace) return;

    // Ajouter les √©v√©nements √† tous les slots (occup√©s et vides)
    const allSlots = workspace.querySelectorAll('.student-slot');
    allSlots.forEach(slot => {
        // Activer drag si le slot est occup√©
        if (slot.classList.contains('occupied')) {
            enableDragOnSlot(slot);
        }
        // Activer drop sur tous les slots
        enableDropOnSlot(slot);
    });
}

// Activer le drag sur un slot occup√©
function enableDragOnSlot(slot) {
    const studentElement = slot.querySelector('.student-placed');
    if (!studentElement) return;

    studentElement.addEventListener('dragstart', function(e) {
        draggedStudent = {
            id: this.dataset.studentId,
            name: this.textContent
        };
        sourceSlot = slot;
        this.style.opacity = '0.4';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
        console.log('Drag started:', draggedStudent);
    });

    studentElement.addEventListener('dragend', function(e) {
        this.style.opacity = '1';
        // Retirer les classes de survol
        document.querySelectorAll('.student-slot').forEach(s => {
            s.classList.remove('drag-over');
        });
    });
}

// Activer le drop sur un slot (occup√© ou vide)
function enableDropOnSlot(slot) {
    slot.addEventListener('dragover', function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';
        this.classList.add('drag-over');
        return false;
    });

    slot.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over');
    });

    slot.addEventListener('drop', function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        this.classList.remove('drag-over');

        if (!draggedStudent || !sourceSlot) return false;

        const targetSlot = this;

        // Si on drop sur le slot source, ne rien faire
        if (targetSlot === sourceSlot) {
            return false;
        }

        // Cas 1: Drop sur un slot vide - d√©placer l'√©tudiant
        if (!targetSlot.classList.contains('occupied')) {
            moveStudent(sourceSlot, targetSlot);
        }
        // Cas 2: Drop sur un slot occup√© - √©changer les √©tudiants
        else {
            swapStudents(sourceSlot, targetSlot);
        }

        // R√©initialiser
        draggedStudent = null;
        sourceSlot = null;

        return false;
    });
}

// D√©placer un √©tudiant vers un slot vide
function moveStudent(fromSlot, toSlot) {
    const studentElement = fromSlot.querySelector('.student-placed');
    if (!studentElement) return;

    const studentId = fromSlot.dataset.studentId;
    const studentName = studentElement.textContent;

    // D√©placer l'√©l√©ment
    toSlot.innerHTML = fromSlot.innerHTML;
    toSlot.classList.add('occupied');
    toSlot.dataset.studentId = studentId;

    // Vider le slot source
    fromSlot.innerHTML = '';
    fromSlot.classList.remove('occupied');
    delete fromSlot.dataset.studentId;

    // R√©activer les √©v√©nements
    enableDragOnSlot(toSlot);
    enableDropOnSlot(fromSlot);

    console.log(`D√©plac√© ${studentName} vers un slot vide`);

    // Sauvegarder les changements
    saveSeatingChanges();
}

// √âchanger deux √©tudiants
function swapStudents(slot1, slot2) {
    const student1Element = slot1.querySelector('.student-placed');
    const student2Element = slot2.querySelector('.student-placed');

    if (!student1Element || !student2Element) return;

    const student1Id = slot1.dataset.studentId;
    const student2Id = slot2.dataset.studentId;
    const student1HTML = slot1.innerHTML;
    const student2HTML = slot2.innerHTML;

    // √âchanger les contenus
    slot1.innerHTML = student2HTML;
    slot1.dataset.studentId = student2Id;

    slot2.innerHTML = student1HTML;
    slot2.dataset.studentId = student1Id;

    // R√©activer les √©v√©nements sur les deux slots
    enableDragOnSlot(slot1);
    enableDragOnSlot(slot2);
    enableDropOnSlot(slot1);
    enableDropOnSlot(slot2);

    console.log(`√âchang√© ${student1Element.textContent} avec ${student2Element.textContent}`);

    // Sauvegarder les changements
    saveSeatingChanges();
}

// Sauvegarder les changements du plan de classe
function saveSeatingChanges() {
    const workspace = document.getElementById('seating-workspace');
    if (!workspace) return;

    // Construire les donn√©es du plan
    const elements = [];
    const studentsPlacement = [];

    // R√©cup√©rer tous les √©l√©ments (tables, bureau prof, etc.)
    workspace.querySelectorAll('.seating-element').forEach(element => {
        const elementId = element.dataset.elementId;
        const x = parseFloat(element.style.left) || 0;
        const y = parseFloat(element.style.top) || 0;

        let type = 'desk-single';
        if (element.classList.contains('desk-double')) type = 'desk-double';
        if (element.classList.contains('teacher-desk')) type = 'teacher-desk';

        elements.push({
            id: elementId,
            type: type,
            x: x,
            y: y
        });

        // R√©cup√©rer les placements d'√©tudiants
        const slots = element.querySelectorAll('.student-slot');
        slots.forEach((slot, index) => {
            if (slot.classList.contains('occupied') && slot.dataset.studentId) {
                const studentId = parseInt(slot.dataset.studentId);
                const student = studentsData.find(s => s.id === studentId);

                if (student) {
                    studentsPlacement.push({
                        element_id: elementId,
                        slot_index: index,
                        student_id: studentId,
                        student_name: student.full_name
                    });
                }
            }
        });
    });

    const planData = {
        elements: elements,
        students_placement: studentsPlacement
    };

    // R√©cup√©rer l'ID de la classe depuis les variables globales
    {% if lesson_classroom %}
    const classroomId = {{ lesson_classroom.id }};
    {% else %}
    const classroomId = null;
    {% endif %}

    if (!classroomId) {
        console.error('Impossible de sauvegarder: ID de classe non disponible');
        return;
    }

    // Envoyer au serveur
    fetch('/planning/save-seating-plan', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            classroom_id: classroomId,
            plan_data: planData,
            name: 'Plan par d√©faut'
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Plan de classe sauvegard√© avec succ√®s');
            // Notification visuelle discr√®te (optionnelle)
        } else {
            console.error('Erreur lors de la sauvegarde:', data.message);
        }
    })
    .catch(error => {
        console.error('Erreur r√©seau:', error);
    });
}

// Fonction pour ajuster l'√©chelle du plan pour qu'il s'adapte au conteneur
function adjustSeatingScale() {
    const workspace = document.getElementById('seating-workspace');
    const viewer = document.getElementById('seating-plan-viewer');
    
    if (!workspace || !viewer) return;
    
    // Attendre que le viewer ait une taille
    if (viewer.offsetWidth === 0) {
        setTimeout(adjustSeatingScale, 100);
        return;
    }
    
    const elements = workspace.querySelectorAll('.seating-element');
    if (elements.length === 0) return;
    
    // Calculer les limites du contenu
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    elements.forEach(element => {
        const x = parseFloat(element.style.left) || 0;
        const y = parseFloat(element.style.top) || 0;
        const width = element.offsetWidth;
        const height = element.offsetHeight;
        
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
    });
    
    // Ajouter une marge
    const margin = 40;
    minX -= margin;
    minY -= margin;
    maxX += margin;
    maxY += margin;
    
    // Calculer les dimensions du contenu
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    // Obtenir les dimensions du viewer
    const viewerWidth = viewer.offsetWidth;
    const viewerHeight = viewer.offsetHeight || 400; // Hauteur par d√©faut
    
    // Calculer l'√©chelle pour adapter le contenu
    const scaleX = viewerWidth / contentWidth;
    const scaleY = viewerHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY, 1); // Ne pas agrandir au-del√† de 100%
    
    // Centrer le contenu
    const scaledWidth = contentWidth * scale;
    const scaledHeight = contentHeight * scale;
    const translateX = (viewerWidth - scaledWidth) / 2 - minX * scale;
    const translateY = (viewerHeight - scaledHeight) / 2 - minY * scale;
    
    // Appliquer la transformation
    workspace.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    workspace.style.transformOrigin = '0 0';
    
    console.log(`Plan ajust√©: √©chelle ${scale}, translation (${translateX}, ${translateY})`);
}


</script>

<style>
.add-resource-btn, .edit-planning-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.375rem 0.75rem;
    background-color: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
    border-radius: var(--border-radius);
    text-decoration: none;
    font-size: 0.875rem;
    transition: all 0.3s ease;
    cursor: pointer;
}

.add-resource-btn:hover, .edit-planning-btn:hover {
    background-color: var(--primary-color);
    color: white;
}

.add-resource-btn {
    background-color: var(--primary-color);
    color: white;
}

.add-resource-btn:hover {
    background-color: var(--primary-hover);
}

/* Styles pour le formulaire de planification */
#planningEdit {
    animation: fadeIn 0.3s ease;
}

#planningForm .form-group {
    margin-bottom: 1rem;
}

#planningForm .form-label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--dark-color);
}

#planningForm .form-control {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #D1D5DB;
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: border-color 0.3s ease;
    font-family: inherit;
}

#planningForm .form-control:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

#planningForm textarea.form-control {
    resize: vertical;
    min-height: 120px;
}

/* Styles pour l'autocompl√©tion des m√©mos */
.memo-autocomplete {
    position: absolute;
    z-index: 1000;
    background: white;
    border: 1px solid #D1D5DB;
    border-radius: 0.375rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    max-height: 300px;
    overflow-y: auto;
    min-width: 300px;
}

.memo-autocomplete-item {
    padding: 0.75rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid #F3F4F6;
    transition: background-color 0.15s;
}

.memo-autocomplete-item:last-child {
    border-bottom: none;
}

.memo-autocomplete-item:hover, .memo-autocomplete-item.selected {
    background-color: #F3F4F6;
}

.memo-autocomplete-item.header {
    background-color: #F9FAFB;
    font-weight: 600;
    color: #374151;
    cursor: default;
    padding: 0.5rem 1rem;
}

.memo-autocomplete-item.header:hover {
    background-color: #F9FAFB;
}

.memo-autocomplete-student {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.memo-autocomplete-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
}

.memo-autocomplete-name {
    flex: 1;
}

/* Liste des m√©mos/remarques */
.memos-list-container {
    margin-top: 1rem;
}

.memo-item, .remark-item {
    background: #F9FAFB;
    border-left: 4px solid #3B82F6;
    padding: 0.75rem 1rem;
    margin-bottom: 0.5rem;
    border-radius: 0.375rem;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    transition: all 0.2s;
}

.remark-item {
    border-left-color: #8B5CF6;
}

.memo-item:hover, .remark-item:hover {
    background: #F3F4F6;
    transform: translateX(2px);
}

.memo-content {
    flex: 1;
}

.memo-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.25rem;
}

.memo-type-badge {
    background: #3B82F6;
    color: white;
    padding: 0.125rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-weight: 600;
}

.remark-item .memo-type-badge {
    background: #8B5CF6;
}

.memo-student-name {
    font-weight: 600;
    color: #374151;
}

.memo-date {
    color: #6B7280;
    font-size: 0.875rem;
}

.memo-text {
    color: #374151;
    margin-top: 0.25rem;
}

.memo-actions {
    display: flex;
    gap: 0.5rem;
}

.memo-action-btn {
    background: none;
    border: none;
    color: #6B7280;
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    transition: all 0.2s;
    font-size: 0.875rem;
}

.memo-action-btn:hover {
    background: #E5E7EB;
    color: #374151;
}

.memo-action-btn.delete:hover {
    background: #FEE2E2;
    color: #DC2626;
}

/* Nouveaux styles pour les boutons d'action m√©mo/remarque */
.memos-actions {
    display: flex;
    gap: 0.75rem;
    margin-top: 0.75rem;
    margin-bottom: 1rem;
}

.btn-memo, .btn-remark {
    flex: 1;
    padding: 0.625rem 1rem;
    font-size: 0.875rem;
    border-radius: 0.375rem;
    border: 1px solid #D1D5DB;
    background: white;
    color: #374151;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.btn-memo:hover {
    background: #DBEAFE;
    border-color: #3B82F6;
    color: #1E40AF;
}

.btn-remark:hover {
    background: #EDE9FE;
    border-color: #8B5CF6;
    color: #6D28D9;
}

/* Formulaire de cr√©ation */
.memo-form {
    margin-top: 1rem;
    padding: 1rem;
    background: #F9FAFB;
    border-radius: 0.5rem;
    border: 1px solid #E5E7EB;
}

.memo-form .form-group {
    margin-bottom: 1rem;
}

.memo-form .form-group:last-child {
    margin-bottom: 0;
}

.memo-form-actions {
    display: flex;
    gap: 0.75rem;
    margin-top: 1rem;
}

.memo-form-actions button {
    flex: 1;
}

/* Tags d'√©l√®ves s√©lectionn√©s */
.selected-students {
    margin-top: 1rem;
}

.selected-students-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
    margin-bottom: 0.75rem;
}

.student-tag {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: #EDE9FE;
    color: #6D28D9;
    padding: 0.375rem 0.75rem;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
}

.remove-student {
    background: none;
    border: none;
    color: #6D28D9;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    transition: all 0.2s;
}

.remove-student:hover {
    background: #DDD6FE;
}

.form-actions {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
}

.form-actions button {
    flex: 1;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideInNotification {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutNotification {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* Animation pour le changement de vue */
.planning-content > div {
    transition: opacity 0.2s ease;
}

/* Styles pour les ressources */
.resource-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.resource-btn {
    width: 32px;
    height: 32px;
    border: 1px solid var(--primary-color);
    background-color: transparent;
    color: var(--primary-color);
    border-radius: var(--border-radius);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.resource-btn:hover {
    background-color: var(--primary-color);
    color: white;
}

.resources-loading {
    text-align: center;
    padding: 2rem;
    color: var(--gray-color);
}

.resources-loading i {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.pinned-resources {
    margin-bottom: 1.5rem;
}

.pinned-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--light-gray);
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: var(--primary-color);
    font-size: 0.875rem;
}

.pinned-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.folder-navigation {
    margin-bottom: 1rem;
    background-color: #F8FAFC;
    border: 1px solid #E5E7EB;
    border-radius: 0.5rem;
    padding: 0.5rem;
}

.resource-breadcrumb {
    display: flex;
    align-items: center;
    gap: 0.125rem;
    font-size: 0.8rem;
    overflow-x: auto;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.resource-breadcrumb::-webkit-scrollbar {
    display: none;
}

.breadcrumb-item {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.15s ease;
    color: #6B7280;
    background-color: transparent;
    flex-shrink: 0;
    font-weight: 400;
}

.breadcrumb-item:hover {
    background-color: #E5E7EB;
    color: #374151;
}

.breadcrumb-item.active {
    background-color: var(--primary-color);
    color: white;
    font-weight: 500;
}

.breadcrumb-separator {
    color: #9CA3AF;
    margin: 0 0.125rem;
    font-size: 0.75rem;
    flex-shrink: 0;
}

.resources-tree {
    display: flex;
    flex-direction: column;
    gap: 1px;
    border: 1px solid #E5E7EB;
    border-radius: 0.5rem;
    overflow: hidden;
    background-color: white;
}

.resource-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background-color: white;
    transition: all 0.15s ease;
    cursor: pointer;
    border-bottom: 1px solid #F3F4F6;
    min-height: 44px;
}

.resource-item:last-child {
    border-bottom: none;
}

.resource-item:hover {
    background-color: #F8FAFC;
}

.resource-item.pinned {
    background-color: #FFFBEB;
    border-left: 3px solid #F59E0B;
}

.resource-item.pinned:hover {
    background-color: #FEF3C7;
}

.resource-item.folder {
    background-color: #F0F9FF;
    border-left: 3px solid #3B82F6;
    font-weight: 500;
}

.resource-item.folder:hover {
    background-color: #E0F2FE;
}

.resource-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    flex-shrink: 0;
}

.resource-icon.pdf {
    color: #DC2626;
}

.resource-icon.image {
    color: #059669;
}

.resource-icon.folder {
    color: #3B82F6;
}

.resource-icon.pinned {
    color: #F59E0B;
}

.resource-info {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.resource-main {
    flex: 1;
    min-width: 0;
}

.resource-name {
    font-weight: 400;
    color: var(--dark-color);
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.2;
}

.resource-item.folder .resource-name {
    font-weight: 500;
    color: #1E40AF;
}

.resource-meta {
    font-size: 0.75rem;
    color: #6B7280;
    display: flex;
    gap: 0.75rem;
    margin-top: 0.125rem;
    white-space: nowrap;
}

.resource-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
    margin-left: 0.5rem;
}

.resource-action-btn {
    width: 24px;
    height: 24px;
    border: none;
    background-color: transparent;
    color: #9CA3AF;
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    opacity: 0;
    font-size: 0.75rem;
}

.resource-item:hover .resource-action-btn {
    opacity: 1;
}

.resource-action-btn:hover {
    background-color: #F3F4F6;
    color: var(--primary-color);
}

.resource-action-btn.pinned {
    color: #F59E0B;
    opacity: 1;
}

.resource-action-btn.pinned:hover {
    background-color: #FEF3C7;
}

/* Styles pour les fichiers annotables */
.clickable-file {
    cursor: pointer;
    color: var(--primary-color) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.clickable-file:hover {
    text-decoration: underline;
    color: var(--primary-hover) !important;
}

.annotatable-badge {
    background-color: #10B981;
    color: white;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    font-size: 0.6rem;
    font-weight: 600;
}

/* Responsive */
@media (max-width: 1200px) {
    .resource-meta {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .resource-actions {
        flex-direction: column;
    }
}

/* Styles pour le plan de classe dans l'onglet */
.seating-plan-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid #e9ecef;
    background-color: #f8f9fa;
}

.seating-plan-info h3 {
    margin: 0;
    color: #333;
    font-size: 1.1rem;
}

.seating-plan-info p {
    margin: 0.25rem 0 0 0;
    color: #666;
    font-size: 0.875rem;
}

/* Styles suppl√©mentaires pour le bouton d'annulation */
#undo-warning-btn {
    font-size: 0.875rem;
}

#undo-warning-btn i {
    margin-right: 0.25rem;
}

.seating-plan-container {
    height: calc(100% - 80px);
    padding: 1rem;
}

.seating-plan-viewer {
    background: white;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 400px;
}

.seating-workspace {
    width: 100% !important;
    height: 100% !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    background: white;
    background-image: radial-gradient(circle, #e9ecef 1px, transparent 1px);
    background-size: 20px 20px;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    outline: none !important;
    box-sizing: border-box !important;
    min-width: unset !important;
    max-width: none !important;
    min-height: unset !important;
    max-height: none !important;
}

/* √âl√©ments du plan */
.seating-element {
    position: absolute;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: default;
    user-select: none;
}

.desk-single {
    background: white;
    border: 2px solid black;
    color: black;
}

.desk-double {
    background: white;
    border: 2px solid black;
    color: black;
}

.teacher-desk {
    background: #f0f0f0;
    border: 2px solid #333;
    color: #333;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

.student-slots {
    display: flex;
    gap: 4px;
    justify-content: center;
    align-items: center;
    height: 100%;
    padding: 4px;
    flex-wrap: nowrap;
    min-width: 100%;
    width: auto;
}

.student-slot {
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #666;
    border-radius: 4px;
    background: white;
    height: 80%;
    min-width: 30px;
    max-width: 120px;
    width: auto;
    font-size: 0.7rem;
    text-align: center;
    padding: 2px 6px;
    overflow: visible;
    flex: 1 1 auto;
    white-space: nowrap;
}

.student-slot.occupied {
    background: white;
    border-color: black;
    color: black;
}

/* √âtats d'avertissement pour les slots d'√©l√®ves */
.student-slot.warning-1 {
    background: #fff3cd !important;
    border-color: #ffc107 !important;
    color: #856404 !important;
}

.student-slot.warning-2 {
    background: #f8d7da !important;
    border-color: #dc3545 !important;
    color: #721c24 !important;
}

.student-slot.warning-3 {
    background: rgba(52, 58, 64, 0.7) !important;
    border-color: rgba(0, 0, 0, 0.8) !important;
    color: #fff !important;
}

.student-placed {
    color: black;
    font-size: 0.65rem;
    line-height: 1.1;
    text-align: center;
    font-weight: 500;
    width: auto;
    white-space: nowrap;
    overflow: visible;
    text-overflow: unset;
    padding: 0 2px;
    cursor: move;
    cursor: grab;
}

.student-placed:active {
    cursor: grabbing;
}

.student-not-found {
    color: #dc3545 !important;
    font-style: italic;
    opacity: 0.7;
}

/* Effet de drag-and-drop */
.student-slot.drag-over {
    background-color: #e3f2fd !important;
    border: 2px dashed #2196F3 !important;
    transform: scale(1.05);
    transition: all 0.2s ease;
}

/* Vue c√¥te-√†-c√¥te pour √©dition de planification avec visualisation PDF */
.split-view-container {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f5f5f5;
    z-index: 9999;
}

.split-view-container.active {
    display: flex;
}

.split-view-left {
    width: 40%;
    height: 100%;
    background-color: white;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
    overflow-y: auto;
    padding: 2rem;
}

.split-view-left .form-group {
    margin-bottom: 1.5rem;
}

.split-view-left .form-control {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #D1D5DB;
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: border-color 0.3s ease;
}

.split-view-left .form-control:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.split-view-left textarea.form-control {
    resize: vertical;
    min-height: 200px;
}

.split-view-right {
    width: 60%;
    height: 100%;
    position: relative;
    overflow: hidden;
}

.split-view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}

.split-view-close {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10001;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.split-view-close:hover {
    background-color: rgba(0, 0, 0, 0.9);
}

/* Styles pour le Modal Viewer/Annotateur Am√©lior√© */
.file-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    display: none;
    flex-direction: column;
}

.file-viewer-modal.show {
    display: flex;
}

/* Mode int√©gr√© pour le viewer dans la vue split */
.file-viewer-modal.embedded {
    position: absolute;
    background-color: transparent;
}

.file-viewer-modal.embedded .viewer-header {
    background-color: #2d3748;
    color: white;
}

.viewer-header {
    background-color: #f8fafc;
    color: #2d3748;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    z-index: 1;
    position: relative;
}

.viewer-title {
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 0.95rem;
    font-weight: 500;
}

/* Styles page-info supprim√©s */

.viewer-tools {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: nowrap;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding-right: 1.5rem;
    border-right: 1px solid #e2e8f0;
}

.tool-group:last-child {
    border-right: none;
    padding-right: 0;
}

.tool-btn {
    width: 40px;
    height: 40px;
    border: 1px solid #e2e8f0;
    background-color: #ffffff;
    color: #4a5568;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.tool-btn:hover {
    background-color: #f7fafc;
    border-color: #cbd5e0;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}

.tool-btn.active {
    background-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
}

.color-picker-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #ffffff;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 1;
}

.preset-colors {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.color-btn {
    width: 28px;
    height: 28px;
    border: 2px solid transparent;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    z-index: 1;
}

.color-btn:hover {
    transform: scale(1.1);
    border-color: white;
}

.color-btn.active {
    border-color: white;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

.color-picker-container input[type="color"] {
    width: 32px;
    height: 32px;
    border: 2px solid transparent;
    border-radius: 0.5rem;
    cursor: pointer;
    background: none;
}

.stroke-width-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #4A5568;
    padding: 0.5rem;
    border-radius: 0.5rem;
    position: relative;
    z-index: 10;
}

.stroke-width-container input[type="range"] {
    width: 80px;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: #6B7280;
    outline: none;
    border-radius: 3px;
    cursor: pointer;
}

.stroke-width-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.stroke-width-container input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    border: none;
}

#strokeWidthValue {
    min-width: 20px;
    text-align: center;
    font-size: 0.9rem;
}

.close-viewer {
    width: 40px;
    height: 40px;
    border: none;
    background-color: #E53E3E;
    color: white;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.close-viewer:hover {
    background-color: #C53030;
    transform: scale(1.05);
}

.viewer-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
    z-index: 0;
}

.viewer-container {
    max-width: 100%;
    max-height: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Styles d'annotation canvas supprim√©s - dupliqu√©s plus bas */

.pdf-container, .image-container {
    position: relative;
    display: inline-block;
}

.viewer-footer {
    background-color: #2D3748;
    color: white;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-top: 1px solid #4A5568;
}

.save-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #68D391;
    font-size: 0.9rem;
}

.save-status.saving {
    color: #F6AD55;
}

.save-status.error {
    color: #FC8181;
}

/* Styles pour la nouvelle interface am√©lior√©e */
/* Styles zoomLevel supprim√©s */

.viewer-content {
    flex: 1;
    display: flex;
    overflow: hidden;
    position: relative;
    min-height: 0; /* Allow flex children to shrink */
}

/* Barre lat√©rale des pages - permanente √† gauche */
.page-sidebar {
    width: 220px;
    background-color: #f8fafc;
    border-right: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
}

.page-sidebar.show {
    display: flex;
}

.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.sidebar-header h6 {
    margin: 0;
    color: white;
    font-size: 0.9rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}


/* Zone de miniatures scrollable moderne */
.page-thumbnails {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f1f5f9;
}

.page-thumbnails.scrollable {
    max-height: calc(100vh - 200px);
}

.page-thumbnails::-webkit-scrollbar {
    width: 8px;
}

.page-thumbnails::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
}

.page-thumbnails::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
    transition: background 0.2s ease;
}

.page-thumbnails::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.thumbnail-item {
    margin-bottom: 0.75rem;
    border: 2px solid transparent;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.thumbnail-item:hover {
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.thumbnail-item.active {
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
}

.thumbnail-canvas {
    width: 100%;
    display: block;
    border-radius: 0.25rem;
}

/* Zone d'affichage principal */
.viewer-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 1rem;
    background-color: #f7fafc;
    position: relative;
    height: 100%;
    scroll-behavior: auto;
}

.pdf-pages-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 1rem 0;
    min-height: 100%;
    width: 100%;
}

.pdf-page-wrapper {
    position: relative;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    margin-bottom: 1rem;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 0.5rem;
    pointer-events: auto;
    touch-action: none;
    z-index: 2;
}

.pdf-page-number {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    z-index: 10;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
    cursor: crosshair;
    border-radius: 0.5rem;
    width: 100%;
    height: 100%;
    pointer-events: auto;
    touch-action: none;
}

/* √âtats des boutons */
.tool-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.tool-btn:disabled:hover {
    background-color: #4A5568;
    transform: none;
}

/* Animation de chargement */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.loading {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Styles pour les erreurs */
.error-message {
    color: #fc8181;
    text-align: center;
    padding: 2rem;
    background-color: #fed7d7;
    border-radius: 0.5rem;
    margin: 1rem;
}

/* Responsive pour le viewer am√©lior√© */
@media (max-width: 768px) {
    .viewer-header {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .viewer-tools {
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .tool-group {
        padding-right: 0.5rem;
        border-right: none;
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    .tool-group:last-child {
        border-bottom: none;
        margin-bottom: 0;
    }
    
    .tool-btn {
        width: 35px;
        height: 35px;
    }
    
    .stroke-width-container input[type="range"] {
        width: 60px;
    }
    
    .viewer-footer {
        padding: 0.5rem 1rem;
    }
    
    .page-sidebar {
        width: 180px;
    }
    
    .page-sidebar.show {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 100;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    .viewer-container {
        padding: 0.5rem;
    }
    
    .viewer-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
    }
    
    /* Styles zoomLevel responsive supprim√©s */
}

@media (max-width: 480px) {
    .viewer-header {
        padding: 0.5rem;
    }
    
    .viewer-tools {
        justify-content: center;
        width: 100%;
    }
    
    .tool-group {
        gap: 0.25rem;
    }
    
    .tool-btn {
        width: 32px;
        height: 32px;
        font-size: 0.8rem;
    }
    
    .color-btn {
        width: 24px;
        height: 24px;
    }
    
    .page-sidebar {
        width: 160px;
    }
}

/* Styles pour l'int√©gration du lecteur PDF unifi√© */
.file-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    display: none;
}

.unified-pdf-viewer-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    background: white;
}

.unified-pdf-viewer-wrapper .close-viewer {
    position: absolute;
    top: 2rem;
    right: 1rem;
    z-index: 10001;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.3s ease;
}

.unified-pdf-viewer-wrapper .close-viewer:hover {
    background: rgba(0, 0, 0, 0.9);
    transform: scale(1.1);
}

#unified-pdf-viewer-container {
    width: 100%;
    height: 100%;
}

/* Correction affichage miniatures - scroll vertical avec miniatures pleine largeur */
.thumbnails-container {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 12px !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    padding: 12px !important;
    height: 100% !important;
    flex: 1 !important;
    grid-auto-rows: max-content !important;
}

.thumbnail-item {
    width: 100% !important;
    min-width: auto !important;
    max-width: none !important;
    height: auto !important;
    min-height: 140px !important;
    padding: 8px !important;
    margin-bottom: 0 !important;
    box-sizing: border-box !important;
    display: flex !important;
    flex-direction: column !important;
}

.thumbnail-canvas {
    width: calc(100% - 16px) !important;
    height: 120px !important;
    min-height: 120px !important;
    max-height: 120px !important;
    max-width: 100% !important;
    display: block !important;
    object-fit: contain !important;
    border: 1px solid #ddd !important;
    margin: 0 auto !important;
    flex-shrink: 0 !important;
}

.thumbnail-number {
    font-size: 10px !important;
    padding: 1px 3px !important;
    position: absolute !important;
    bottom: 4px !important;
    left: 4px !important;
    background: rgba(0, 0, 0, 0.4) !important;
    color: white !important;
    border-radius: 2px !important;
    font-weight: 600 !important;
    line-height: 1 !important;
    min-width: auto !important;
    max-width: fit-content !important;
    width: auto !important;
    height: auto !important;
    text-align: center !important;
    z-index: 10 !important;
    display: inline-block !important;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
}

/* Am√©liorer la scrollbar verticale */
.thumbnails-container::-webkit-scrollbar {
    width: 8px !important;
    height: auto !important;
}

.thumbnails-container::-webkit-scrollbar-track {
    background: #f1f1f1 !important;
    border-radius: 4px !important;
}

.thumbnails-container::-webkit-scrollbar-thumb {
    background: #c1c1c1 !important;
    border-radius: 4px !important;
}

.thumbnails-container::-webkit-scrollbar-thumb:hover {
    background: #a1a1a1 !important;
}

/* S'assurer que le panneau des miniatures utilise tout l'espace */
#thumbnails-panel {
    display: flex !important;
    flex-direction: column !important;
    height: 100% !important;
    min-height: 200px !important;
    max-height: none !important;
}

/* Surcharger TOUTES les contraintes avec des s√©lecteurs ultra-sp√©cifiques */
.unified-pdf-viewer .thumbnails-container .thumbnail-item,
#thumbnails-container .thumbnail-item,
#thumbnails-panel .thumbnail-item,
body .thumbnail-item {
    width: 100% !important;
    min-height: 140px !important;
    max-height: none !important;
    height: auto !important;
    padding: 8px !important;
    margin-bottom: 0 !important;
    display: flex !important;
    flex-direction: column !important;
}

.unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
#thumbnails-container .thumbnail-canvas,
#thumbnails-panel .thumbnail-canvas,
body .thumbnail-canvas {
    width: calc(100% - 16px) !important;
    height: 120px !important;
    min-height: 120px !important;
    max-height: 120px !important;
    object-fit: contain !important;
    border: 1px solid #ddd !important;
    margin: 0 auto !important;
    flex-shrink: 0 !important;
}

/* Surcharger toutes les media queries avec des hauteurs fixes */
@media (max-width: 1200px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 140px !important;
        height: auto !important;
        padding: 8px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 120px !important;
        min-height: 120px !important;
        max-height: 120px !important;
        width: calc(100% - 16px) !important;
    }
    
    .thumbnail-number {
        font-size: 9px !important;
        padding: 1px 2px !important;
        bottom: 3px !important;
        left: 3px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 900px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 130px !important;
        height: auto !important;
        padding: 6px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 110px !important;
        min-height: 110px !important;
        max-height: 110px !important;
        width: calc(100% - 12px) !important;
    }
    
    .thumbnail-number {
        font-size: 8px !important;
        padding: 1px 2px !important;
        bottom: 3px !important;
        left: 3px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 768px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 120px !important;
        height: auto !important;
        padding: 6px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 100px !important;
        min-height: 100px !important;
        max-height: 100px !important;
        width: calc(100% - 12px) !important;
    }
    
    .thumbnail-number {
        font-size: 8px !important;
        padding: 1px 2px !important;
        bottom: 2px !important;
        left: 2px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 600px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 110px !important;
        height: auto !important;
        padding: 4px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 90px !important;
        min-height: 90px !important;
        max-height: 90px !important;
        width: calc(100% - 8px) !important;
    }
    
    .thumbnail-number {
        font-size: 7px !important;
        padding: 1px 2px !important;
        bottom: 2px !important;
        left: 2px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 400px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 100px !important;
        height: auto !important;
        padding: 4px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 80px !important;
        min-height: 80px !important;
        max-height: 80px !important;
        width: calc(100% - 8px) !important;
    }
    
    .thumbnail-number {
        font-size: 6px !important;
        padding: 1px 2px !important;
        bottom: 1px !important;
        left: 1px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}
</style>

<!-- Perfect Freehand - Biblioth√®que d'annotation vectorielle -->
<script type="module">
    // Importer perfect-freehand depuis CDN et exposer globalement
    import { getStroke } from 'https://cdn.skypack.dev/perfect-freehand@1.2.0';
    window.getStroke = getStroke;
    console.log('‚úÖ perfect-freehand charg√©');

    // Signaler que perfect-freehand est pr√™t
    window.perfectFreehandReady = true;
    window.dispatchEvent(new Event('perfectFreehandLoaded'));
</script>

<!-- Simple Pen Annotation System - Charg√© apr√®s perfect-freehand -->
<script>
    // Charger le nouveau syst√®me d'annotation optimis√© (ne n√©cessite plus perfect-freehand)
    function loadAnnotationEngine() {
        const script = document.createElement('script');
        script.src = "{{ url_for('static', filename='js/optimized-pen-annotation.js') }}?v=3.0.0&cache_bust={{ range(1000000, 9999999) | random }}";
        script.onload = function() {
            console.log('‚ú® Syst√®me d\'annotation optimis√© charg√© avec succ√®s');
        };
        document.head.appendChild(script);
    }
    loadAnnotationEngine();
</script>

<!-- Syst√®me de m√©mos et remarques -->
<script src="{{ url_for('static', filename='js/lesson-memos.js') }}?cache_bust={{ range(1000000, 9999999) | random }}"></script>

<!-- Nouveau Lecteur PDF Clean -->
<script src="{{ url_for('static', filename='js/clean-pdf-tools.js') }}?v=5.5.3&cache_bust={{ range(1000000, 9999999) | random }}"></script>
<script src="{{ url_for('static', filename='js/clean-pdf-viewer.js') }}?v=5.5.3&cache_bust={{ range(1000000, 9999999) | random }}"></script>
<script>
// Variables globales pour le lecteur PDF
let cleanPDFViewer = null;
let currentPDFUrl = null;

// Donn√©es des √©tudiants (d√©finies globalement pour le PDF viewer)
let studentsData = [
    {% for student in students %}
    {
        id: {{ student.id }},
        first_name: {{ student.first_name | tojson }},
        last_name: {{ (student.last_name or '') | tojson }},
        full_name: {{ student.full_name | tojson }}
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];

// Fonction pour ouvrir un fichier avec le nouveau lecteur unifi√©
function openFileWithUnifiedViewer(filePath, fileName) {
    console.log('üéØ Ouverture avec le lecteur unifi√©:', fileName);

    // V√©rifier et obtenir la modal parente d'abord
    // Utiliser querySelector directement car c'est plus fiable
    let modal = document.querySelector('.file-viewer-modal');
    console.log('üîç Modal trouv√©e (querySelector):', modal);

    // Fallback sur getElementById si querySelector ne fonctionne pas
    if (!modal) {
        modal = document.getElementById('fileViewerModal');
        console.log('üîç Modal trouv√©e (getElementById):', modal);
    }

    if (!modal) {
        console.error('‚ùå Impossible de trouver la modal avec querySelector et getElementById');
        alert('Erreur: La modal de visualisation n\'existe pas.\n\nVeuillez recharger la page (Ctrl/Cmd+R).');
        return;
    }

    // Afficher la modal d'abord
    modal.style.display = 'flex';

    // Maintenant chercher le container √† l'int√©rieur de la modal
    let viewerContainer = document.getElementById('unified-pdf-viewer-container');
    console.log('üîç Container trouv√©:', viewerContainer);

    if (!viewerContainer) {
        console.warn('‚ö†Ô∏è Container non trouv√© par ID, recherche dans la modal...');
        // Chercher le container dans la modal
        viewerContainer = modal.querySelector('#unified-pdf-viewer-container');
        if (!viewerContainer) {
            console.error('‚ùå Container toujours introuvable, tentative de recr√©ation...');
            // Essayer de recr√©er le container
            const wrapper = modal.querySelector('.unified-pdf-viewer-wrapper');
            if (wrapper) {
                console.log('üîß Wrapper trouv√©, recr√©ation du container...');
                viewerContainer = document.createElement('div');
                viewerContainer.id = 'unified-pdf-viewer-container';
                wrapper.appendChild(viewerContainer);
                console.log('‚úÖ Container recr√©√© avec succ√®s');
            } else {
                console.error('‚ùå Wrapper introuvable, impossible de recr√©er le container');
                alert('Erreur: Le container de visualisation n\'existe pas.\n\nVeuillez recharger la page (Ctrl/Cmd+R).');
                modal.style.display = 'none';
                return;
            }
        } else {
            console.log('‚úÖ Container trouv√© dans la modal via querySelector');
        }
    }

    viewerContainer.style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // V√©rifier la disponibilit√© des donn√©es des √©l√®ves
    if (typeof studentsData === 'undefined' || !Array.isArray(studentsData)) {
        console.warn('studentsData non d√©fini, utilisation d‚Äôun tableau vide');
        studentsData = [];
    }
    
    // Pr√©parer les donn√©es des √©l√®ves et sanctions pour le PDF viewer
    const sanctionsData = {};
    try {
        // R√©cup√©rer les compteurs de sanctions actuels
        document.querySelectorAll('.count-display').forEach(element => {
            const studentId = element.dataset.student;
            const sanctionId = element.dataset.sanction;
            const count = parseInt(element.textContent) || 0;
            if (studentId && sanctionId) {
                sanctionsData[`${studentId}_${sanctionId}`] = count;
            }
        });
    } catch (error) {
        console.warn('Erreur lors de la r√©cup√©ration des sanctions:', error);
    }
    
    // R√©cup√©rer le HTML du plan de classe actuel s'il existe
    let seatingPlanHTML = null;
    try {
        const seatingWorkspace = document.querySelector('#seating-workspace');
        if (seatingWorkspace) {
            seatingPlanHTML = seatingWorkspace.outerHTML;
        }
    } catch (error) {
        console.warn('Erreur lors de la r√©cup√©ration du plan de classe:', error);
    }

    // Le viewerContainer est d√©j√† d√©fini et affich√© au d√©but de la fonction (ligne 8977)
    // Pas besoin de le red√©clarer ici

    // Cr√©er l'instance du nouveau lecteur clean s'il n'existe pas
    if (!cleanPDFViewer) {
        try {
            // Pr√©parer l'URL du PDF
            const pdfUrl = `/file_manager/serve_file/${encodeURIComponent(filePath)}`;
            currentPDFUrl = pdfUrl;

            cleanPDFViewer = new CleanPDFViewer('unified-pdf-viewer-container', {
                fileId: filePath, // Utiliser filePath comme ID pour les annotations
                pdfUrl: pdfUrl,
                showSidebar: true,
                enableAnnotations: true,
                autoSaveInterval: 5000,
                studentData: studentsData, // Donn√©es des √©l√®ves
                onClose: () => {
                    if (viewerContainer) {
                        viewerContainer.style.display = 'none';
                    }
                    cleanPDFViewer = null;
                    currentPDFUrl = null;
                }
            });

            console.log('‚úÖ Nouveau lecteur PDF Clean cr√©√©');
        } catch (error) {
            console.error('‚ùå Erreur lors de la cr√©ation du lecteur:', error);
            alert('Erreur lors de la cr√©ation du lecteur PDF: ' + error.message);
            return;
        }
    } else {
        // Si le viewer existe d√©j√†, charger le nouveau PDF
        const pdfUrl = `/file_manager/serve_file/${encodeURIComponent(filePath)}`;
        currentPDFUrl = pdfUrl;

        cleanPDFViewer.loadPDF(pdfUrl)
            .catch(error => {
                console.error('‚ùå Erreur lors du chargement du PDF:', error);
                alert('Erreur lors du chargement du PDF: ' + error.message);
            });
    }
}

// closeFileViewer() est d√©fini plus haut dans le fichier (ligne ~5354)
// Ne pas dupliquer la fonction ici

// ============================================================================
// GESTION DES FEUILLES BLANCHES
// ============================================================================

/**
 * Affiche le menu de s√©lection des feuilles blanches
 */
async function showBlankSheetsMenu() {
    const lessonDate = '{{ lesson_date.strftime("%Y-%m-%d") if lesson_date else "" }}';
    const periodNumber = {{ lesson.period_number if lesson else 0 }};
    const classroomId = {{ lesson_classroom.id if lesson_classroom else 'null' }};

    if (!lessonDate || !periodNumber) {
        alert('Informations de le√ßon manquantes');
        return;
    }

    try {
        // Charger les feuilles blanches existantes
        const response = await fetch(`/planning/api/blank-sheets/list?date=${lessonDate}&period=${periodNumber}&classroom_id=${classroomId}`);
        const data = await response.json();

        if (!data.success) {
            console.error('Erreur chargement feuilles blanches:', data.error);
            // Cr√©er directement une nouvelle feuille en cas d'erreur
            openNewBlankSheet(lessonDate, periodNumber, classroomId);
            return;
        }

        if (data.sheets.length === 0) {
            // Aucune feuille existante, cr√©er directement
            openNewBlankSheet(lessonDate, periodNumber, classroomId);
        } else {
            // Afficher menu de s√©lection
            displayBlankSheetsMenu(data.sheets, lessonDate, periodNumber, classroomId);
        }
    } catch (error) {
        console.error('Erreur lors du chargement des feuilles blanches:', error);
        // Cr√©er directement une nouvelle feuille en cas d'erreur
        openNewBlankSheet(lessonDate, periodNumber, classroomId);
    }
}

/**
 * Affiche un menu pour s√©lectionner ou cr√©er une feuille blanche
 */
function displayBlankSheetsMenu(sheets, lessonDate, periodNumber, classroomId) {
    // Supprimer menu existant si pr√©sent
    const existingMenu = document.querySelector('.blank-sheets-menu');
    if (existingMenu) {
        existingMenu.remove();
    }

    // Cr√©er le menu
    const menu = document.createElement('div');
    menu.className = 'blank-sheets-menu';
    menu.innerHTML = `
        <div class="menu-header">
            <h4>Feuilles blanches de la le√ßon</h4>
            <button class="close-menu-btn">√ó</button>
        </div>
        <div class="menu-list">
            ${sheets.map(sheet => `
                <div class="sheet-item" data-sheet-id="${sheet.id}">
                    <i class="fas fa-file"></i>
                    <div class="sheet-info">
                        <span class="sheet-title">${sheet.title}</span>
                        <small class="sheet-date">${formatDateTime(sheet.created_at)}</small>
                    </div>
                </div>
            `).join('')}
        </div>
        <button class="btn-primary new-sheet-btn">
            <i class="fas fa-plus"></i> Nouvelle feuille
        </button>
    `;

    document.body.appendChild(menu);

    // Attacher les event listeners apr√®s l'ajout au DOM
    const closeBtn = menu.querySelector('.close-menu-btn');
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            menu.remove();
        });
    }

    // Event listeners pour les feuilles existantes
    menu.querySelectorAll('.sheet-item').forEach(item => {
        const sheetId = parseInt(item.dataset.sheetId);
        item.addEventListener('click', () => {
            console.log('üñ±Ô∏è Click menu: Ouverture feuille', sheetId);
            menu.remove(); // Fermer le menu d'abord
            openExistingBlankSheet(sheetId); // Puis ouvrir la feuille
        });
    });

    // Event listener pour le bouton nouvelle feuille
    const newSheetBtn = menu.querySelector('.new-sheet-btn');
    if (newSheetBtn) {
        newSheetBtn.addEventListener('click', () => {
            console.log('üñ±Ô∏è Click menu: Nouvelle feuille');
            menu.remove(); // Fermer le menu d'abord
            openNewBlankSheet(lessonDate, periodNumber, classroomId); // Puis cr√©er nouvelle feuille
        });
    }
}

/**
 * Ouvre le viewer pour cr√©er une nouvelle feuille blanche
 */
function openNewBlankSheet(lessonDate, periodNumber, classroomId) {
    console.log('üìÑ Cr√©ation nouvelle feuille blanche');

    // V√©rifier et obtenir la modal parente d'abord
    // Utiliser querySelector directement car c'est plus fiable
    let modal = document.querySelector('.file-viewer-modal');
    console.log('üîç Modal trouv√©e (querySelector):', modal);

    // Fallback sur getElementById si querySelector ne fonctionne pas
    if (!modal) {
        modal = document.getElementById('fileViewerModal');
        console.log('üîç Modal trouv√©e (getElementById):', modal);
    }

    if (!modal) {
        console.error('‚ùå Impossible de trouver la modal avec querySelector et getElementById');
        alert('Erreur: La modal de visualisation n\'existe pas.\n\nVeuillez recharger la page (Ctrl/Cmd+R).');
        return;
    }

    // Afficher la modal d'abord
    modal.style.display = 'flex';

    // Maintenant chercher le container √† l'int√©rieur de la modal
    let viewerContainer = document.getElementById('unified-pdf-viewer-container');
    console.log('üîç Container trouv√©:', viewerContainer);

    if (!viewerContainer) {
        console.warn('‚ö†Ô∏è Container non trouv√© par ID, recherche dans la modal...');
        // Chercher le container dans la modal
        viewerContainer = modal.querySelector('#unified-pdf-viewer-container');
        if (!viewerContainer) {
            console.error('‚ùå Container toujours introuvable, tentative de recr√©ation...');
            // Essayer de recr√©er le container
            const wrapper = modal.querySelector('.unified-pdf-viewer-wrapper');
            if (wrapper) {
                console.log('üîß Wrapper trouv√©, recr√©ation du container...');
                viewerContainer = document.createElement('div');
                viewerContainer.id = 'unified-pdf-viewer-container';
                wrapper.appendChild(viewerContainer);
                console.log('‚úÖ Container recr√©√© avec succ√®s');
            } else {
                console.error('‚ùå Wrapper introuvable, impossible de recr√©er le container');
                alert('Erreur: Le container de visualisation n\'existe pas.\n\nVeuillez recharger la page (Ctrl/Cmd+R).');
                modal.style.display = 'none';
                return;
            }
        } else {
            console.log('‚úÖ Container trouv√© dans la modal via querySelector');
        }
    }

    viewerContainer.style.display = 'block';
    document.body.style.overflow = 'hidden';

    // V√©rifier la disponibilit√© des donn√©es des √©l√®ves
    if (typeof studentsData === 'undefined' || !Array.isArray(studentsData)) {
        console.warn("studentsData non d√©fini, utilisation d'un tableau vide");
        studentsData = [];
    }

    // D√©truire le viewer existant s'il y en a un
    if (cleanPDFViewer) {
        console.log('üîÑ Destruction du viewer existant...');
        try {
            cleanPDFViewer.destroy();
        } catch (e) {
            console.warn('Erreur lors de la destruction du viewer:', e);
        }
        cleanPDFViewer = null;
    }

    try {
        cleanPDFViewer = new CleanPDFViewer('unified-pdf-viewer-container', {
            blankSheetId: null,  // Nouvelle feuille
                lessonDate: lessonDate,
                periodNumber: periodNumber,
                classroomId: classroomId,
                title: 'Feuille blanche',
                pdfUrl: null,
                showSidebar: true,
                enableAnnotations: true,
                autoSaveInterval: 5000,
                studentData: studentsData,
                onClose: () => {
                    // Fermer la modal si elle existe
                    const modalToClose = document.getElementById('fileViewerModal');
                    if (modalToClose) {
                        modalToClose.style.display = 'none';
                    }

                    // Fermer le container
                    const containerToClose = document.getElementById('unified-pdf-viewer-container');
                    if (containerToClose) {
                        containerToClose.style.display = 'none';
                    }

                    document.body.style.overflow = '';
                    cleanPDFViewer = null;

                    // Recharger la liste des ressources pour afficher la nouvelle feuille
                    loadClassResources();
                }
            });

        console.log('‚úÖ Nouvelle feuille blanche cr√©√©e');
    } catch (error) {
        console.error('‚ùå Erreur lors de la cr√©ation du viewer:', error);
        alert('Erreur lors de la cr√©ation du viewer: ' + error.message);
        return;
    }
}

/**
 * Ouvre une feuille blanche existante
 */
async function openExistingBlankSheet(sheetId) {
    console.log('üìÑ Ouverture feuille blanche:', sheetId);

    try {
        // Charger les donn√©es de la feuille
        const response = await fetch(`/planning/api/blank-sheets/${sheetId}`);
        const data = await response.json();

        if (!data.success) {
            alert('Erreur lors du chargement de la feuille: ' + (data.message || 'Erreur inconnue'));
            return;
        }

        const sheet = data.sheet;
        console.log('üìã Donn√©es de la feuille charg√©es:', sheet);

        // Attendre que tous les scripts et √©v√©nements en cours soient termin√©s
        await new Promise(resolve => setTimeout(resolve, 50));

        // V√©rifier et obtenir la modal parente d'abord
        // Essayer plusieurs m√©thodes pour trouver la modal
        let modal = document.querySelector('.file-viewer-modal');
        console.log('üîç Modal trouv√©e (querySelector):', modal);

        if (!modal) {
            modal = document.getElementById('fileViewerModal');
            console.log('üîç Modal trouv√©e (getElementById):', modal);
        }

        // Si toujours pas trouv√©e, chercher dans tout le document
        if (!modal) {
            console.warn('‚ö†Ô∏è Modal non trouv√©e, recherche exhaustive...');
            const allDivs = document.querySelectorAll('div');
            for (const div of allDivs) {
                if (div.id === 'fileViewerModal' || div.classList.contains('file-viewer-modal')) {
                    modal = div;
                    console.log('‚úÖ Modal trouv√©e via recherche exhaustive');
                    break;
                }
            }
        }

        if (!modal) {
            console.error('‚ùå Modal introuvable apr√®s recherche exhaustive');
            console.error('üìä √âtat du DOM:', {
                body: document.body ? 'existe' : 'null',
                childElementCount: document.body ? document.body.childElementCount : 0,
                allModals: document.querySelectorAll('[id*="modal"]').length,
                allViewers: document.querySelectorAll('[id*="viewer"]').length
            });
            alert('Erreur: La modal de visualisation n\'existe pas dans le DOM.\n\nVeuillez recharger la page (Ctrl/Cmd+R).');
            return;
        }

        // Afficher la modal d'abord
        modal.style.display = 'flex';

        // Maintenant chercher le container √† l'int√©rieur de la modal
        let viewerContainer = document.getElementById('unified-pdf-viewer-container');
        console.log('üîç Container trouv√©:', viewerContainer);

        if (!viewerContainer) {
            console.warn('‚ö†Ô∏è Container non trouv√© par ID, recherche dans la modal...');
            // Chercher le container dans la modal
            viewerContainer = modal.querySelector('#unified-pdf-viewer-container');
            if (!viewerContainer) {
                console.error('‚ùå Container toujours introuvable, tentative de recr√©ation...');
                // Essayer de recr√©er le container
                const wrapper = modal.querySelector('.unified-pdf-viewer-wrapper');
                if (wrapper) {
                    console.log('üîß Wrapper trouv√©, recr√©ation du container...');
                    viewerContainer = document.createElement('div');
                    viewerContainer.id = 'unified-pdf-viewer-container';
                    wrapper.appendChild(viewerContainer);
                    console.log('‚úÖ Container recr√©√© avec succ√®s');
                } else {
                    console.error('‚ùå Wrapper introuvable, impossible de recr√©er le container');
                    alert('Erreur: Le container de visualisation n\'existe pas.\n\nVeuillez recharger la page (Ctrl/Cmd+R).');
                    modal.style.display = 'none';
                    return;
                }
            } else {
                console.log('‚úÖ Container trouv√© dans la modal via querySelector');
            }
        }

        viewerContainer.style.display = 'block';
        document.body.style.overflow = 'hidden';

        // V√©rifier la disponibilit√© des donn√©es des √©l√®ves
        if (typeof studentsData === 'undefined' || !Array.isArray(studentsData)) {
            console.warn("studentsData non d√©fini, utilisation d'un tableau vide");
            window.studentsData = [];
        }

        // D√©truire le viewer existant s'il y en a un
        if (window.cleanPDFViewer) {
            console.log('üîÑ Destruction du viewer existant...');
            try {
                window.cleanPDFViewer.destroy();
            } catch (e) {
                console.warn('Erreur lors de la destruction du viewer:', e);
            }
            window.cleanPDFViewer = null;
        }

        try {
            console.log('üöÄ Cr√©ation du CleanPDFViewer avec blankSheetId:', sheet.id);
            window.cleanPDFViewer = new CleanPDFViewer('unified-pdf-viewer-container', {
                    blankSheetId: sheet.id,
                    lessonDate: sheet.lesson_date,
                    periodNumber: sheet.period_number,
                    classroomId: sheet.classroom_id,
                    title: sheet.title,
                    pdfUrl: null,
                    showSidebar: true,
                    enableAnnotations: true,
                    autoSaveInterval: 5000,
                    studentData: window.studentsData,
                    onClose: () => {
                        console.log('üîí Fermeture du viewer');

                        // Fermer la modal si elle existe
                        const modalToClose = document.getElementById('fileViewerModal');
                        if (modalToClose) {
                            modalToClose.style.display = 'none';
                        }

                        // Fermer le container
                        const containerToClose = document.getElementById('unified-pdf-viewer-container');
                        if (containerToClose) {
                            containerToClose.style.display = 'none';
                        }

                        document.body.style.overflow = '';
                        window.cleanPDFViewer = null;

                        // Recharger la liste des ressources pour afficher les modifications
                        loadClassResources();
                    }
                });

            console.log('‚úÖ Feuille blanche charg√©e');
        } catch (error) {
            console.error('‚ùå Erreur lors du chargement du viewer:', error);
            alert('Erreur lors du chargement du viewer: ' + error.message);
            modal.style.display = 'none';
            document.body.style.overflow = '';
            return;
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la feuille blanche:', error);
        alert('Erreur lors du chargement de la feuille blanche: ' + error.message);
    }
}

/**
 * Formate une date ISO en format lisible
 */
function formatDateTime(isoString) {
    if (!isoString) return '';
    const date = new Date(isoString);
    const options = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' };
    return date.toLocaleDateString('fr-FR', options);
}

/**
 * Supprime une feuille blanche
 */
async function deleteBlankSheet(sheetId) {
    console.log('üóëÔ∏è Suppression feuille blanche:', sheetId);

    // Confirmer la suppression
    if (!confirm('√ätes-vous s√ªr de vouloir supprimer cette feuille blanche ? Cette action est irr√©versible.')) {
        return;
    }

    try {
        const response = await fetch(`/planning/api/blank-sheets/${sheetId}`, {
            method: 'DELETE',
            headers: {'Content-Type': 'application/json'}
        });

        const data = await response.json();

        if (data.success) {
            console.log('‚úÖ Feuille blanche supprim√©e');
            // Recharger la liste des ressources
            await loadClassResources();
        } else {
            alert('Erreur lors de la suppression: ' + (data.message || 'Erreur inconnue'));
        }
    } catch (error) {
        console.error('Erreur lors de la suppression de la feuille blanche:', error);
        alert('Erreur lors de la suppression de la feuille blanche');
    }
}

// Fonction pour ouvrir le viewer avec des pages blanches (LEGACY - gard√©e pour compatibilit√©)
function openBlankPages() {
    console.log('üìÑ Ouverture du viewer avec des pages blanches');

    // Afficher la modal
    const modal = document.getElementById('fileViewerModal');
    if (!modal) {
        console.error('Modal fileViewerModal non trouv√©e');
        return;
    }

    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';

    // V√©rifier la disponibilit√© des donn√©es des √©l√®ves
    if (typeof studentsData === 'undefined' || !Array.isArray(studentsData)) {
        console.warn("studentsData non d√©fini, utilisation d'un tableau vide");
        studentsData = [];
    }

    // Afficher le container du viewer
    const viewerContainer = document.getElementById('unified-pdf-viewer-container');
    if (viewerContainer) {
        viewerContainer.style.display = 'block';
    }

    // Cr√©er un ID sp√©cial pour les pages blanches bas√© sur la le√ßon actuelle
    {% if lesson %}
    const blankPagesId = 'blank_lesson_{{ lesson.id }}';
    {% else %}
    const blankPagesId = 'blank_lesson_new';
    {% endif %}

    // Cr√©er l'instance du viewer pour pages blanches
    if (!cleanPDFViewer) {
        try {
            cleanPDFViewer = new CleanPDFViewer('unified-pdf-viewer-container', {
                fileId: blankPagesId, // ID sp√©cial pour sauvegarder les pages blanches
                pdfUrl: null, // Pas de PDF √† charger
                showSidebar: true,
                enableAnnotations: true,
                autoSaveInterval: 5000,
                studentData: studentsData,
                onClose: () => {
                    if (viewerContainer) {
                        viewerContainer.style.display = 'none';
                    }
                    cleanPDFViewer = null;
                }
            });

            console.log('‚úÖ Viewer avec pages blanches cr√©√©, ID:', blankPagesId);
        } catch (error) {
            console.error('‚ùå Erreur lors de la cr√©ation du viewer:', error);
            alert('Erreur lors de la cr√©ation du viewer: ' + error.message);
            return;
        }
    } else {
        console.warn('Le viewer est d√©j√† ouvert. Fermez-le d\'abord.');
    }
}

// Fonction modifi√©e pour ouvrir les fichiers (remplace l'ancienne fonction openFile)
function openFile(filePath, fileName, fileType) {
    console.log('üìÅ Ouverture du fichier:', fileName, 'Type:', fileType);

    if (fileType === 'pdf') {
        // Utiliser le nouveau lecteur unifi√© pour les PDF
        openFileWithUnifiedViewer(filePath, fileName);
    } else {
        // Pour les autres types de fichiers, utiliser l'ancienne m√©thode ou rediriger
        window.open(`/file_manager/serve_file/${encodeURIComponent(filePath)}`, '_blank');
    }
}

// G√©rer la fermeture avec √âchap
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const modal = document.getElementById('fileViewerModal');
        if (modal && modal.style.display === 'block') {
            closeFileViewer();
        }
    }
});

// Initialiser l'apparence des boutons au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser les boutons de retard pour tous les √©l√®ves
    {% for student in students %}
    updateAttendanceButtons({{ student.id }});
    {% endfor %}
});
</script>
{% endif %}

<!-- Modal ajout ressource -->
<div id="add-resource-modal" style="display:none;position:fixed;inset:0;z-index:10000;background:rgba(0,0,0,0.5);backdrop-filter:blur(4px);justify-content:center;align-items:center;">
    <div style="background:white;border-radius:16px;padding:1.5rem;max-width:600px;width:90%;max-height:85vh;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.3);display:flex;flex-direction:column;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;">
            <h3 style="margin:0;font-size:1.1rem;"><i class="fas fa-plus-circle" style="color:#10b981;"></i> Ajouter une ressource</h3>
            <button onclick="closeAddResourceModal()" style="background:none;border:none;cursor:pointer;font-size:1.2rem;color:#9ca3af;"><i class="fas fa-times"></i></button>
        </div>

        <!-- Onglets -->
        <div style="display:flex;gap:0.5rem;margin-bottom:1rem;border-bottom:2px solid #e5e7eb;">
            <button id="tab-files-btn" onclick="switchResourceTab('files')" style="padding:0.75rem 1rem;border:none;background:none;cursor:pointer;font-weight:600;border-bottom:3px solid #10b981;color:#10b981;transition:all 0.2s;">
                <i class="fas fa-folder-open"></i> Fichiers de classe
            </button>
            <button id="tab-exercises-btn" onclick="switchResourceTab('exercises')" style="padding:0.75rem 1rem;border:none;background:none;cursor:pointer;font-weight:600;border-bottom:3px solid transparent;color:#9ca3af;transition:all 0.2s;">
                <i class="fas fa-gamepad"></i> Exercices
            </button>
        </div>

        <!-- Contenu des onglets (scrollable) -->
        <div style="flex:1;overflow-y:auto;padding-right:0.5rem;">
            <!-- Onglet Fichiers -->
            <div id="resource-files-tab" style="display:block;">
                {% if lesson_classroom %}
                <div id="class-files-tree-container" style="min-height:100px;">
                    <div style="text-align:center;padding:2rem;color:#9ca3af;">
                        <i class="fas fa-spinner fa-spin"></i> Chargement des fichiers...
                    </div>
                </div>
                {% else %}
                <div style="text-align:center;padding:2rem;color:#9ca3af;font-style:italic;">
                    Aucune classe s√©lectionn√©e
                </div>
                {% endif %}
            </div>

            <!-- Onglet Exercices -->
            <div id="resource-exercises-tab" style="display:none;">
                {% if user_exercises %}
                <div id="exercises-list-container">
                    {% for ex in user_exercises %}
                    <div class="resource-item" onclick="addExerciseToPlanning({{ ex.id }}, '{{ ex.title|e }}')" style="padding:0.8rem;border:1px solid #e5e7eb;border-radius:10px;margin-bottom:0.5rem;cursor:pointer;transition:all 0.15s;display:flex;align-items:center;gap:0.6rem;">
                        <i class="fas fa-gamepad" style="color:#667eea;font-size:1.1rem;"></i>
                        <div style="flex:1;">
                            <div style="font-weight:600;font-size:0.85rem;">{{ ex.title }}</div>
                            <div style="font-size:0.7rem;color:#9ca3af;">{{ ex.total_points }} XP ‚Äî {{ ex.subject or 'G√©n√©ral' }}</div>
                        </div>
                        <span style="background:#f0fdf4;color:#10b981;padding:0.3rem 0.6rem;border-radius:6px;font-size:0.7rem;font-weight:600;">Non publi√©</span>
                        <i class="fas fa-plus-circle" style="color:#10b981;font-size:1rem;"></i>
                    </div>
                    {% endfor %}
                </div>
                {% else %}
                <div style="text-align:center;padding:2rem;color:#9ca3af;font-style:italic;">
                    Aucun exercice disponible
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Modal choix du mode (classique vs combat) -->
<div id="mode-modal" style="display:none;position:fixed;inset:0;z-index:10001;background:rgba(0,0,0,0.6);backdrop-filter:blur(6px);justify-content:center;align-items:center;">
    <div style="background:white;border-radius:20px;padding:1.5rem;max-width:480px;width:90%;box-shadow:0 24px 64px rgba(0,0,0,0.35);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
            <h3 style="margin:0;font-size:1.05rem;"><i class="fas fa-rocket" style="color:#667eea;"></i> Lancer l'exercice</h3>
            <button onclick="closeModeModal()" style="background:none;border:none;cursor:pointer;font-size:1.2rem;color:#9ca3af;"><i class="fas fa-times"></i></button>
        </div>
        <p id="mode-exercise-title" style="font-size:0.85rem;color:#6b7280;margin-bottom:1rem;"></p>

        <!-- Option Classique -->
        <div id="mode-classique-btn" onclick="selectMode('classique')"
             style="padding:1rem;border:2px solid #e5e7eb;border-radius:14px;margin-bottom:0.75rem;cursor:pointer;transition:all 0.2s;">
            <div style="display:flex;align-items:center;gap:0.75rem;">
                <div style="width:48px;height:48px;background:linear-gradient(135deg,#10b981,#059669);border-radius:12px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-book-open" style="color:white;font-size:1.2rem;"></i>
                </div>
                <div style="flex:1;">
                    <div style="font-weight:700;font-size:0.95rem;color:#1f2937;">Mode Classique</div>
                    <div style="font-size:0.75rem;color:#6b7280;margin-top:0.15rem;">
                        Les √©l√®ves font l'exercice √† leur rythme. Pas de suivi en direct.
                    </div>
                </div>
                <i class="fas fa-check-circle" id="mode-classique-check" style="color:#10b981;font-size:1.2rem;display:none;"></i>
            </div>
        </div>

        <!-- Option Combat -->
        <div id="mode-combat-btn" onclick="selectMode('combat')"
             style="padding:1rem;border:2px solid #e5e7eb;border-radius:14px;margin-bottom:1rem;cursor:pointer;transition:all 0.2s;">
            <div style="display:flex;align-items:center;gap:0.75rem;">
                <div style="width:48px;height:48px;background:linear-gradient(135deg,#ef4444,#dc2626);border-radius:12px;display:flex;align-items:center;justify-content:center;">
                    <i class="fas fa-bolt" style="color:white;font-size:1.2rem;"></i>
                </div>
                <div style="flex:1;">
                    <div style="font-weight:700;font-size:0.95rem;color:#1f2937;">Mode Combat</div>
                    <div style="font-size:0.75rem;color:#6b7280;margin-top:0.15rem;">
                        Mission en direct ! Suivez la progression de chaque √©l√®ve en temps r√©el.
                    </div>
                </div>
                <i class="fas fa-check-circle" id="mode-combat-check" style="color:#ef4444;font-size:1.2rem;display:none;"></i>
            </div>
        </div>

        <button id="launch-exercise-btn" onclick="launchExercise()" disabled
                style="width:100%;padding:0.75rem;border:none;border-radius:12px;font-weight:700;font-size:0.9rem;cursor:pointer;background:#d1d5db;color:white;transition:all 0.2s;">
            <i class="fas fa-play"></i> Lancer la mission
        </button>
    </div>
</div>

<!-- Modal suivi en direct (combat) -->
<div id="tracking-modal" style="display:none;position:fixed;inset:0;z-index:10002;background:rgba(15,12,41,0.95);backdrop-filter:blur(8px);overflow-y:auto;">
    <div style="max-width:700px;margin:1rem auto;padding:1rem;">
        <!-- Header -->
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;">
            <div>
                <h2 id="tracking-title" style="margin:0;color:white;font-size:1.2rem;"></h2>
                <p id="tracking-subtitle" style="margin:0;color:rgba(255,255,255,0.6);font-size:0.8rem;margin-top:0.2rem;"></p>
            </div>
            <button onclick="closeTrackingModal()" style="background:rgba(255,255,255,0.1);border:none;color:white;padding:0.5rem 0.8rem;border-radius:10px;cursor:pointer;font-size:0.85rem;">
                <i class="fas fa-times"></i> Fermer
            </button>
        </div>

        <!-- Stats r√©sum√© -->
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:0.5rem;margin-bottom:1rem;">
            <div style="background:rgba(255,255,255,0.08);border-radius:12px;padding:0.75rem;text-align:center;">
                <div id="track-total" style="color:white;font-size:1.5rem;font-weight:800;">0</div>
                <div style="color:rgba(255,255,255,0.5);font-size:0.7rem;">√âl√®ves</div>
            </div>
            <div style="background:rgba(255,255,255,0.08);border-radius:12px;padding:0.75rem;text-align:center;">
                <div id="track-started" style="color:#f59e0b;font-size:1.5rem;font-weight:800;">0</div>
                <div style="color:rgba(255,255,255,0.5);font-size:0.7rem;">En cours</div>
            </div>
            <div style="background:rgba(255,255,255,0.08);border-radius:12px;padding:0.75rem;text-align:center;">
                <div id="track-completed" style="color:#10b981;font-size:1.5rem;font-weight:800;">0</div>
                <div style="color:rgba(255,255,255,0.5);font-size:0.7rem;">Termin√©</div>
            </div>
            <div style="background:rgba(255,255,255,0.08);border-radius:12px;padding:0.75rem;text-align:center;">
                <div id="track-avg" style="color:#667eea;font-size:1.5rem;font-weight:800;">‚Äî</div>
                <div style="color:rgba(255,255,255,0.5);font-size:0.7rem;">Moyenne</div>
            </div>
        </div>

        <!-- Liste des √©l√®ves -->
        <div id="tracking-students" style="display:flex;flex-direction:column;gap:0.5rem;"></div>

        <!-- Bouton arr√™ter -->
        <div style="text-align:center;margin-top:1.5rem;">
            <button id="stop-mission-btn" onclick="stopMission()" style="background:linear-gradient(135deg,#ef4444,#dc2626);color:white;border:none;padding:0.6rem 1.5rem;border-radius:10px;font-weight:700;cursor:pointer;font-size:0.85rem;">
                <i class="fas fa-stop-circle"></i> Arr√™ter la mission
            </button>
        </div>
    </div>
</div>

<script>
// ============================================================
// Ajout ressource (NOUVEAU SYST√àME)
// ============================================================
function showAddResourceModal() {
    document.getElementById('add-resource-modal').style.display = 'flex';
    // Initialiser sur l'onglet des fichiers
    switchResourceTab('files');
    {% if lesson_classroom %}
    loadClassFilesTree({{ lesson_classroom.id }});
    {% endif %}
}

function closeAddResourceModal() {
    document.getElementById('add-resource-modal').style.display = 'none';
}

function switchResourceTab(tabName) {
    // Masquer tous les onglets
    document.getElementById('resource-files-tab').style.display = 'none';
    document.getElementById('resource-exercises-tab').style.display = 'none';

    // R√©initialiser les styles des boutons
    document.getElementById('tab-files-btn').style.borderBottomColor = 'transparent';
    document.getElementById('tab-files-btn').style.color = '#9ca3af';
    document.getElementById('tab-exercises-btn').style.borderBottomColor = 'transparent';
    document.getElementById('tab-exercises-btn').style.color = '#9ca3af';

    // Afficher l'onglet demand√© et modifier le style du bouton
    if (tabName === 'files') {
        document.getElementById('resource-files-tab').style.display = 'block';
        document.getElementById('tab-files-btn').style.borderBottomColor = '#10b981';
        document.getElementById('tab-files-btn').style.color = '#10b981';
    } else {
        document.getElementById('resource-exercises-tab').style.display = 'block';
        document.getElementById('tab-exercises-btn').style.borderBottomColor = '#667eea';
        document.getElementById('tab-exercises-btn').style.color = '#667eea';
    }
}

{% if lesson_classroom %}
async function loadClassFilesTree(classroomId) {
    const container = document.getElementById('class-files-tree-container');
    try {
        const res = await fetch(`/planning/get-class-resources/${classroomId}`);
        const data = await res.json();

        if (data.success) {
            // Combiner fichiers √©pingl√©s et normaux
            const allFiles = [...(data.pinned_files || []), ...(data.files || [])];

            if (allFiles.length > 0) {
                // Organiser par dossiers
                const filesByFolder = {};
                allFiles.forEach(file => {
                    const folder = file.folder_path || 'Racine';
                    if (!filesByFolder[folder]) {
                        filesByFolder[folder] = [];
                    }
                    filesByFolder[folder].push(file);
                });

                // Cr√©er l'HTML de l'arborescence
                let html = '';
                Object.keys(filesByFolder).sort().forEach(folder => {
                    html += `<div style="margin-bottom:1rem;">
                        <div style="font-weight:600;font-size:0.85rem;color:#374151;padding:0.5rem 0;border-bottom:1px solid #e5e7eb;margin-bottom:0.5rem;">
                            <i class="fas fa-folder" style="color:#f59e0b;margin-right:0.3rem;"></i> ${folder}
                        </div>`;

                    filesByFolder[folder].forEach(file => {
                        const icon = getFileIcon(file.file_type);
                        const iconColor = getFileIconColor(file.file_type);
                        html += `<div onclick="addFileResourceToPlanning(${file.id}, '${file.original_filename.replace(/'/g, "\\'")}', '${file.file_type}')" style="padding:0.6rem 0.8rem;border:1px solid #e5e7eb;border-radius:8px;margin-bottom:0.4rem;cursor:pointer;transition:all 0.15s;display:flex;align-items:center;gap:0.6rem;hover:background:#f9fafb;">
                            <i class="fas fa-${icon}" style="color:${iconColor};"></i>
                            <div style="flex:1;min-width:0;">
                                <div style="font-weight:500;font-size:0.85rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${file.original_filename}</div>
                            </div>
                            <i class="fas fa-plus-circle" style="color:#10b981;font-size:1rem;flex-shrink:0;"></i>
                        </div>`;
                    });
                    html += '</div>';
                });
                container.innerHTML = html;
            } else {
                container.innerHTML = '<div style="text-align:center;padding:2rem;color:#9ca3af;font-style:italic;">Aucun fichier dans cette classe</div>';
            }
        } else {
            container.innerHTML = '<div style="text-align:center;padding:2rem;color:#ef4444;">Erreur de chargement</div>';
        }
    } catch(e) {
        container.innerHTML = '<div style="text-align:center;padding:2rem;color:#ef4444;">Erreur de chargement: ' + e.message + '</div>';
        console.error('Erreur loadClassFilesTree:', e);
    }
}

function getFileIcon(fileType) {
    if (!fileType) return 'file';
    if (fileType === 'pdf') return 'file-pdf';
    if (fileType.match(/png|jpg|jpeg|gif/)) return 'file-image';
    if (fileType.match(/doc|docx|txt/)) return 'file-word';
    return 'file';
}

function getFileIconColor(fileType) {
    if (!fileType) return '#6b7280';
    if (fileType === 'pdf') return '#dc2626';
    if (fileType.match(/png|jpg|jpeg|gif/)) return '#3b82f6';
    if (fileType.match(/doc|docx|txt/)) return '#2563eb';
    return '#6b7280';
}

async function addFileResourceToPlanning(fileId, fileName, fileType) {
    const planningId = {{ planning.id if planning else 'null' }};

    if (!planningId) {
        alert('Veuillez d\'abord cr√©er une planification');
        return;
    }

    try {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';
        const res = await fetch('/planning/add-resource', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({
                planning_id: planningId,
                resource_type: 'file',
                resource_id: fileId,
                display_name: fileName,
                file_type: fileType
            }),
        });
        const data = await res.json();

        if (data.success) {
            // Recharger la vue de planification
            location.reload();
        } else {
            alert(data.error || data.message || 'Erreur lors de l\'ajout du fichier');
        }
    } catch(e) {
        alert('Erreur de connexion');
        console.error('Erreur addFileResourceToPlanning:', e);
    }
}
{% endif %}

async function addExerciseToPlanning(exerciseId, exerciseTitle) {
    const planningId = {{ planning.id if planning else 'null' }};

    if (!planningId) {
        alert('Veuillez d\'abord cr√©er une planification');
        return;
    }

    try {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';
        const res = await fetch('/planning/add-resource', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
            body: JSON.stringify({
                planning_id: planningId,
                resource_type: 'exercise',
                resource_id: exerciseId,
                display_name: exerciseTitle
            }),
        });
        const data = await res.json();

        if (data.success) {
            // Recharger la vue de planification
            location.reload();
        } else {
            alert(data.error || data.message || 'Erreur lors de l\'ajout de l\'exercice');
        }
    } catch(e) {
        alert('Erreur de connexion');
        console.error('Erreur addExerciseToPlanning:', e);
    }
}

// ============================================================
// Mode selection (classique vs combat)
// ============================================================
let selectedExerciseId = null;
let selectedExerciseTitle = '';
let selectedMode = null;
let selectedPlanningResourceId = null;  // Pour tracker si on publie depuis la planification
let modeModalContext = 'add';  // 'add' (ajout via modal) ou 'publish' (depuis la planification)

function showModeModal(exerciseId, title, context = 'add', resourceId = null) {
    selectedExerciseId = exerciseId;
    selectedExerciseTitle = title;
    selectedMode = null;
    modeModalContext = context;
    selectedPlanningResourceId = resourceId;
    document.getElementById('mode-exercise-title').textContent = title;
    document.getElementById('mode-classique-check').style.display = 'none';
    document.getElementById('mode-combat-check').style.display = 'none';
    document.getElementById('mode-classique-btn').style.borderColor = '#e5e7eb';
    document.getElementById('mode-combat-btn').style.borderColor = '#e5e7eb';
    const btn = document.getElementById('launch-exercise-btn');
    btn.disabled = true;
    btn.style.background = '#d1d5db';
    document.getElementById('mode-modal').style.display = 'flex';
}

function closeModeModal() {
    document.getElementById('mode-modal').style.display = 'none';
}

function selectMode(mode) {
    selectedMode = mode;
    const classiqueCheck = document.getElementById('mode-classique-check');
    const combatCheck = document.getElementById('mode-combat-check');
    const classiqueBtn = document.getElementById('mode-classique-btn');
    const combatBtn = document.getElementById('mode-combat-btn');
    const launchBtn = document.getElementById('launch-exercise-btn');

    classiqueCheck.style.display = 'none';
    combatCheck.style.display = 'none';
    classiqueBtn.style.borderColor = '#e5e7eb';
    combatBtn.style.borderColor = '#e5e7eb';

    if (mode === 'classique') {
        classiqueCheck.style.display = 'inline';
        classiqueBtn.style.borderColor = '#10b981';
        classiqueBtn.style.background = '#f0fdf4';
        combatBtn.style.background = 'white';
        launchBtn.style.background = 'linear-gradient(135deg,#10b981,#059669)';
        launchBtn.innerHTML = modeModalContext === 'publish' ? '<i class="fas fa-play"></i> Publier et lancer' : '<i class="fas fa-plus"></i> Ajouter en mode classique';
    } else {
        combatCheck.style.display = 'inline';
        combatBtn.style.borderColor = '#ef4444';
        combatBtn.style.background = '#fef2f2';
        classiqueBtn.style.background = 'white';
        launchBtn.style.background = 'linear-gradient(135deg,#ef4444,#dc2626)';
        launchBtn.innerHTML = '<i class="fas fa-bolt"></i> Lancer le combat !';
    }
    launchBtn.disabled = false;
}

async function launchExercise() {
    if (!selectedExerciseId || !selectedMode) return;

    const launchBtn = document.getElementById('launch-exercise-btn');
    launchBtn.disabled = true;
    launchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Lancement...';

    try {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';

        // Si on publie depuis la planification (exercice d√©j√† li√©)
        if (modeModalContext === 'publish' && selectedPlanningResourceId) {
            const res = await fetch('/planning/publish-resource', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({
                    resource_id: selectedPlanningResourceId,
                    exercise_id: selectedExerciseId,
                    classroom_id: {{ lesson_classroom.id if lesson_classroom else 'null' }},
                    mode: selectedMode,
                }),
            });
            const data = await res.json();

            if (data.success) {
                closeModeModal();

                if (selectedMode === 'combat') {
                    openTracking(data.publication_id);
                } else {
                    alert(`Exercice "${selectedExerciseTitle}" publi√© en mode classique !`);
                    location.reload();
                }
            } else {
                alert(data.error || data.message || 'Erreur lors de la publication');
                launchBtn.disabled = false;
                launchBtn.innerHTML = '<i class="fas fa-play"></i> R√©essayer';
            }
        } else {
            // Ancien comportement: ajouter et publier imm√©diatement (via add-resource modal)
            const res = await fetch('/exercises/launch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify({
                    exercise_id: selectedExerciseId,
                    classroom_id: {{ lesson_classroom.id if lesson_classroom else 'null' }},
                    mode: selectedMode,
                }),
            });
            const data = await res.json();

            if (data.success) {
                // Ajouter le lien dans la description
                const descEl = document.getElementById('planningDescriptionDisplay');
                if (descEl) {
                    const link = document.createElement('div');
                    const modeLabel = selectedMode === 'combat' ? '‚öîÔ∏è Combat' : 'üìñ Classique';
                    const modeColor = selectedMode === 'combat' ? '#fef2f2;border:1px solid #fecaca' : '#eef2ff;border:1px solid #c7d2fe';
                    link.style.cssText = `margin-top:0.5rem;padding:0.5rem 0.8rem;background:${modeColor};border-radius:8px;display:flex;align-items:center;justify-content:space-between;`;
                    link.innerHTML = `
                        <span><i class="fas fa-gamepad" style="color:#667eea;"></i> <strong>${selectedExerciseTitle}</strong>
                        <span style="font-size:0.7rem;padding:0.1rem 0.4rem;border-radius:6px;background:${selectedMode==='combat'?'#ef4444':'#10b981'};color:white;margin-left:0.3rem;">${modeLabel}</span></span>
                        ${selectedMode === 'combat' ? `<button onclick="openTracking(${data.publication_id})" style="background:#667eea;color:white;border:none;padding:0.3rem 0.6rem;border-radius:8px;cursor:pointer;font-size:0.75rem;font-weight:600;"><i class="fas fa-eye"></i> Suivi live</button>` : ''}
                    `;
                    descEl.appendChild(link);
                }

                closeModeModal();
                closeAddResourceModal();

                if (selectedMode === 'combat') {
                    // Ouvrir directement le suivi live
                    openTracking(data.publication_id);
                } else {
                    alert(`Exercice "${selectedExerciseTitle}" publi√© en mode classique !`);
                }
            } else {
                alert(data.error || data.message || 'Erreur lors du lancement');
                launchBtn.disabled = false;
                launchBtn.innerHTML = '<i class="fas fa-play"></i> R√©essayer';
            }
        }
    } catch(e) {
        alert('Erreur de connexion');
        launchBtn.disabled = false;
        launchBtn.innerHTML = '<i class="fas fa-play"></i> R√©essayer';
        console.error('Erreur launchExercise:', e);
    }
}

// ============================================================
// Ouverture des ressources de fichier
// ============================================================
function openResourceFile(fileId, fileName) {
    // Ouvrir le fichier dans le visualiseur PDF int√©gr√© ou dans un nouvel onglet
    window.open(`/file_manager/preview/${fileId}`, '_blank');
}

async function deleteResource(resourceId, btn) {
    if (!confirm('Supprimer cette ressource de la planification ?')) return;
    try {
        const res = await fetch('/planning/delete-resource', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ resource_id: resourceId })
        });
        const data = await res.json();
        if (data.success) {
            const item = btn.closest('.planning-resource-item');
            if (item) item.remove();
            // Si plus de ressources, masquer la section
            const list = document.getElementById('planning-resources-list');
            if (list && list.children.length === 0) {
                const section = document.getElementById('planning-resources-section');
                if (section) section.remove();
            }
        } else {
            alert(data.error || 'Erreur lors de la suppression');
        }
    } catch (e) {
        alert('Erreur de connexion');
    }
}

// ============================================================
// Suivi en direct (tracking modal)
// ============================================================
let trackingInterval = null;
let currentPubId = null;

function openTracking(pubId) {
    currentPubId = pubId;
    document.getElementById('tracking-modal').style.display = 'block';
    refreshTracking();
    // Rafra√Æchir toutes les 4 secondes
    trackingInterval = setInterval(refreshTracking, 4000);
}

function closeTrackingModal() {
    document.getElementById('tracking-modal').style.display = 'none';
    if (trackingInterval) {
        clearInterval(trackingInterval);
        trackingInterval = null;
    }
}

async function refreshTracking() {
    if (!currentPubId) return;
    try {
        const res = await fetch(`/exercises/publication/${currentPubId}/live-tracking`);
        const data = await res.json();
        if (!data.success) return;

        document.getElementById('tracking-title').textContent = data.exercise_title;
        document.getElementById('tracking-subtitle').textContent = `${data.blocks_count} questions ‚Äî Mode ${data.mode}`;
        document.getElementById('track-total').textContent = data.total_students;
        document.getElementById('track-started').textContent = data.started;
        document.getElementById('track-completed').textContent = data.completed;
        document.getElementById('track-avg').textContent = data.completed > 0 ? data.average_score + '%' : '‚Äî';

        const container = document.getElementById('tracking-students');
        container.innerHTML = data.students.map(s => {
            let statusIcon, statusColor, statusText, progressWidth;
            if (s.status === 'completed') {
                statusIcon = 'check-circle';
                statusColor = '#10b981';
                statusText = `${s.score_percentage}%`;
                progressWidth = 100;
            } else if (s.status === 'in_progress') {
                statusIcon = 'spinner fa-pulse';
                statusColor = '#f59e0b';
                const pct = s.blocks_count > 0 ? Math.round((s.answers_count / s.blocks_count) * 100) : 0;
                statusText = `${s.answers_count}/${s.blocks_count}`;
                progressWidth = pct;
            } else {
                statusIcon = 'clock';
                statusColor = '#6b7280';
                statusText = 'En attente';
                progressWidth = 0;
            }

            return `
                <div style="background:rgba(255,255,255,0.06);border-radius:12px;padding:0.65rem 0.8rem;display:flex;align-items:center;gap:0.6rem;">
                    <i class="fas fa-${statusIcon}" style="color:${statusColor};font-size:1rem;width:20px;text-align:center;"></i>
                    <div style="flex:1;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.3rem;">
                            <span style="color:white;font-weight:600;font-size:0.85rem;">${s.name}</span>
                            <span style="color:${statusColor};font-weight:700;font-size:0.8rem;">${statusText}</span>
                        </div>
                        <div style="width:100%;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;">
                            <div style="width:${progressWidth}%;height:100%;background:${statusColor};border-radius:2px;transition:width 0.5s ease;"></div>
                        </div>
                        ${s.status === 'completed' ? `<div style="font-size:0.7rem;color:rgba(255,255,255,0.4);margin-top:0.2rem;">+${s.xp_earned} XP ‚Äî ${s.correct_count}/${s.blocks_count} correct</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');

    } catch(e) {
        console.error('Erreur tracking:', e);
    }
}

async function stopMission() {
    if (!currentPubId) return;
    if (!confirm('Arr√™ter la mission en direct ?')) return;

    try {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || '';
        await fetch(`/exercises/publication/${currentPubId}/toggle-active`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
        });
        closeTrackingModal();
    } catch(e) {
        alert('Erreur');
    }
}
</script>
{% endblock %}
