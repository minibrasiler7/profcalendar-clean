{% extends "base.html" %}

{% block title %}{% if is_current %}Leçon en cours{% else %}Prochain cours{% endif %} - TeacherPlanner{% endblock %}

{% block extra_css %}
<!-- PDF.js pour l'affichage des PDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<!-- Font Awesome pour les icônes -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!-- Lecteur PDF unifié -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/unified-pdf-viewer.css') }}">
<script>
// Configuration du worker PDF.js
if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    console.log('PDF.js worker configuré');
}
</script>
<style>
.lesson-container {
    max-width: 1400px;
    margin: 0 auto;
    padding-bottom: 2rem;
    min-height: calc(100vh - 200px);
}

.lesson-header {
    background-color: var(--white);
    padding: 1.5rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-bottom: 1.5rem;
}

.lesson-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.lesson-title h1 {
    margin: 0;
    font-size: 1.75rem;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.lesson-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 9999px;
    font-size: 0.875rem;
    font-weight: 500;
}

.lesson-badge.current {
    background-color: #FEF3C7;
    color: #92400E;
}

.lesson-badge.next {
    background-color: #DBEAFE;
    color: #1E40AF;
}

.lesson-details {
    display: flex;
    gap: 2rem;
    margin-top: 0.5rem;
    color: var(--gray-color);
}

.lesson-detail {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.lesson-main {
    display: grid;
    grid-template-columns: 1.5fr 1fr 1fr;
    gap: 1.5rem;
    min-height: 500px;
    margin-bottom: 2rem;
    transition: all 0.3s ease;
}

/* Dispositions alternatives - Focus Planification = 50% gauche, autres empilées à droite */
.lesson-main.layout-planning-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning attendance"
        "planning resources" !important;
}

.lesson-main.layout-planning-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-planning-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-planning-focus .resources-section {
    grid-area: resources;
}

/* Focus Présences = 50% droite, autres empilées à gauche */
.lesson-main.layout-attendance-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning attendance"
        "resources attendance" !important;
}

.lesson-main.layout-attendance-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-attendance-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-attendance-focus .resources-section {
    grid-area: resources;
}

/* Focus Ressources = 50% droite, autres empilées à gauche */
.lesson-main.layout-resources-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning resources"
        "attendance resources" !important;
}

.lesson-main.layout-resources-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-resources-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-resources-focus .resources-section {
    grid-area: resources;
}

/* Effets visuels discrets pour les sections focus */
.lesson-main.layout-planning-focus .planning-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-resources-focus .resources-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-attendance-focus .attendance-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-vertical {
    grid-template-columns: 1fr;
    gap: 1rem;
}

.lesson-main.layout-vertical .planning-section {
    order: 1;
}

.lesson-main.layout-vertical .resources-section {
    order: 2;
}

.lesson-main.layout-vertical .attendance-section {
    order: 3;
}

.planning-section, .resources-section, .attendance-section {
    background-color: var(--white);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    min-height: 400px;
    height: auto;
    transition: all 0.3s ease;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--light-gray);
}

.section-title {
    font-size: 1.25rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.planning-content {
    flex: 1;
    overflow-y: auto;
}

.planning-item {
    margin-bottom: 2rem;
}

.planning-item h3 {
    color: var(--primary-color);
    margin-bottom: 0.5rem;
    font-size: 1.125rem;
}

.planning-description {
    color: var(--gray-color);
    line-height: 1.6;
    white-space: pre-wrap;
}

/* Style spécifique pour les checkboxes dans la description de planification */
.planning-description .checkbox-item {
    margin: 0.125rem 0;
}

.planning-description > div:not(.checkbox-item) {
    margin: 0.25rem 0;
}

/* Styles pour les checkboxes dans la planification */
.planning-checklist-item, .checkbox-item {
    display: flex;
    align-items: flex-start;
    gap: 0.5rem;
    margin: 0.25rem 0;
    min-height: 1.5rem;
}

.planning-checkbox {
    margin-top: 0.125rem;
    cursor: pointer;
    width: 1rem;
    height: 1rem;
}

.planning-checkbox-label {
    flex: 1;
    cursor: pointer;
    user-select: none;
    line-height: 1.4;
    padding-left: 0.125rem;
}

.planning-checkbox:checked + .planning-checkbox-label {
    text-decoration: line-through;
    opacity: 0.7;
}

#planningDescription {
    font-family: monospace;
    tab-size: 4;
}

.checklist-help {
    font-size: 0.75rem;
    color: var(--gray-color);
    margin-top: 0.5rem;
    font-style: italic;
}

.resources-content {
    flex: 1;
    overflow-y: auto;
}

.no-resources {
    text-align: center;
    padding: 3rem;
    color: var(--gray-color);
}

.no-resources i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

/* Styles pour les onglets de suivi */
.tracking-tabs {
    display: flex;
    border-bottom: 2px solid var(--light-gray);
    margin-bottom: 1.5rem;
}

.tracking-tab {
    padding: 0.75rem 1.5rem;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    color: var(--gray-color);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.tracking-tab:hover {
    color: var(--primary-color);
}

.tracking-tab.active {
    color: var(--primary-color);
    border-bottom-color: var(--primary-color);
}

.tracking-content {
    display: none;
}

.tracking-content.active {
    display: block;
}

/* Styles pour la section présences */
.attendance-content {
    flex: 1;
    overflow-y: auto;
}

.attendance-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.stat-item {
    text-align: center;
    padding: 0.5rem;
    border-radius: 0.375rem;
    background-color: var(--light-gray);
}

.stat-item.present {
    background-color: #D1FAE5;
    color: #065F46;
}

.stat-item.absent {
    background-color: #FEE2E2;
    color: #991B1B;
}

.stat-item.late {
    background-color: #FEF3C7;
    color: #92400E;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 700;
}

.stat-label {
    font-size: 0.75rem;
}

.students-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.student-attendance {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    border-radius: 0.375rem;
    background-color: var(--light-gray);
    transition: all 0.2s ease;
}

.student-attendance.present {
    background-color: #D1FAE5;
}

.student-attendance.absent {
    background-color: #FEE2E2;
}

.student-attendance.late {
    background-color: #FEF3C7;
}

.student-info {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    user-select: none;
}

.student-avatar {
    width: 32px;
    height: 32px;
    background-color: var(--primary-color);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
}

.student-attendance.absent .student-avatar {
    background-color: var(--danger-color);
}

.student-attendance.late .student-avatar {
    background-color: var(--warning-color);
}

.student-name {
    font-weight: 500;
}

.student-name-container {
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
}

.student-accommodations {
    display: flex;
    gap: 0.25rem;
    flex-wrap: wrap;
}

.accommodation-emoji {
    font-size: 0.875rem;
}

.accommodation-name {
    font-size: 0.75rem;
    color: #6b7280;
    font-style: italic;
}

.student-attendance.absent .student-name {
    color: var(--danger-color);
    text-decoration: line-through;
}

.student-attendance.late .student-name {
    color: var(--warning-color);
}

.late-controls {
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.late-minutes {
    width: 60px;
    padding: 0.25rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    text-align: center;
}

.late-minutes:focus {
    outline: none;
    border-color: var(--warning-color);
}

.btn-late {
    width: 32px;
    height: 32px;
    border: none;
    background-color: #F3F4F6;
    color: var(--gray-color);
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.btn-late:hover {
    background-color: var(--warning-color);
    color: white;
}

.student-attendance.late .btn-late {
    background-color: var(--warning-color);
    color: white;
}

/* Styles pour les sanctions */
.sanctions-content {
    flex: 1;
    overflow-y: auto;
}

.sanctions-table-container {
    overflow-x: auto;
    border-radius: var(--border-radius);
    border: 1px solid var(--light-gray);
    background-color: var(--white);
}

.sanctions-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
}

.sanctions-table th {
    background-color: var(--light-gray);
    padding: 0.75rem;
    text-align: center;
    font-weight: 600;
    color: var(--dark-color);
    border-bottom: 2px solid var(--primary-color);
    position: sticky;
    top: 0;
    z-index: 1;
    font-size: 0.875rem;
}

.sanctions-table th.student-column {
    text-align: left;
    min-width: 150px;
    max-width: 150px;
}

.sanctions-table th.sanction-column {
    min-width: 100px;
}

.sanctions-table td {
    padding: 0.5rem;
    border-bottom: 1px solid var(--light-gray);
    vertical-align: middle;
}

.sanctions-table tr:hover {
    background-color: #F9FAFB;
}

.student-name {
    font-weight: 500;
    color: var(--dark-color);
    text-align: left;
    font-size: 0.875rem;
}

.sanction-count {
    text-align: center;
}

.count-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
}

.count-btn {
    width: 24px;
    height: 24px;
    border: 1px solid var(--light-gray);
    background-color: var(--white);
    color: var(--gray-color);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.625rem;
    transition: all 0.2s ease;
}

.count-btn:hover {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    transform: scale(1.1);
}

.count-btn.decrease:hover {
    background-color: var(--danger-color);
    border-color: var(--danger-color);
}

.count-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.count-display {
    font-weight: 600;
    font-size: 0.875rem;
    min-width: 24px;
    text-align: center;
    color: var(--dark-color);
    padding: 0.125rem 0.25rem;
    border-radius: var(--border-radius);
    background-color: var(--light-gray);
}

.count-display.warning {
    background-color: #FEF3C7;
    color: #92400E;
}

.count-display.danger {
    background-color: #FEE2E2;
    color: #991B1B;
}

.lesson-controls {
    display: flex;
    align-items: center;
    gap: 2rem;
}

.layout-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.layout-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--gray-color);
}

.layout-buttons {
    display: flex;
    gap: 0.25rem;
    background-color: var(--light-gray);
    padding: 0.25rem;
    border-radius: 0.5rem;
}

.layout-btn {
    width: 40px;
    height: 40px;
    border: none;
    background-color: transparent;
    color: var(--gray-color);
    border-radius: 0.375rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 1rem;
}

.layout-btn:hover {
    background-color: var(--white);
    color: var(--primary-color);
    transform: scale(1.05);
}

.layout-btn.active {
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
}

.timer-widget {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 1.5rem;
    background-color: var(--light-gray);
    border-radius: var(--border-radius);
}

.timer-display {
    font-size: 1.5rem;
    font-weight: 600;
    font-family: monospace;
}

.timer-controls {
    display: flex;
    gap: 0.5rem;
}

.timer-btn {
    width: 36px;
    height: 36px;
    border: none;
    background-color: var(--white);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timer-btn:hover {
    transform: scale(1.1);
    box-shadow: var(--shadow-sm);
}

/* Indicateur de sauvegarde */
.saving-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background-color: #3B82F6;
    color: white;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    display: none;
    align-items: center;
    gap: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.saving-indicator.show {
    display: flex;
}

.saving-indicator.success {
    background-color: #10B981;
}

.saving-indicator.error {
    background-color: #EF4444;
}

@media (max-width: 900px) {
    .lesson-main,
    .lesson-main.layout-planning-focus,
    .lesson-main.layout-resources-focus,
    .lesson-main.layout-attendance-focus {
        grid-template-columns: 1fr !important;
        gap: 1rem;
    }
}

@media (min-width: 901px) and (max-width: 1200px) {
    .lesson-main {
        grid-template-columns: 1fr 1fr 1fr;
    }
    
    .lesson-main.layout-planning-focus {
        grid-template-columns: 2fr 1fr 1fr !important;
    }

    .lesson-main.layout-resources-focus {
        grid-template-columns: 1fr 2fr 1fr !important;
    }

    .lesson-main.layout-attendance-focus {
        grid-template-columns: 1fr 1fr 2fr !important;
    }
}

@media (max-width: 1200px) {
    .lesson-container {
        min-height: auto;
        padding-bottom: 2rem;
    }

    .planning-section, .resources-section, .attendance-section, .seating-plan-section {
        min-height: 300px;
    }
    
    .lesson-controls {
        flex-direction: column;
        gap: 1rem;
        align-items: flex-start;
    }
    
    .layout-controls {
        width: 100%;
        justify-content: space-between;
    }
    
    .layout-buttons {
        flex-wrap: wrap;
    }
}

@media (max-width: 768px) {
    .layout-label {
        display: none;
    }
    
    .layout-btn {
        width: 36px;
        height: 36px;
        font-size: 0.875rem;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="lesson-container">
    <!-- En-tête de la leçon -->
    <div class="lesson-header">
        <div class="lesson-info">
            <div>
                <div class="lesson-title">
                    <h1>
                        {% if is_current %}
                        <span class="lesson-badge current">
                            <i class="fas fa-circle"></i> En cours
                        </span>
                        {% else %}
                        <span class="lesson-badge next">
                            <i class="fas fa-clock"></i> Prochain cours
                        </span>
                        {% endif %}
                        {% if lesson.classroom_id %}
                    {{ lesson.classroom.name }} - {{ lesson.classroom.subject }}
                {% elif lesson.mixed_group_id %}
                    {{ lesson.mixed_group.name }} - {{ lesson.mixed_group.subject }}
                {% else %}
                    Cours non défini
                {% endif %}
                    </h1>
                </div>
                <div class="lesson-details">
                    <div class="lesson-detail">
                        <i class="fas fa-calendar"></i>
                        <span>
                            {% set day_names = {
                                'Monday': 'Lundi',
                                'Tuesday': 'Mardi', 
                                'Wednesday': 'Mercredi',
                                'Thursday': 'Jeudi',
                                'Friday': 'Vendredi',
                                'Saturday': 'Samedi',
                                'Sunday': 'Dimanche'
                            } %}
                            {% set month_names = {
                                'January': 'janvier',
                                'February': 'février',
                                'March': 'mars',
                                'April': 'avril',
                                'May': 'mai',
                                'June': 'juin',
                                'July': 'juillet',
                                'August': 'août',
                                'September': 'septembre',
                                'October': 'octobre',
                                'November': 'novembre',
                                'December': 'décembre'
                            } %}
                            {{ day_names[lesson_date.strftime('%A')] }} {{ lesson_date.strftime('%d') }} {{ month_names[lesson_date.strftime('%B')] }} {{ lesson_date.strftime('%Y') }}
                        </span>
                    </div>
                    <div class="lesson-detail">
                        <i class="fas fa-clock"></i>
                        <span>Période {{ lesson.period_number }} ({{ lesson.start_time.strftime('%H:%M') }} - {{ lesson.end_time.strftime('%H:%M') }})</span>
                    </div>
                </div>
            </div>

            <div class="lesson-controls">
                <!-- Contrôles de disposition -->
                <div class="layout-controls">
                    <span class="layout-label">Disposition :</span>
                    <div class="layout-buttons">
                        <button class="layout-btn active" data-layout="default" title="Disposition par défaut (3 colonnes)">
                            <i class="fas fa-columns"></i>
                        </button>
                        <button class="layout-btn" data-layout="planning-focus" title="Focus planification (planification large)">
                            <i class="fas fa-list-alt"></i>
                        </button>
                        <button class="layout-btn" data-layout="resources-focus" title="Focus ressources (ressources large)">
                            <i class="fas fa-folder-open"></i>
                        </button>
                        <button class="layout-btn" data-layout="attendance-focus" title="Focus présences (présences large)">
                            <i class="fas fa-user-check"></i>
                        </button>
                        <button class="layout-btn" data-layout="vertical" title="Disposition verticale (1 colonne)">
                            <i class="fas fa-bars"></i>
                        </button>
                    </div>
                </div>
                
                {% if is_current %}
                <div class="timer-widget">
                    <div class="timer-display" id="lessonTimer">{{ time_remaining }}</div>
                    <div class="timer-controls">
                        <button class="timer-btn" onclick="toggleTimer()" title="Pause/Reprendre">
                            <i class="fas fa-pause" id="timerIcon"></i>
                        </button>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Contenu principal -->
    <div class="lesson-main">
        <!-- Section planification -->
        <div class="planning-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-clipboard-list"></i> Planification du cours
                </h2>
                <button class="edit-planning-btn" onclick="togglePlanningEdit()">
                    <i class="fas fa-edit"></i> <span id="editBtnText">Modifier</span>
                </button>
            </div>

            <div class="planning-content">
                <!-- Vue de lecture -->
                <div id="planningView" {% if not planning %}style="display: none;"{% endif %}>
                    <div class="planning-item">
                        <h3 id="planningTitleDisplay">{{ planning.title if planning else 'Cours sans titre' }}</h3>
                        <div class="planning-description" id="planningDescriptionDisplay">
                            {% if planning %}
                                {{ render_planning_with_checkboxes(planning) | safe }}
                            {% else %}
                                Aucune description
                            {% endif %}
                        </div>
                    </div>
                </div>

                <!-- Formulaire d'édition -->
                <div id="planningEdit" style="display: none;">
                    <form id="planningForm" onsubmit="savePlanning(event)">
                        <div class="form-group">
                            <label class="form-label">Titre du cours</label>
                            <input type="text"
                                   id="planningTitle"
                                   class="form-control"
                                   placeholder="Ex: Introduction aux fractions"
                                   value="{{ planning.title if planning else '' }}">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Description détaillée</label>
                            <textarea id="planningDescription"
                                      class="form-control"
                                      rows="8"
                                      placeholder="Objectifs du cours, activités prévues, exercices, devoirs...">{{ planning.description if planning else '' }}</textarea>
                            <div class="checklist-help">
                                Astuce : Commencez une ligne par "-" pour créer une case à cocher
                            </div>
                        </div>

                        <div class="form-actions">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Enregistrer
                            </button>
                            <button type="button" class="btn btn-outline" onclick="cancelPlanningEdit()">
                                Annuler
                            </button>
                        </div>
                    </form>
                </div>

                <!-- État vide -->
                {% if not planning %}
                <div id="emptyPlanning" class="no-resources">
                    <i class="fas fa-clipboard"></i>
                    <p>Aucune planification pour ce cours</p>
                    <button class="btn btn-primary" onclick="togglePlanningEdit()">
                        <i class="fas fa-plus"></i> Créer une planification
                    </button>
                </div>
                {% endif %}
            </div>
        </div>


        <!-- Section présences -->
        <div class="attendance-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-user-check"></i> Suivi des élèves
                </h2>
            </div>

            <!-- Onglets de suivi -->
            <div class="tracking-tabs">
                <button class="tracking-tab active" onclick="showTrackingTab('attendance')">
                    <i class="fas fa-user-check"></i> Présences
                </button>
                {% if imported_sanctions %}
                <button class="tracking-tab" onclick="showTrackingTab('sanctions')">
                    <i class="fas fa-exclamation-triangle"></i> Coches ({{ imported_sanctions|length }})
                </button>
                {% endif %}
                {% if seating_plan %}
                <button class="tracking-tab" onclick="showTrackingTab('seating-plan')">
                    <i class="fas fa-th"></i> Plan de classe
                </button>
                {% endif %}
            </div>

            <div class="attendance-content tracking-content active" id="attendance-content">
                <!-- Statistiques -->
                <div class="attendance-stats">
                    <div class="stat-item present">
                        <div class="stat-value" id="presentCount">0</div>
                        <div class="stat-label">Présents</div>
                    </div>
                    <div class="stat-item absent">
                        <div class="stat-value" id="absentCount">0</div>
                        <div class="stat-label">Absents</div>
                    </div>
                    <div class="stat-item late">
                        <div class="stat-value" id="lateCount">0</div>
                        <div class="stat-label">Retards</div>
                    </div>
                </div>

                <!-- Liste des élèves -->
                {% if current_group %}
                <div style="margin-bottom: 1rem; padding: 0.5rem; background-color: #f8f9fa; border-radius: 0.375rem; border-left: 4px solid {{ current_group.color }};">
                    <h4 style="margin: 0; font-size: 0.875rem; color: #374151; display: flex; align-items: center;">
                        <i class="fas fa-users" style="margin-right: 0.5rem; color: {{ current_group.color }};"></i>
                        Groupe : {{ current_group.name }}
                        {% if current_group.description %}
                        <span style="font-weight: normal; color: #6b7280; margin-left: 0.5rem;">({{ current_group.description }})</span>
                        {% endif %}
                    </h4>
                    <p style="margin: 0.25rem 0 0 0; font-size: 0.75rem; color: #6b7280;">
                        {{ students|length }} élève(s) dans ce groupe
                    </p>
                </div>
                {% else %}
                <div style="margin-bottom: 1rem; padding: 0.5rem; background-color: #f8f9fa; border-radius: 0.375rem;">
                    <h4 style="margin: 0; font-size: 0.875rem; color: #374151; display: flex; align-items: center;">
                        <i class="fas fa-users" style="margin-right: 0.5rem; color: #6b7280;"></i>
                        Classe entière
                    </h4>
                    <p style="margin: 0.25rem 0 0 0; font-size: 0.75rem; color: #6b7280;">
                        {{ students|length }} élève(s) dans la classe
                    </p>
                </div>
                {% endif %}
                <div class="students-list">
                    {% for student in students %}
                    {% set attendance = attendance_records.get(student.id, {}) %}
                    {% set status = attendance.get('status', 'present') %}
                    {% set late_minutes = attendance.get('late_minutes', 0) %}

                    <div class="student-attendance {{ status }}"
                         id="student-{{ student.id }}"
                         data-student-id="{{ student.id }}"
                         data-status="{{ status }}">

                        <div class="student-info" onclick="toggleAttendance({{ student.id }})">
                            <div class="student-avatar">
                                {{ student.first_name[0] }}{{ student.last_name[0] if student.last_name else '' }}
                            </div>
                            <div class="student-name-container">
                                <span class="student-name">{{ student.full_name }}</span>
                                {% if accommodation_display != 'none' and student_accommodations.get(student.id) %}
                                <div class="student-accommodations">
                                    {% for accommodation in student_accommodations[student.id] %}
                                        {% if accommodation_display == 'emoji' %}
                                            <span class="accommodation-emoji" title="{{ accommodation.name }}">{{ accommodation.emoji }}</span>
                                        {% elif accommodation_display == 'name' %}
                                            <span class="accommodation-name">{{ accommodation.emoji }} {{ accommodation.name }}</span>
                                        {% endif %}
                                    {% endfor %}
                                </div>
                                {% endif %}
                            </div>
                        </div>

                        <div class="late-controls">
                            <input type="number"
                                   class="late-minutes"
                                   id="late-{{ student.id }}"
                                   value="{{ late_minutes if status == 'late' else '' }}"
                                   min="1"
                                   max="120"
                                   placeholder="min">
                            <button class="btn-late"
                                    onclick="setLateStatus({{ student.id }})"
                                    title="Marquer en retard">
                                <i class="fas fa-clock"></i>
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>

            <!-- Section sanctions -->
            {% if imported_sanctions %}
            <div class="sanctions-content tracking-content" id="sanctions-content">
                <div class="sanctions-table-container">
                    <table class="sanctions-table">
                        <thead>
                            <tr>
                                <th class="student-column">Élève</th>
                                {% for sanction in imported_sanctions %}
                                <th class="sanction-column">{{ sanction.name }}</th>
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for student in students %}
                            <tr>
                                <td class="student-name">{{ student.full_name }}</td>
                                {% for sanction in imported_sanctions %}
                                <td class="sanction-count">
                                    <div class="count-controls">
                                        <button class="count-btn decrease" onclick="updateSanctionCount({{ student.id }}, {{ sanction.id }}, -1)">
                                            <i class="fas fa-minus"></i>
                                        </button>
                                        <span class="count-display" data-student="{{ student.id }}" data-sanction="{{ sanction.id }}">
                                            {{ sanctions_data[student.id][sanction.id] }}
                                        </span>
                                        <button class="count-btn increase" onclick="updateSanctionCount({{ student.id }}, {{ sanction.id }}, 1)">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                    </div>
                                </td>
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
            {% endif %}
            
            <!-- Section plan de classe -->
            {% if seating_plan %}
            <div class="seating-plan-content tracking-content" id="seating-plan-content">
                <div class="seating-plan-header">
                    <div class="seating-plan-info">
                        <h3><i class="fas fa-th"></i> Plan de classe</h3>
                        <p>Cliquez sur les tables pour ajouter des avertissements : jaune → rouge → noir</p>
                    </div>
                    <button id="undo-warning-btn" class="btn btn-primary" onclick="undoLastWarning()" disabled>
                        <i class="fas fa-undo"></i> Annuler
                    </button>
                </div>
                <div class="seating-plan-container">
                    <div class="seating-plan-viewer" id="seating-plan-viewer">
                        <div class="seating-workspace" id="seating-workspace">
                            <!-- Le plan de classe sera affiché ici -->
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}
        </div>
        <!-- Fin de attendance-section -->

        <!-- Section ressources -->
        <div class="resources-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-folder-open"></i> Ressources du cours
                </h2>
                <div class="resource-controls">
                    <button class="resource-btn" onclick="refreshResources()" title="Actualiser">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <a href="{{ url_for('file_manager.index') }}" class="add-resource-btn" target="_blank">
                        <i class="fas fa-plus"></i> Gestionnaire
                    </a>
                </div>
            </div>

            <div class="resources-content" id="resourcesContent">
                <!-- Chargement initial -->
                <div class="resources-loading" id="resourcesLoading">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Chargement des ressources...</p>
                </div>

                <!-- Ressources épinglées -->
                <div class="pinned-resources" id="pinnedResources" style="display: none;">
                    <div class="pinned-header">
                        <i class="fas fa-thumbtack"></i>
                        <span>Ressources épinglées</span>
                    </div>
                    <div class="pinned-list" id="pinnedList">
                        <!-- Les ressources épinglées seront chargées ici -->
                    </div>
                </div>

                <!-- Navigation des dossiers -->
                <div class="folder-navigation" id="folderNavigation" style="display: none;">
                    <div class="breadcrumb" id="resourceBreadcrumb">
                        <span class="breadcrumb-item active" data-path="" onclick="navigateToFolder('')">
                            <i class="fas fa-home"></i> Racine
                        </span>
                    </div>
                </div>

                <!-- Arborescence des ressources -->
                <div class="resources-tree" id="resourcesTree" style="display: none;">
                    <!-- L'arborescence sera chargée ici -->
                </div>

                <!-- État vide -->
                <div class="no-resources" id="noResources" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <p>Aucune ressource dans cette classe</p>
                    <p style="font-size: 0.875rem; margin-top: 0.5rem;">
                        Utilisez le gestionnaire de fichiers pour ajouter des ressources à cette classe
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Indicateur de sauvegarde -->
<div class="saving-indicator" id="savingIndicator">
    <i class="fas fa-spinner fa-spin"></i>
    <span id="savingText">Sauvegarde...</span>
</div>

<!-- Vue côte-à-côte pour édition avec PDF -->
<div class="split-view-container" id="splitViewContainer">
    <div class="split-view-left">
        <div class="split-view-header">
            <h2>Éditer la planification</h2>
        </div>
        <div id="splitViewPlanningEdit">
            <!-- Le contenu du formulaire sera copié ici -->
        </div>
    </div>
    <div class="split-view-right" id="splitViewRight">
        <button class="split-view-close" onclick="closeSplitView()" title="Fermer la vue côte-à-côte">
            <i class="fas fa-times"></i>
        </button>
        <!-- Le viewer PDF sera intégré ici -->
    </div>
</div>

<!-- Modal Viewer/Annotateur avec Lecteur PDF Unifié -->
<div class="file-viewer-modal" id="fileViewerModal">
    <div class="unified-pdf-viewer-wrapper">
        <button class="close-viewer" onclick="closeFileViewer()">
            <i class="fas fa-times"></i>
        </button>
        <!-- Le lecteur PDF unifié sera injecté ici -->
        <div id="unified-pdf-viewer-container"></div>
    </div>
</div>

<script>
// Variables globales
const lessonDate = '{{ lesson_date.strftime("%Y-%m-%d") }}';
const periodNumber = {{ lesson.period_number }};
const classroomId = {{ lesson_classroom.id if lesson_classroom else 'null' }};
const mixedGroupId = {{ lesson.mixed_group_id if lesson.mixed_group_id else 'null' }};
let isEditingPlanning = false;
let isSplitViewActive = false;

// Variables pour le système de sanctions
let initialSanctionCounts = {};
let sanctionCheckTimer = null;
let sanctionNotificationShown = false;
const NOTIFICATION_TIME_BEFORE_END = 3 * 60 * 1000; // 3 minutes en millisecondes
let checklistStates = {{ (planning.get_checklist_states() if planning else {}) | tojson }};
let checkboxUpdateTimeout = null;
let currentLayout = 'default';

// Fonction pour changer la disposition
function changeLayout(layout) {
    console.log('Changement de disposition vers:', layout);
    currentLayout = layout;
    
    const lessonMain = document.querySelector('.lesson-main');
    const layoutButtons = document.querySelectorAll('.layout-btn');
    const body = document.body;
    
    if (!lessonMain) {
        console.error('Element .lesson-main non trouvé');
        return;
    }
    
    // Supprimer toutes les classes de layout
    lessonMain.classList.remove('layout-planning-focus', 'layout-resources-focus', 'layout-attendance-focus', 'layout-vertical');
    
    // Ajouter la nouvelle classe si ce n'est pas default
    if (layout !== 'default') {
        const className = `layout-${layout}`;
        console.log('Ajout de la classe:', className);
        lessonMain.classList.add(className);
        
        console.log('Classes actuelles:', lessonMain.className);
        
        // Vérifier les styles calculés
        const computedStyle = window.getComputedStyle(lessonMain);
        console.log('Grid template columns calculé:', computedStyle.gridTemplateColumns);
        console.log('Largeur écran:', window.innerWidth + 'px');
    } else {
        console.log('Disposition par défaut - aucune classe ajoutée');
        const computedStyle = window.getComputedStyle(lessonMain);
        console.log('Grid template columns par défaut:', computedStyle.gridTemplateColumns);
    }
    
    // Mettre à jour les boutons actifs
    layoutButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.layout === layout) {
            btn.classList.add('active');
        }
    });
    
    // Sauvegarder la préférence
    localStorage.setItem('lessonLayout', layout);
    
    // Animation de confirmation visuelle
    lessonMain.style.transform = 'scale(0.98)';
    setTimeout(() => {
        lessonMain.style.transform = 'scale(1)';
    }, 150);
    
    // Recalculer la taille du plan de classe si l'onglet est actif
    setTimeout(() => {
        const seatingPlanContent = document.getElementById('seating-plan-content');
        if (seatingPlanContent && seatingPlanContent.classList.contains('active')) {
            console.log('Recalcul de la taille du plan de classe après changement de layout');
            adjustSeatingScale();
        }
    }, 200);
}

// Initialiser les contrôles de disposition
function initLayoutControls() {
    console.log('Initialisation des contrôles de disposition');
    
    // Charger la disposition sauvegardée
    const savedLayout = localStorage.getItem('lessonLayout') || 'default';
    console.log('Disposition sauvegardée:', savedLayout);
    changeLayout(savedLayout);
    
    // Ajouter les event listeners
    const layoutButtons = document.querySelectorAll('.layout-btn');
    console.log('Boutons de disposition trouvés:', layoutButtons.length);
    
    layoutButtons.forEach((btn, index) => {
        console.log(`Bouton ${index}:`, btn.dataset.layout);
        btn.addEventListener('click', () => {
            const layout = btn.dataset.layout;
            console.log('Clic sur bouton:', layout);
            changeLayout(layout);
        });
    });
}

// Fonction pour basculer l'édition de la planification
function togglePlanningEdit() {
    isEditingPlanning = !isEditingPlanning;

    const planningView = document.getElementById('planningView');
    const planningEdit = document.getElementById('planningEdit');
    const emptyPlanning = document.getElementById('emptyPlanning');
    const editBtn = document.querySelector('.edit-planning-btn');
    const editBtnText = document.getElementById('editBtnText');

    if (isEditingPlanning) {
        // Passer en mode édition
        if (planningView) planningView.style.display = 'none';
        if (emptyPlanning) emptyPlanning.style.display = 'none';
        planningEdit.style.display = 'block';
        editBtnText.textContent = 'Fermer';

        // Focus sur le titre
        document.getElementById('planningTitle').focus();
    } else {
        // Passer en mode lecture
        planningEdit.style.display = 'none';
        
        // Vérifier s'il y a du contenu de planification en regardant le titre
        const titleDisplay = document.getElementById('planningTitleDisplay');
        const hasPlanning = titleDisplay && titleDisplay.textContent.trim() && 
                           titleDisplay.textContent !== 'Cours sans titre';
        
        if (hasPlanning) {
            // Il y a une planification, afficher la vue de lecture
            if (planningView) planningView.style.display = 'block';
            if (emptyPlanning) emptyPlanning.style.display = 'none';
        } else {
            // Pas de planification, afficher l'état vide
            if (planningView) planningView.style.display = 'none';
            if (emptyPlanning) emptyPlanning.style.display = 'block';
        }
        editBtnText.textContent = 'Modifier';
    }
}

// Fonction pour gérer l'auto-conversion des tirets en checkboxes
document.getElementById('planningDescription').addEventListener('input', function(e) {
    const textarea = e.target;
    const cursorPos = textarea.selectionStart;
    const value = textarea.value;

    // Vérifier si on vient de taper un tiret en début de ligne
    if (e.inputType === 'insertText' && e.data === '-') {
        const lines = value.substring(0, cursorPos).split('\n');
        const currentLine = lines[lines.length - 1];

        // Si le tiret est au début de la ligne (avec éventuellement des espaces avant)
        if (currentLine.trim() === '-') {
            e.preventDefault();

            // Remplacer le tiret par [ ]
            const beforeCursor = value.substring(0, cursorPos - 1);
            const afterCursor = value.substring(cursorPos);
            const spaces = currentLine.match(/^\s*/)[0]; // Préserver l'indentation

            textarea.value = beforeCursor + spaces + '[ ] ' + afterCursor;

            // Placer le curseur après [ ]
            const newCursorPos = cursorPos - 1 + spaces.length + 4;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
        }
    }
});

// Fonction pour échapper le HTML
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

// Fonction pour mettre à jour l'état d'une checkbox
async function updateCheckboxState(index, checked) {
    // Mettre à jour l'état local immédiatement
    checklistStates[index] = checked;

    // Afficher l'indicateur de sauvegarde
    showSavingIndicator();

    // Annuler le timeout précédent s'il existe
    if (checkboxUpdateTimeout) {
        clearTimeout(checkboxUpdateTimeout);
    }

    // Sauvegarder avec un petit délai pour éviter trop de requêtes
    checkboxUpdateTimeout = setTimeout(async () => {
        try {
            const response = await fetch('{{ url_for("planning.update_checklist_states") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    date: lessonDate,
                    period_number: periodNumber,
                    checklist_states: checklistStates
                })
            });

            const result = await response.json();

            if (result.success) {
                showSavingIndicator('success', 'Sauvegardé');
            } else {
                // En cas d'erreur, rétablir l'état précédent
                checklistStates[index] = !checked;
                const checkbox = document.getElementById(`checkbox-${index}`);
                if (checkbox) {
                    checkbox.checked = !checked;
                }
                showSavingIndicator('error', 'Erreur de sauvegarde');
            }
        } catch (error) {
            console.error('Erreur:', error);
            // En cas d'erreur, rétablir l'état précédent
            checklistStates[index] = !checked;
            const checkbox = document.getElementById(`checkbox-${index}`);
            if (checkbox) {
                checkbox.checked = !checked;
            }
            showSavingIndicator('error', 'Erreur de connexion');
        }
    }, 500); // Délai de 500ms pour regrouper les changements
}

// Fonction pour afficher l'indicateur de sauvegarde
function showSavingIndicator(status = 'saving', message = 'Sauvegarde...') {
    const indicator = document.getElementById('savingIndicator');
    const text = document.getElementById('savingText');
    const icon = indicator.querySelector('i');

    // Réinitialiser les classes
    indicator.className = 'saving-indicator show';

    if (status === 'saving') {
        icon.className = 'fas fa-spinner fa-spin';
        text.textContent = message;
    } else if (status === 'success') {
        indicator.classList.add('success');
        icon.className = 'fas fa-check';
        text.textContent = message;
    } else if (status === 'error') {
        indicator.classList.add('error');
        icon.className = 'fas fa-exclamation-triangle';
        text.textContent = message;
    }

    // Masquer après 2 secondes si c'est un succès ou une erreur
    if (status !== 'saving') {
        setTimeout(() => {
            indicator.classList.remove('show');
        }, 2000);
    }
}

// Fonction pour annuler l'édition
function cancelPlanningEdit() {
    // Restaurer les valeurs d'origine
    const titleDisplay = document.getElementById('planningTitleDisplay');
    const descriptionDisplay = document.getElementById('planningDescriptionDisplay');

    if (titleDisplay && titleDisplay.textContent !== 'Cours sans titre') {
        document.getElementById('planningTitle').value = titleDisplay.textContent;

        // Récupérer la description originale depuis les données du serveur
        {% if planning %}
        document.getElementById('planningDescription').value = {{ planning.description | tojson }};
        {% else %}
        document.getElementById('planningDescription').value = '';
        {% endif %}
    }

    togglePlanningEdit();
}

// Fonction pour sauvegarder la planification
async function savePlanning(event) {
    event.preventDefault();

    const title = document.getElementById('planningTitle').value.trim();
    const description = document.getElementById('planningDescription').value.trim();

    const submitButton = event.target.querySelector('button[type="submit"]');
    const originalText = submitButton.innerHTML;

    // Désactiver le bouton et afficher un loader
    submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Enregistrement...';

    try {
        const response = await fetch('{{ url_for("planning.save_lesson_planning") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                date: lessonDate,
                period_number: periodNumber,
                classroom_id: classroomId,
                title: title,
                description: description,
                checklist_states: checklistStates
            })
        });

        const result = await response.json();

        if (result.success) {
            // Recharger la page pour afficher les changements
            window.location.reload();
        } else {
            showPlanningNotification('error', result.message || 'Erreur lors de l\'enregistrement');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showPlanningNotification('error', 'Erreur lors de la communication avec le serveur');
    } finally {
        submitButton.disabled = false;
        submitButton.innerHTML = originalText;
    }
}

// Fonction pour afficher une notification
function showPlanningNotification(type, message) {
    // Créer le conteneur de notifications s'il n'existe pas
    let container = document.querySelector('.notifications-container');
    if (!container) {
        container = document.createElement('div');
        container.className = 'notifications-container';
        container.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 1000;';
        document.body.appendChild(container);
    }

    // Créer la notification
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        background-color: ${type === 'success' ? '#D1FAE5' : '#FEE2E2'};
        color: ${type === 'success' ? '#065F46' : '#991B1B'};
        padding: 1rem 1.5rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideInNotification 0.3s ease;
        max-width: 400px;
    `;

    const icon = document.createElement('i');
    icon.className = `fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}`;

    const text = document.createElement('span');
    text.textContent = message;

    notification.appendChild(icon);
    notification.appendChild(text);
    container.appendChild(notification);

    // Supprimer la notification après 5 secondes
    setTimeout(() => {
        notification.style.animation = 'slideOutNotification 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 5000);
}

// Fonction pour basculer entre présent/absent
async function toggleAttendance(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const currentStatus = studentElement.dataset.status;
    let newStatus;

    // Cycle: present -> absent -> present (ignorer late dans le cycle)
    if (currentStatus === 'present' || currentStatus === 'late') {
        newStatus = 'absent';
    } else {
        newStatus = 'present';
    }

    // Réinitialiser le champ de retard
    const lateInput = document.getElementById(`late-${studentId}`);
    lateInput.value = '';

    await updateAttendance(studentId, newStatus, null);
}

// Fonction pour marquer un élève en retard (toggle)
async function setLateStatus(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const lateInput = document.getElementById(`late-${studentId}`);
    
    // Vérifier le statut actuel de l'élève
    const isCurrentlyLate = studentElement.classList.contains('late');
    
    if (isCurrentlyLate) {
        // Si déjà en retard, remettre présent
        await updateAttendance(studentId, 'present', null);
    } else {
        // Sinon, marquer en retard
        const minutes = lateInput.value;

        if (!minutes || minutes <= 0) {
            alert('Veuillez entrer le nombre de minutes de retard');
            lateInput.focus();
            return;
        }

        await updateAttendance(studentId, 'late', parseInt(minutes));
    }
}

// Fonction pour mettre à jour l'apparence des boutons selon le statut
function updateAttendanceButtons(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const lateButton = studentElement.querySelector('.btn-late');
    
    if (studentElement.classList.contains('late')) {
        // Élève en retard - bouton pour remettre présent
        lateButton.title = 'Remettre présent';
        lateButton.innerHTML = '<i class="fas fa-undo"></i>';
    } else {
        // Élève présent ou absent - bouton pour marquer en retard
        lateButton.title = 'Marquer en retard';
        lateButton.innerHTML = '<i class="fas fa-clock"></i>';
    }
}

// Fonction pour envoyer la mise à jour au serveur
async function updateAttendance(studentId, status, lateMinutes) {
    try {
        const response = await fetch('{{ url_for("planning.update_attendance") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                student_id: studentId,
                classroom_id: classroomId,
                date: lessonDate,
                period_number: periodNumber,
                status: status,
                late_minutes: lateMinutes
            })
        });

        const result = await response.json();

        if (result.success) {
            // Mettre à jour l'interface
            const studentElement = document.getElementById(`student-${studentId}`);
            const lateInput = document.getElementById(`late-${studentId}`);

            // Retirer toutes les classes de statut
            studentElement.classList.remove('present', 'absent', 'late');

            // Ajouter la nouvelle classe
            studentElement.classList.add(status);
            studentElement.dataset.status = status;

            // Si ce n'est pas un retard, vider le champ
            if (status !== 'late') {
                lateInput.value = '';
            }

            // Mettre à jour l'apparence des boutons
            updateAttendanceButtons(studentId);

            // Mettre à jour les statistiques
            updateStats();

            // Afficher une notification visuelle
            showQuickNotification(studentElement, status);
        } else {
            alert('Erreur lors de la mise à jour de la présence');
        }
    } catch (error) {
        console.error('Erreur:', error);
        alert('Erreur lors de la communication avec le serveur');
    }
}

// Fonction pour afficher une notification rapide
function showQuickNotification(element, status) {
    element.style.transform = 'scale(0.95)';
    setTimeout(() => {
        element.style.transform = 'scale(1)';
    }, 200);
}

// Permettre d'entrer le retard avec Enter
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser les contrôles de disposition
    initLayoutControls();
    
    // Initialiser les statistiques
    updateStats();

    // Ajouter l'événement Enter sur tous les champs de retard
    document.querySelectorAll('.late-minutes').forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const studentId = this.id.replace('late-', '');
                setLateStatus(parseInt(studentId));
            }
        });
    });

    // Gérer les raccourcis clavier pour la planification
    document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + E pour éditer la planification
        if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
            e.preventDefault();
            if (!isEditingPlanning) {
                togglePlanningEdit();
            }
        }

        // Escape pour annuler l'édition
        if (e.key === 'Escape' && isEditingPlanning) {
            cancelPlanningEdit();
        }
    });
});

// Fonction pour mettre à jour les statistiques
function updateStats() {
    let present = 0;
    let absent = 0;
    let late = 0;

    document.querySelectorAll('.student-attendance').forEach(student => {
        const status = student.dataset.status;
        if (status === 'present') present++;
        else if (status === 'absent') absent++;
        else if (status === 'late') late++;
    });

    document.getElementById('presentCount').textContent = present;
    document.getElementById('absentCount').textContent = absent;
    document.getElementById('lateCount').textContent = late;
}

// Variables pour la gestion des ressources
let currentFolderPath = '';
let classResources = [];

// Charger les ressources de la classe au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    loadClassResources();
});

// Fonction pour charger les ressources de la classe
async function loadClassResources() {
    try {
        showResourcesLoading(true);
        
        const response = await fetch(`{{ url_for('planning.get_class_resources', classroom_id=0) }}`.replace('0', classroomId));
        const result = await response.json();
        
        if (result.success) {
            classResources = result.files || [];
            renderResources(result.pinned_files || [], classResources);
        } else {
            showNoResources();
        }
    } catch (error) {
        console.error('Erreur lors du chargement des ressources:', error);
        showNoResources();
    } finally {
        showResourcesLoading(false);
    }
}

// Fonction pour afficher/masquer le chargement
function showResourcesLoading(show) {
    const loadingElement = document.getElementById('resourcesLoading');
    if (loadingElement) {
        loadingElement.style.display = show ? 'block' : 'none';
    }
}

// Fonction pour afficher l'état vide
function showNoResources() {
    const noResourcesElement = document.getElementById('noResources');
    const pinnedElement = document.getElementById('pinnedResources');
    const navigationElement = document.getElementById('folderNavigation');
    const treeElement = document.getElementById('resourcesTree');
    
    if (noResourcesElement) noResourcesElement.style.display = 'block';
    if (pinnedElement) pinnedElement.style.display = 'none';
    if (navigationElement) navigationElement.style.display = 'none';
    if (treeElement) treeElement.style.display = 'none';
}

// Fonction pour rendre les ressources
function renderResources(pinnedFiles, allFiles) {
    const pinnedElement = document.getElementById('pinnedResources');
    const navigationElement = document.getElementById('folderNavigation');
    const treeElement = document.getElementById('resourcesTree');
    const noResourcesElement = document.getElementById('noResources');
    
    // Masquer l'état vide
    if (noResourcesElement) noResourcesElement.style.display = 'none';
    
    // Afficher les ressources épinglées
    if (pinnedFiles && pinnedFiles.length > 0) {
        renderPinnedResources(pinnedFiles);
        if (pinnedElement) pinnedElement.style.display = 'block';
    } else {
        if (pinnedElement) pinnedElement.style.display = 'none';
    }
    
    // À la racine, passer tous les fichiers à renderResourceTree pour qu'elle puisse extraire les dossiers
    // Dans un dossier spécifique, filtrer seulement les fichiers de ce dossier
    let filesToDisplay;
    if (!currentFolderPath) {
        // À la racine : passer tous les fichiers
        filesToDisplay = allFiles;
    } else {
        // Dans un dossier : filtrer
        filesToDisplay = filterFilesByFolder(allFiles, currentFolderPath);
    }
    
    // Afficher la navigation
    renderBreadcrumb();
    if (navigationElement) navigationElement.style.display = 'block';
    
    // Afficher l'arborescence
    renderResourceTree(filesToDisplay);
    if (treeElement) treeElement.style.display = 'block';
}

// Fonction pour rendre les ressources épinglées
function renderPinnedResources(pinnedFiles) {
    const pinnedList = document.getElementById('pinnedList');
    if (!pinnedList) return;
    
    pinnedList.innerHTML = pinnedFiles.map(file => {
        const isAnnotatable = ['pdf', 'png', 'jpg', 'jpeg'].includes(file.file_type.toLowerCase());
        
        return `
            <div class="resource-item pinned" data-file-id="${file.id}">
                <div class="resource-icon ${getResourceIconClass(file.file_type)}">
                    <i class="fas ${getResourceIcon(file.file_type)}"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name ${isAnnotatable ? 'clickable-file' : ''}" 
                             ${isAnnotatable ? `onclick="openFileViewer(${file.id}, '${file.original_filename}', '${file.file_type}')"` : ''}>
                            ${file.original_filename}
                        </div>
                        <div class="resource-meta">
                            <span>${formatFileSize(file.file_size)}</span>
                            <span>Épinglé</span>
                            ${isAnnotatable ? '<span class="annotatable-badge">✏️ Annotable</span>' : ''}
                        </div>
                    </div>
                    <div class="resource-actions">
                        <button class="resource-action-btn pinned" onclick="togglePinResource(${file.id})" title="Désépingler">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Fonction pour filtrer les fichiers par dossier
function filterFilesByFolder(files, folderPath) {
    return files.filter(file => {
        if (!folderPath) {
            // Racine : fichiers sans dossier ou dossier vide
            return !file.folder_path || file.folder_path === '';
        } else {
            // Dossier spécifique : fichiers dans ce dossier exact OU dans ses sous-dossiers
            return file.folder_path === folderPath || 
                   (file.folder_path && file.folder_path.startsWith(folderPath + '/'));
        }
    });
}

// Fonction pour rendre le fil d'ariane
function renderBreadcrumb() {
    const breadcrumb = document.getElementById('resourceBreadcrumb');
    if (!breadcrumb) return;
    
    let html = `
        <span class="breadcrumb-item ${currentFolderPath === '' ? 'active' : ''}" 
              data-path="" onclick="navigateToFolder('')">
            <i class="fas fa-home"></i> Racine
        </span>
    `;
    
    if (currentFolderPath) {
        const pathParts = currentFolderPath.split('/');
        let currentPath = '';
        
        pathParts.forEach((part, index) => {
            currentPath += (index > 0 ? '/' : '') + part;
            const isLast = index === pathParts.length - 1;
            
            html += `
                <span class="breadcrumb-separator">/</span>
                <span class="breadcrumb-item ${isLast ? 'active' : ''}" 
                      data-path="${currentPath}" onclick="navigateToFolder('${currentPath}')">
                    ${part}
                </span>
            `;
        });
    }
    
    breadcrumb.innerHTML = html;
}

// Fonction pour rendre l'arborescence des ressources
function renderResourceTree(files) {
    const treeElement = document.getElementById('resourcesTree');
    if (!treeElement) return;
    
    // Organiser les fichiers par dossiers et fichiers
    const folders = new Set();
    const regularFiles = [];
    
    files.forEach(file => {
        if (file.folder_path) {
            if (!currentFolderPath) {
                // À la racine : extraire le premier niveau de dossier
                const topLevelFolder = file.folder_path.split('/')[0];
                folders.add(topLevelFolder);
            } else if (file.folder_path.startsWith(currentFolderPath + '/') || file.folder_path === currentFolderPath) {
                // Dans un dossier : vérifier si le fichier est exactement dans ce dossier ou dans un sous-dossier
                if (file.folder_path === currentFolderPath) {
                    // Fichier directement dans ce dossier
                    regularFiles.push(file);
                } else {
                    // Extraire le dossier suivant
                    const relativePath = file.folder_path.substring(currentFolderPath.length + 1);
                    const nextFolder = relativePath.split('/')[0];
                    if (nextFolder && nextFolder !== '') {
                        folders.add(nextFolder);
                    }
                }
            }
        } else {
            // Fichier sans dossier (directement à la racine)
            if (!currentFolderPath) {
                regularFiles.push(file);
            }
        }
    });
    
    let html = '';
    
    // Afficher les dossiers
    Array.from(folders).sort().forEach(folderName => {
        const folderPath = currentFolderPath ? `${currentFolderPath}/${folderName}` : folderName;
        html += `
            <div class="resource-item folder" onclick="navigateToFolder('${folderPath}')">
                <div class="resource-icon folder">
                    <i class="fas fa-folder"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name">${folderName}</div>
                        <div class="resource-meta">
                            <span>Dossier</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    
    // Afficher les fichiers
    regularFiles.forEach(file => {
        const isPinned = file.is_pinned;
        const isAnnotatable = ['pdf', 'png', 'jpg', 'jpeg'].includes(file.file_type.toLowerCase());
        
        html += `
            <div class="resource-item ${isPinned ? 'pinned' : ''}" data-file-id="${file.id}">
                <div class="resource-icon ${getResourceIconClass(file.file_type)}">
                    <i class="fas ${getResourceIcon(file.file_type)}"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name ${isAnnotatable ? 'clickable-file' : ''}" 
                             ${isAnnotatable ? `onclick="openFileViewer(${file.id}, '${file.original_filename}', '${file.file_type}')"` : ''}>
                            ${file.original_filename}
                        </div>
                        <div class="resource-meta">
                            <span>${formatFileSize(file.file_size)}</span>
                            ${file.uploaded_at ? `<span>${formatDate(file.uploaded_at)}</span>` : ''}
                            ${isAnnotatable ? '<span class="annotatable-badge">✏️ Annotable</span>' : ''}
                        </div>
                    </div>
                    <div class="resource-actions">
                        <button class="resource-action-btn ${isPinned ? 'pinned' : ''}" 
                                onclick="togglePinResource(${file.id})" 
                                title="${isPinned ? 'Désépingler' : 'Épingler'}">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    });
    
    treeElement.innerHTML = html || '<p style="text-align: center; color: #6B7280; padding: 2rem;">Aucun fichier dans ce dossier</p>';
}

// Fonction pour naviguer vers un dossier
function navigateToFolder(folderPath) {
    currentFolderPath = folderPath;
    
    // Utiliser la même logique que dans renderResources
    let filesToDisplay;
    if (!currentFolderPath) {
        // À la racine : passer tous les fichiers
        filesToDisplay = classResources;
    } else {
        // Dans un dossier : filtrer
        filesToDisplay = filterFilesByFolder(classResources, currentFolderPath);
    }
    
    renderBreadcrumb();
    renderResourceTree(filesToDisplay);
}

// Fonction pour épingler/désépingler une ressource
async function togglePinResource(fileId) {
    try {
        const response = await fetch('{{ url_for("planning.toggle_pin_resource") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_id: fileId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Recharger les ressources pour refléter les changements
            await loadClassResources();
        } else {
            console.error('Erreur lors de l\'épinglage:', result.message);
        }
    } catch (error) {
        console.error('Erreur lors de l\'épinglage:', error);
    }
}

// Fonction pour actualiser les ressources
function refreshResources() {
    loadClassResources();
}

// Fonctions utilitaires
function getResourceIcon(fileType) {
    switch(fileType) {
        case 'pdf': return 'fa-file-pdf';
        case 'png':
        case 'jpg':
        case 'jpeg': return 'fa-file-image';
        default: return 'fa-file';
    }
}

function getResourceIconClass(fileType) {
    switch(fileType) {
        case 'pdf': return 'pdf';
        case 'png':
        case 'jpg':
        case 'jpeg': return 'image';
        default: return '';
    }
}

function formatFileSize(bytes) {
    if (!bytes) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('fr-FR');
}

{% if is_current %}
// Gestion du timer
let timerInterval;
let isPaused = false;
let remainingSeconds = {{ remaining_seconds }};

function updateTimer() {
    if (!isPaused && remainingSeconds > 0) {
        remainingSeconds--;

        const hours = Math.floor(remainingSeconds / 3600);
        const minutes = Math.floor((remainingSeconds % 3600) / 60);
        const seconds = remainingSeconds % 60;

        let display = '';
        if (hours > 0) {
            display = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } else {
            display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        document.getElementById('lessonTimer').textContent = display;

        if (remainingSeconds === 0) {
            clearInterval(timerInterval);
            alert('Le cours est terminé !');
        }
    }
}

function toggleTimer() {
    isPaused = !isPaused;
    const icon = document.getElementById('timerIcon');
    icon.className = isPaused ? 'fas fa-play' : 'fas fa-pause';
}

// Démarrer le timer
timerInterval = setInterval(updateTimer, 1000);

// Nettoyer à la fermeture de la page
window.addEventListener('beforeunload', () => {
    clearInterval(timerInterval);
    
    // Sauvegarder les annotations si le viewer est ouvert
    if (currentFileId && annotations.length > 0) {
        // Utiliser sendBeacon pour une sauvegarde synchrone lors de la fermeture
        const data = JSON.stringify({
            file_id: currentFileId,
            annotations: annotations
        });
        
        // sendBeacon est plus fiable que fetch lors de beforeunload
        navigator.sendBeacon('/planning/save_file_annotations', new Blob([data], {type: 'application/json'}));
    }
});
{% endif %}

// =================== SYSTÈME D'ANNOTATION ===================

// Variables globales pour l'annotation améliorée
let currentFileId = null;
let currentAnnotationTool = 'pen';
let currentTool = 'pen'; // Variable manquante
let currentColor = '#000000';
let currentAnnotationColor = '#ff0000'; // Variable pour les annotations
let currentStrokeWidth = 3;
let isDrawing = false;
let isNavigating = false; // Nouveau: indique qu'on est en train de naviguer entre pages
let isLoadingInitialAnnotations = false; // Indique qu'on charge les annotations initiales
let annotations = []; // Annotations de la page actuelle (pour compatibilité)
let annotationsByPage = {}; // Nouveau: annotations organisées par numéro de page
let currentStroke = [];
let undoHistory = [];
let undoHistoryByPage = {}; // Historique d'annulation par page
let saveTimeout = null;

// Variables simplifiées

// Variables PDF
let pdfDoc = null;
let currentPageNum = 1;
let pageIsRendering = false;
let pageNumIsPending = null;
let currentScale = 1.0;
let pdfCanvas = null;
let pdfCtx = null;
let annotationCanvas = null;
let annotationCtx = null;
// Variables de compatibilité
let canvas = null;
let ctx = null;

// Charger PDF.js si pas déjà fait
if (typeof pdfjsLib === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
    script.onload = () => {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    };
    document.head.appendChild(script);
}

// Fonction openFileViewer redirigée vers le nouveau lecteur unifié
async function openFileViewer(fileId, filename, fileType) {
    console.log('🔄 Redirection vers le lecteur unifié:', filename, fileType);
    
    // Si l'éditeur de planification est actif, ouvrir en vue split
    if (isEditingPlanning) {
        openSplitView(fileId, filename, fileType);
        return;
    }
    
    // Pour les PDF, utiliser le nouveau lecteur unifié
    if (fileType.toLowerCase() === 'pdf') {
        openFileWithUnifiedViewer(fileId, filename);
        return;
    }
    
    // Pour les autres types de fichiers, rediriger vers l'ouverture simple
    window.open(`/file_manager/serve_file/${encodeURIComponent(fileId)}`, '_blank');
}

// Initialiser les canvas
function initializeCanvases() {
    // En mode multi-pages, les canvas sont créés dynamiquement
    // Cette fonction reste pour la compatibilité
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (pagesContainer) {
        // Mode multi-pages - rien à faire ici
        return;
    }
    
    // Mode single page (ancien mode)
    pdfCanvas = document.getElementById('pdfCanvas');
    annotationCanvas = document.getElementById('annotationCanvas');
    
    if (pdfCanvas && annotationCanvas) {
        pdfCtx = pdfCanvas.getContext('2d');
        annotationCtx = annotationCanvas.getContext('2d');
        
        // Variables de compatibilité pour les autres fonctions
        canvas = annotationCanvas;
        ctx = annotationCtx;
        
        // Améliorer la qualité du rendu
        pdfCtx.imageSmoothingEnabled = true;
        pdfCtx.imageSmoothingQuality = 'high';
        annotationCtx.imageSmoothingEnabled = true;
        annotationCtx.imageSmoothingQuality = 'high';
        
        // Forcer le bon positionnement du canvas d'annotation
        forceCanvasPositioning();
    }
}

// Fonction pour forcer le bon positionnement du canvas
function forceCanvasPositioning() {
    if (!annotationCanvas || !pdfCanvas) return;
    
    console.log('🔧 Aligning annotation canvas with PDF canvas...');
    
    // Assurer que les canvas ont exactement les mêmes dimensions logiques
    annotationCanvas.width = pdfCanvas.width;
    annotationCanvas.height = pdfCanvas.height;
    
    // Obtenir les rectangles de position pour diagnostic
    const pdfRect = pdfCanvas.getBoundingClientRect();
    
    // Copier TOUS les styles computed du PDF canvas pour garantir un alignement parfait
    const pdfComputedStyle = window.getComputedStyle(pdfCanvas);
    
    // Assurer que les canvas ont exactement les mêmes styles CSS
    annotationCanvas.style.position = 'absolute';
    annotationCanvas.style.top = '0px';
    annotationCanvas.style.left = '0px';
    
    // IMPORTANT: Copier les dimensions exactement du PDF canvas
    // Les dimensions CSS doivent être les dimensions logiques (avant transformation)
    if (pdfCanvas.style.width) {
        annotationCanvas.style.width = pdfCanvas.style.width;
    } else {
        // Si pas de style explicite, utiliser les dimensions logiques
        annotationCanvas.style.width = pdfCanvas.width + 'px';
    }
    
    if (pdfCanvas.style.height) {
        annotationCanvas.style.height = pdfCanvas.style.height;
    } else {
        // Si pas de style explicite, utiliser les dimensions logiques
        annotationCanvas.style.height = pdfCanvas.height + 'px';
    }
    
    // Copier la transformation et l'origine exactement
    annotationCanvas.style.transform = pdfComputedStyle.transform;
    annotationCanvas.style.transformOrigin = pdfComputedStyle.transformOrigin;
    
    annotationCanvas.style.zIndex = '100'; // Au-dessus du PDF
    annotationCanvas.style.pointerEvents = 'auto';
    
    // S'assurer que le conteneur est configuré correctement
    const container = pdfCanvas.parentElement;
    if (container) {
        container.style.position = 'relative';
    }
    
    // Vérifier l'alignement après positionnement
    requestAnimationFrame(() => {
        const annotationRect = annotationCanvas.getBoundingClientRect();
        const pdfRectAfter = pdfCanvas.getBoundingClientRect();
        
        console.log('✅ Canvas alignment completed');
        console.log('  📏 PDF Canvas logical:', pdfCanvas.width, 'x', pdfCanvas.height);
        console.log('  📏 PDF Canvas visible:', Math.round(pdfRectAfter.width), 'x', Math.round(pdfRectAfter.height));
        console.log('  📏 Annotation Canvas logical:', annotationCanvas.width, 'x', annotationCanvas.height);
        console.log('  📏 Annotation Canvas visible:', Math.round(annotationRect.width), 'x', Math.round(annotationRect.height));
        console.log('  🎨 CSS width match:', annotationCanvas.style.width, '===', pdfCanvas.style.width || pdfComputedStyle.width);
        console.log('  🎨 CSS height match:', annotationCanvas.style.height, '===', pdfCanvas.style.height || pdfComputedStyle.height);
        console.log('  📍 Position alignment:', 
            Math.abs(pdfRectAfter.left - annotationRect.left) < 1 && Math.abs(pdfRectAfter.top - annotationRect.top) < 1);
        console.log('  📍 Size alignment:', 
            Math.abs(pdfRectAfter.width - annotationRect.width) < 1 && Math.abs(pdfRectAfter.height - annotationRect.height) < 1);
        console.log('  ⚖️  Scale factor X:', Math.round(annotationCanvas.width / annotationRect.width * 100) / 100);
        console.log('  ⚖️  Scale factor Y:', Math.round(annotationCanvas.height / annotationRect.height * 100) / 100);
        
        // Si les tailles ne correspondent pas, forcer la correction
        if (Math.abs(pdfRectAfter.width - annotationRect.width) > 1) {
            console.warn('⚠️  Size mismatch detected! Forcing correction...');
            annotationCanvas.style.width = pdfRectAfter.width + 'px';
            annotationCanvas.style.height = pdfRectAfter.height + 'px';
        }
        
        // 🔥 CRITIQUE: Redessiner les annotations après l'alignement car le redimensionnement les efface
        if (annotations.length > 0) {
            console.log('🎨 REDESSINAGE APRÈS ALIGNEMENT:', annotations.length, 'annotations');
            redrawAnnotations();
        }
    });
}

// Charger PDF.js de manière asynchrone
function loadPDFJS() {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        script.onload = () => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            resolve();
        };
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Charger un PDF avec qualité améliorée
async function loadPDF(fileId) {
    const pdfUrl = `/file_manager/serve_file/${fileId}`;
    
    // Initialiser les variables d'annotation
    currentTool = 'pen';
    currentColor = '#000000';
    currentAnnotationColor = '#ff0000';
    currentStrokeWidth = 3;
    
    // Vérifier que PDF.js est chargé
    if (typeof pdfjsLib === 'undefined') {
        await loadPDFJS();
    }
    
    try {
        // Charger le PDF avec qualité améliorée
        const loadingTask = pdfjsLib.getDocument({
            url: pdfUrl,
            cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
            cMapPacked: true,
            useSystemFonts: true
        });
        
        pdfDoc = await loadingTask.promise;
        console.log('PDF chargé, nombre de pages:', pdfDoc.numPages);
        
        // Mettre à jour l'interface
        updatePageInfo();
        
        // Générer les miniatures
        await generateThumbnails();
        
        // Rendre toutes les pages en mode scroll
        await renderAllPages();
        
    } catch (error) {
        console.error('Erreur lors du chargement du PDF:', error);
        throw error;
    }
}

// Rendre toutes les pages du PDF en mode scroll
async function renderAllPages() {
    console.log('🔍 DEBUG: renderAllPages - Début');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (!pagesContainer) {
        console.error('❌ pdfPagesContainer non trouvé!');
        return;
    }
    
    pagesContainer.innerHTML = ''; // Nettoyer le conteneur
    console.log(`📄 Nombre de pages à rendre: ${pdfDoc.numPages}`);
    
    // Réinitialiser currentPageNum à 1
    currentPageNum = 1;
    
    // Créer les éléments pour chaque page
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'pdf-page-wrapper';
        pageWrapper.id = `page-wrapper-${pageNum}`;
        
        // Ajouter le numéro de page
        const pageNumber = document.createElement('div');
        pageNumber.className = 'pdf-page-number';
        pageNumber.textContent = `Page ${pageNum}`;
        pageWrapper.appendChild(pageNumber);
        
        // Créer les canvas pour le PDF et les annotations
        const pdfCanvas = document.createElement('canvas');
        pdfCanvas.className = 'pdf-canvas';
        pdfCanvas.id = `pdf-canvas-${pageNum}`;
        
        const annotationCanvas = document.createElement('canvas');
        annotationCanvas.className = 'annotation-canvas';
        annotationCanvas.id = `annotation-canvas-${pageNum}`;
        
        pageWrapper.appendChild(pdfCanvas);
        pageWrapper.appendChild(annotationCanvas);
        pagesContainer.appendChild(pageWrapper);
        
        // Rendre la page
        await renderSinglePage(pageNum, pdfCanvas, annotationCanvas);
    }
    
    // Configurer les événements d'annotation pour toutes les pages
    setupMultiPageAnnotations();
    
    // Observer le scroll pour mettre à jour la page courante
    setupScrollObserver();
    
    // Appliquer automatiquement la correction du problème de scroll après un petit délai
    setTimeout(() => {
        console.log('🔧 Application automatique de la correction de scroll...');
        applyScrollFix();
    }, 200);
    
    
    console.log('✅ renderAllPages - Terminé');
}

// === FONCTIONS DE TEST ET DEBUG ===
window.pdfDebug = {
    // Tester la navigation
    testNavigation: function() {
        console.log('🧪 Test de navigation');
        console.log(`Pages disponibles: 1-${pdfDoc ? pdfDoc.numPages : 'PDF non chargé'}`);
        console.log(`Page actuelle: ${currentPageNum}`);
        
        // Tester le scroll vers la page 1
        const firstPage = document.getElementById('page-wrapper-1');
        if (firstPage) {
            console.log('✅ page-wrapper-1 trouvé');
            firstPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } else {
            console.error('❌ page-wrapper-1 non trouvé');
        }
    },
    
    // Vérifier les canvas
    checkCanvases: function() {
        console.log('🧪 Vérification des canvas');
        const pagesContainer = document.getElementById('pdfPagesContainer');
        if (!pagesContainer) {
            console.error('❌ pdfPagesContainer non trouvé');
            return;
        }
        
        console.log(`📄 Conteneur: ${pagesContainer.children.length} enfants`);
        console.log('Enfants du conteneur:', Array.from(pagesContainer.children).map(c => c.id));
        
        for (let i = 1; i <= (pdfDoc ? pdfDoc.numPages : 10); i++) {
            const pageWrapper = document.getElementById(`page-wrapper-${i}`);
            const pdfCanvas = document.getElementById(`pdf-canvas-${i}`);
            const annotCanvas = document.getElementById(`annotation-canvas-${i}`);
            
            console.log(`Page ${i}: Wrapper ${pageWrapper ? '✅' : '❌'}, PDF canvas ${pdfCanvas ? '✅' : '❌'}, Annotation canvas ${annotCanvas ? '✅' : '❌'}`);
            
            if (annotCanvas) {
                const rect = annotCanvas.getBoundingClientRect();
                console.log(`  - Taille: ${rect.width}x${rect.height}, Position: ${rect.top}`);
            }
        }
    },
    
    // Tester le dessin
    testDrawing: function() {
        console.log('🧪 Test du système de dessin');
        console.log(`Outil actuel: ${currentTool}`);
        console.log(`Couleur: ${currentColor}`);
        console.log(`Épaisseur: ${currentStrokeWidth}`);
        console.log(`Mode dessin: ${isDrawing ? 'ACTIF' : 'INACTIF'}`);
    },
    
    // Forcer le scroll vers la première page
    goToFirst: function() {
        console.log('🔧 Force scroll vers page 1');
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (viewerContainer && firstPage) {
            viewerContainer.scrollTop = 0;
            firstPage.scrollIntoView({ behavior: 'auto', block: 'start' });
            currentPageNum = 1;
            updatePageInfo();
                    updateActiveThumbnail();
            console.log('✅ Navigation forcée vers page 1');
        }
    },
    
    // Aller à une page spécifique
    goToPage: function(pageNum) {
        console.log(`🔧 DEBUG Navigation vers page ${pageNum}`);
        const viewerContainer = document.getElementById('viewerContainer');
        const targetPage = document.getElementById(`page-wrapper-${pageNum}`);
        
        if (viewerContainer && targetPage && pageNum >= 1 && pageNum <= (pdfDoc ? pdfDoc.numPages : 0)) {
            // Utiliser la fonction principale goToPage
            goToPage(pageNum);
        } else {
            console.error(`❌ Page ${pageNum} non trouvée ou invalide`);
            console.log('Vérifications:');
            console.log('- viewerContainer:', !!viewerContainer);
            console.log('- targetPage:', !!targetPage);
            console.log('- pageNum range:', pageNum >= 1 && pageNum <= (pdfDoc ? pdfDoc.numPages : 0));
            console.log('- Total pages:', pdfDoc ? pdfDoc.numPages : 'PDF non chargé');
        }
    },
    
    // Test de navigation complète
    testFullNavigation: function() {
        console.log('🧪 Test de navigation complète');
        const totalPages = pdfDoc ? pdfDoc.numPages : 0;
        console.log(`Pages disponibles: 1-${totalPages}`);
        
        if (totalPages === 0) {
            console.error('❌ Aucun PDF chargé');
            return;
        }
        
        // Test aller à la page 1
        this.goToPage(1);
        
        setTimeout(() => {
            // Test aller à la dernière page
            console.log(`🧪 Test navigation vers page ${totalPages}`);
            this.goToPage(totalPages);
            
            setTimeout(() => {
                // Retour à la page 1
                console.log('🧪 Retour à la page 1');
                this.goToPage(1);
            }, 2000);
        }, 2000);
    },
    
    // Relancer le rendu si ça a échoué
    retryRender: async function() {
        console.log('🔧 Relance du rendu...');
        if (pdfDoc) {
            currentTool = 'pen'; // S'assurer que currentTool est défini
            await renderAllPages();
        } else {
            console.error('❌ PDF non chargé');
        }
    },
    
    // Test spécifique pour le problème de scroll
    testScrollIssue: function() {
        console.log('🧪 Test spécifique du problème de scroll');
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (!viewerContainer || !firstPage) {
            console.error('❌ Elements non trouvés');
            return;
        }
        
        console.log('📊 État actuel:');
        console.log('  - Container scrollTop:', viewerContainer.scrollTop);
        console.log('  - Container scrollHeight:', viewerContainer.scrollHeight);
        console.log('  - Container clientHeight:', viewerContainer.clientHeight);
        console.log('  - Page courante détectée:', currentPageNum);
        
        // Position de la page 1
        const rect = firstPage.getBoundingClientRect();
        const containerRect = viewerContainer.getBoundingClientRect();
        console.log('📍 Position de la page 1:');
        console.log('  - Page offsetTop:', firstPage.offsetTop);
        console.log('  - Page getBoundingClientRect top:', rect.top);
        console.log('  - Container getBoundingClientRect top:', containerRect.top);
        console.log('  - Différence:', rect.top - containerRect.top);
        
        // Test du scroll forcé
        console.log('🔧 Test du scroll forcé à 0...');
        viewerContainer.scrollTop = 0;
        
        setTimeout(() => {
            console.log('📊 Après scroll forcé:');
            console.log('  - Container scrollTop:', viewerContainer.scrollTop);
            
            const newRect = firstPage.getBoundingClientRect();
            const newContainerRect = viewerContainer.getBoundingClientRect();
            console.log('  - Nouvelle position page 1:', newRect.top - newContainerRect.top);
            
            // Test si la page 1 est maintenant visible
            const isVisible = newRect.top >= newContainerRect.top - 50 && newRect.top <= newContainerRect.bottom;
            console.log('  - Page 1 visible:', isVisible);
            
            if (!isVisible) {
                console.log('🚨 La page 1 n\'est toujours pas visible après scroll = 0');
                console.log('🔧 Tentative avec scrollTo...');
                viewerContainer.scrollTo(0, 0);
                
                setTimeout(() => {
                    const finalRect = firstPage.getBoundingClientRect();
                    const finalContainerRect = viewerContainer.getBoundingClientRect();
                    console.log('📊 Après scrollTo:');
                    console.log('  - Container scrollTop:', viewerContainer.scrollTop);
                    console.log('  - Position page 1:', finalRect.top - finalContainerRect.top);
                }, 100);
            }
        }, 100);
    },
    
    // Forcer la navigation vers page 1 avec debug détaillé
    forceGoToPage1: function() {
        console.log('🚨 FORCE navigation vers page 1');
        
        // Arrêter l'observer temporairement
        if (window.currentPageObserver) {
            window.currentPageObserver.disconnect();
            console.log('🔧 Observer arrêté');
        }
        
        // Force la page à 1
        currentPageNum = 1;
        updatePageInfo();
        updateActiveThumbnail();
        
        // Force le scroll
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (viewerContainer && firstPage) {
            viewerContainer.scrollTop = 0;
            console.log('🔧 Scroll forcé à 0');
            
            // Redémarrer l'observer après un délai
            setTimeout(() => {
                setupScrollObserver();
                console.log('🔧 Observer redémarré');
            }, 500);
        }
    },
    
    // Diagnostic CSS complet
    diagnoseCSSIssue: function() {
        console.log('🔬 DIAGNOSTIC CSS COMPLET');
        
        const viewerContainer = document.getElementById('viewerContainer');
        const pagesContainer = document.getElementById('pdfPagesContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        const page7 = document.getElementById('page-wrapper-7');
        
        if (!viewerContainer || !pagesContainer || !firstPage) {
            console.error('❌ Éléments manquants');
            return;
        }
        
        console.log('📊 PROPRIÉTÉS DU CONTAINER:');
        const containerStyle = window.getComputedStyle(viewerContainer);
        console.log('  - height:', containerStyle.height);
        console.log('  - max-height:', containerStyle.maxHeight);
        console.log('  - overflow-y:', containerStyle.overflowY);
        console.log('  - position:', containerStyle.position);
        console.log('  - scrollTop actuel:', viewerContainer.scrollTop);
        console.log('  - scrollHeight total:', viewerContainer.scrollHeight);
        console.log('  - clientHeight:', viewerContainer.clientHeight);
        
        console.log('📊 PROPRIÉTÉS DU PAGES CONTAINER:');
        const pagesStyle = window.getComputedStyle(pagesContainer);
        console.log('  - height:', pagesStyle.height);
        console.log('  - min-height:', pagesStyle.minHeight);
        console.log('  - padding-top:', pagesStyle.paddingTop);
        console.log('  - margin-top:', pagesStyle.marginTop);
        console.log('  - transform:', pagesStyle.transform);
        console.log('  - offsetTop:', pagesContainer.offsetTop);
        
        console.log('📊 POSITIONS DES PAGES:');
        for (let i = 1; i <= Math.min(8, pdfDoc ? pdfDoc.numPages : 0); i++) {
            const page = document.getElementById(`page-wrapper-${i}`);
            if (page) {
                const rect = page.getBoundingClientRect();
                const containerRect = viewerContainer.getBoundingClientRect();
                console.log(`  - Page ${i}: offsetTop=${page.offsetTop}, getBoundingClientRect.top=${Math.round(rect.top - containerRect.top)}`);
            }
        }
        
        console.log('🔧 TEST DE SCROLL RÉEL:');
        console.log('  - scrollTop avant test:', viewerContainer.scrollTop);
        viewerContainer.scrollTop = 0;
        console.log('  - scrollTop après scrollTop=0:', viewerContainer.scrollTop);
        
        // Vérifier si le scroll est bloqué par du CSS
        setTimeout(() => {
            console.log('  - scrollTop après 100ms:', viewerContainer.scrollTop);
            
            if (viewerContainer.scrollTop !== 0) {
                console.log('🚨 PROBLÈME DÉTECTÉ: scrollTop ne reste pas à 0 !');
                console.log('🔧 Tentative de correction CSS...');
                
                // Forcer les styles
                viewerContainer.style.scrollBehavior = 'auto';
                viewerContainer.style.overflow = 'auto';
                viewerContainer.scrollTop = 0;
                
                // Reset du container des pages
                pagesContainer.style.paddingTop = '0px';
                pagesContainer.style.marginTop = '0px';
                pagesContainer.style.transform = 'none';
                
                setTimeout(() => {
                    console.log('  - scrollTop après correction CSS:', viewerContainer.scrollTop);
                    
                    if (viewerContainer.scrollTop !== 0) {
                        console.log('🚨 ÉCHEC: Le scroll est forcé par autre chose !');
                        console.log('🔍 Investigation des éléments parents...');
                        
                        let element = viewerContainer.parentElement;
                        while (element && element !== document.body) {
                            const style = window.getComputedStyle(element);
                            if (style.overflow !== 'visible' || style.position === 'fixed' || style.position === 'absolute') {
                                console.log(`🔍 Parent suspect: ${element.className || element.tagName} - overflow:${style.overflow}, position:${style.position}`);
                            }
                            element = element.parentElement;
                        }
                    }
                }, 100);
            } else {
                console.log('✅ Scroll fonctionne - problème probablement dans la logique JavaScript');
            }
        }, 100);
    },
    
    // Correction automatique du problème détecté
    fixScrollIssue: function() {
        console.log('🛠️ CORRECTION AUTOMATIQUE DU PROBLÈME DE SCROLL');
        
        const viewerContainer = document.getElementById('viewerContainer');
        const pagesContainer = document.getElementById('pdfPagesContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (!viewerContainer || !pagesContainer || !firstPage) {
            console.error('❌ Éléments manquants');
            return;
        }
        
        console.log('🔧 Étape 1: Reset complet du CSS');
        
        // Reset du viewer container
        viewerContainer.style.scrollBehavior = 'auto';
        viewerContainer.style.height = '100%';
        viewerContainer.style.minHeight = '500px'; // Forcer une hauteur minimum
        viewerContainer.style.maxHeight = 'none';
        viewerContainer.style.overflow = 'auto';
        viewerContainer.style.position = 'relative';
        
        // Reset du pages container
        pagesContainer.style.paddingTop = '16px'; // Padding minimum
        pagesContainer.style.marginTop = '0px';
        pagesContainer.style.transform = 'none';
        pagesContainer.style.position = 'relative';
        pagesContainer.style.top = '0px';
        pagesContainer.style.left = '0px';
        
        console.log('🔧 Étape 2: Repositionnement forcé');
        
        // Forcer la restructuration du layout
        viewerContainer.style.display = 'none';
        viewerContainer.offsetHeight; // Force reflow
        viewerContainer.style.display = 'block';
        
        setTimeout(() => {
            console.log('🔧 Étape 3: Test du scroll après correction');
            viewerContainer.scrollTop = 0;
            
            setTimeout(() => {
                const rect = firstPage.getBoundingClientRect();
                const containerRect = viewerContainer.getBoundingClientRect();
                const newPosition = rect.top - containerRect.top;
                
                console.log('📊 Après correction:');
                console.log('  - Container height:', viewerContainer.clientHeight);
                console.log('  - Container scrollTop:', viewerContainer.scrollTop);
                console.log('  - Page 1 position:', newPosition);
                
                if (newPosition < -100 || newPosition > viewerContainer.clientHeight) {
                    console.log('🚨 Position toujours incorrecte, tentative manuelle...');
                    
                    // Calcul de la position correcte
                    const targetScrollTop = firstPage.offsetTop - 16; // 16px de padding
                    console.log(`🔧 Scroll calculé vers: ${targetScrollTop}px`);
                    
                    viewerContainer.scrollTop = Math.max(0, targetScrollTop);
                    
                    setTimeout(() => {
                        const finalRect = firstPage.getBoundingClientRect();
                        const finalContainerRect = viewerContainer.getBoundingClientRect();
                        const finalPosition = finalRect.top - finalContainerRect.top;
                        
                        console.log('📊 Position finale:');
                        console.log('  - scrollTop final:', viewerContainer.scrollTop);
                        console.log('  - Position page 1 finale:', finalPosition);
                        
                        if (finalPosition >= 0 && finalPosition <= 100) {
                            console.log('✅ CORRECTION RÉUSSIE !');
                            
                            // Reset de l'observer pour qu'il détecte la page 1
                            if (window.currentPageObserver) {
                                window.currentPageObserver.disconnect();
                            }
                            
                            currentPageNum = 1;
                            updatePageInfo();
                            updateActiveThumbnail();
                            
                            setTimeout(() => {
                                setupScrollObserver();
                                console.log('🔧 Observer redémarré avec page 1 active');
                            }, 200);
                            
                        } else {
                            console.log('❌ CORRECTION ÉCHEC - Position encore incorrecte');
                        }
                    }, 100);
                } else {
                    console.log('✅ CORRECTION RÉUSSIE - Page 1 maintenant visible !');
                    currentPageNum = 1;
                    updatePageInfo();
                    updateActiveThumbnail();
                }
            }, 100);
        }, 100);
    }
};

console.log('🔧 Fonctions de debug disponibles: window.pdfDebug');
console.log('   - testNavigation() : Tester la navigation');
console.log('   - checkCanvases() : Vérifier les canvas');  
console.log('   - testDrawing() : Tester le dessin');
console.log('   - goToFirst() : Aller à la page 1');
console.log('   - goToPage(n) : Aller à la page n');
console.log('   - testFullNavigation() : Test navigation complète');
console.log('   - testScrollIssue() : Test diagnostic du scroll');
console.log('   - diagnoseCSSIssue() : Diagnostic CSS complet');
console.log('   - fixScrollIssue() : NOUVEAU - Correction automatique du problème');
console.log('   - forceGoToPage1() : Force page 1 avec reset observer');
console.log('   - retryRender() : Relancer le rendu si échec');

// Fonctions de débogage pour les outils d'annotation
window.annotationDebug = {
    // Tester l'état des variables d'annotation
    checkVariables: function() {
        console.log('🎨 === ÉTAT DES VARIABLES D\'ANNOTATION ===');
        console.log('  - currentTool:', currentTool);
        console.log('  - currentAnnotationTool:', currentAnnotationTool);
        console.log('  - currentStrokeWidth:', currentStrokeWidth);
        console.log('  - currentAnnotationColor:', currentAnnotationColor);
        console.log('  - Les deux tools sont synchronisés:', currentTool === currentAnnotationTool);
    },
    
    // Tester tous les éléments DOM des outils
    checkDOMElements: function() {
        console.log('🔍 === VÉRIFICATION DES ÉLÉMENTS DOM ===');
        
        // Boutons d'outils
        const penTool = document.getElementById('penTool');
        const highlighterTool = document.getElementById('highlighterTool');
        const eraserTool = document.getElementById('eraserTool');
        
        console.log('  Boutons d\'outils:');
        console.log('    - penTool:', penTool ? 'trouvé' : 'MANQUANT', penTool);
        console.log('    - highlighterTool:', highlighterTool ? 'trouvé' : 'MANQUANT', highlighterTool);
        console.log('    - eraserTool:', eraserTool ? 'trouvé' : 'MANQUANT', eraserTool);
        
        if (penTool) console.log('    - penTool classList:', penTool.classList.toString());
        if (highlighterTool) console.log('    - highlighterTool classList:', highlighterTool.classList.toString());
        if (eraserTool) console.log('    - eraserTool classList:', eraserTool.classList.toString());
        
        // Sélecteur de couleur
        const colorPicker = document.getElementById('annotationColor');
        console.log('  - colorPicker:', colorPicker ? 'trouvé' : 'MANQUANT', colorPicker);
        if (colorPicker) {
            console.log('    - value:', colorPicker.value);
            console.log('    - disabled:', colorPicker.disabled);
        }
        
        // Curseur d'épaisseur
        const strokeWidthSlider = document.getElementById('strokeWidth');
        const strokeWidthValue = document.getElementById('strokeWidthValue');
        console.log('  - strokeWidthSlider:', strokeWidthSlider ? 'trouvé' : 'MANQUANT', strokeWidthSlider);
        console.log('  - strokeWidthValue:', strokeWidthValue ? 'trouvé' : 'MANQUANT', strokeWidthValue);
        
        if (strokeWidthSlider) {
            console.log('    - value:', strokeWidthSlider.value);
            console.log('    - min:', strokeWidthSlider.min);
            console.log('    - max:', strokeWidthSlider.max);
            console.log('    - disabled:', strokeWidthSlider.disabled);
            console.log('    - step:', strokeWidthSlider.step);
        }
        
        if (strokeWidthValue) {
            console.log('    - textContent:', strokeWidthValue.textContent);
        }
    },
    
    // Tester les événements
    testEvents: function() {
        console.log('🎯 === TEST DES ÉVÉNEMENTS ===');
        
        console.log('  Test de changement d\'outil vers pen...');
        setAnnotationTool('pen');
        this.checkVariables();
        
        setTimeout(() => {
            console.log('  Test de changement d\'outil vers highlighter...');
            setAnnotationTool('highlighter');
            this.checkVariables();
            
            setTimeout(() => {
                console.log('  Test de changement d\'outil vers eraser...');
                setAnnotationTool('eraser');
                this.checkVariables();
                
                setTimeout(() => {
                    console.log('  Test de changement de couleur...');
                    setAnnotationColor('#00ff00');
                    this.checkVariables();
                    
                    setTimeout(() => {
                        console.log('  Test de changement d\'épaisseur...');
                        setStrokeWidth(8);
                        this.checkVariables();
                    }, 500);
                }, 500);
            }, 500);
        }, 500);
    },
    
    // Tester les événements des sliders manuellement
    testSliderEvents: function() {
        console.log('🎚️ === TEST MANUEL DU SLIDER ===');
        
        const strokeWidthSlider = document.getElementById('strokeWidth');
        if (!strokeWidthSlider) {
            console.error('❌ Slider non trouvé');
            return;
        }
        
        console.log('  Valeur initiale du slider:', strokeWidthSlider.value);
        console.log('  Variable currentStrokeWidth:', currentStrokeWidth);
        
        // Simuler un changement de valeur
        console.log('  Simulation changement vers 7...');
        strokeWidthSlider.value = 7;
        
        // Déclencher l'événement manuellement
        const inputEvent = new Event('input', { bubbles: true });
        strokeWidthSlider.dispatchEvent(inputEvent);
        
        setTimeout(() => {
            console.log('  Après événement input:');
            console.log('    - slider.value:', strokeWidthSlider.value);
            console.log('    - currentStrokeWidth:', currentStrokeWidth);
            console.log('    - strokeWidthValue.textContent:', document.getElementById('strokeWidthValue')?.textContent);
        }, 100);
    },
    
    // Vérifier l'état des boutons d'outils
    checkToolButtons: function() {
        console.log('🔘 === ÉTAT DES BOUTONS D\'OUTILS ===');
        
        ['penTool', 'highlighterTool', 'eraserTool'].forEach(toolId => {
            const btn = document.getElementById(toolId);
            if (btn) {
                console.log(`  ${toolId}:`);
                console.log(`    - active: ${btn.classList.contains('active')}`);
                console.log(`    - disabled: ${btn.disabled}`);
                console.log(`    - onclick: ${btn.onclick ? 'défini' : 'NON DÉFINI'}`);
                console.log(`    - classList: ${btn.classList.toString()}`);
            } else {
                console.log(`  ${toolId}: INTROUVABLE`);
            }
        });
    },
    
    // Test complet
    fullTest: function() {
        console.log('🧪 === TEST COMPLET DES OUTILS D\'ANNOTATION ===');
        this.checkVariables();
        this.checkDOMElements();
        this.checkToolButtons();
        
        setTimeout(() => {
            this.testSliderEvents();
        }, 1000);
        
        setTimeout(() => {
            this.testEvents();
        }, 2000);
    },
    
    // Surveiller en temps réel qui efface les annotations
    watchAnnotations: function() {
        console.log('🔍 === SURVEILLANCE DES ANNOTATIONS ACTIVÉE ===');
        
        // Intercepter les appels à clearRect (qui efface le canvas)
        if (annotationCtx) {
            const originalClearRect = annotationCtx.clearRect;
            annotationCtx.clearRect = function(...args) {
                console.log('🧹 CANVAS EFFACÉ ! Par qui ?');
                console.trace('📍 Trace de l\'effacement:');
                return originalClearRect.apply(this, args);
            };
            console.log('✅ Surveillance clearRect activée');
        }
        
        // Surveiller les changements de la variable annotations
        let annotationsLength = annotations.length;
        const checkAnnotations = () => {
            if (annotations.length !== annotationsLength) {
                console.log(`📊 CHANGEMENT DÉTECTÉ: annotations.length ${annotationsLength} → ${annotations.length}`);
                console.trace('📍 Trace du changement:');
                annotationsLength = annotations.length;
            }
            
            // Surveiller aussi annotationsByPage
            if (annotationsByPage[currentPageNum]) {
                const pageAnnotationsLength = annotationsByPage[currentPageNum].length;
                setTimeout(() => {
                    if (annotationsByPage[currentPageNum] && annotationsByPage[currentPageNum].length !== pageAnnotationsLength) {
                        console.log(`📊 CHANGEMENT annotationsByPage[${currentPageNum}]: ${pageAnnotationsLength} → ${annotationsByPage[currentPageNum].length}`);
                        console.trace('📍 Trace du changement annotationsByPage:');
                    }
                }, 10);
            }
        };
        
        // Vérifier toutes les 100ms
        const interval = setInterval(checkAnnotations, 100);
        
        console.log('✅ Surveillance des variables activée (toutes les 100ms)');
        console.log('Pour arrêter: clearInterval(' + interval + ')');
        
        return interval;
    },
    
    // Forcer la réinitialisation des outils
    resetTools: function() {
        console.log('🔄 === RÉINITIALISATION FORCÉE DES OUTILS ===');
        
        // Réinitialiser les variables
        currentTool = 'pen';
        currentAnnotationTool = 'pen';
        currentStrokeWidth = 3;
        currentColor = '#ff0000';
        currentAnnotationColor = '#ff0000';
        
        // Réinitialiser l'interface
        setAnnotationTool('pen');
        setStrokeWidth(3);
        setAnnotationColor('#ff0000');
        
        console.log('✅ Outils réinitialisés');
        this.checkVariables();
    },
    
    // Reconfigurer manuellement les événements
    rebindEvents: function() {
        console.log('🔄 === RECONFIGURATION DES ÉVÉNEMENTS ===');
        
        // Supprimer les anciens événements en clonant les éléments
        const toolButtons = document.querySelectorAll('[data-tool]');
        console.log('🔘 Reconfiguration de', toolButtons.length, 'boutons d\'outils');
        
        toolButtons.forEach((btn, index) => {
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', () => {
                console.log('🖱️ [REBOUND] Clic sur bouton outil:', newBtn.dataset.tool);
                setAnnotationTool(newBtn.dataset.tool);
            });
            
            console.log(`  ✅ Bouton ${index} reconfiguré: ${newBtn.id} (${newBtn.dataset.tool})`);
        });
        
        // Reconfigurer les couleurs
        const colorButtons = document.querySelectorAll('.color-btn');
        console.log('🎨 Reconfiguration de', colorButtons.length, 'boutons de couleur');
        
        colorButtons.forEach(btn => {
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', () => {
                console.log('🖱️ [REBOUND] Clic sur couleur:', newBtn.dataset.color);
                setAnnotationColor(newBtn.dataset.color);
            });
        });
        
        // Reconfigurer le slider d'épaisseur
        const strokeWidthSlider = document.getElementById('strokeWidth');
        if (strokeWidthSlider) {
            console.log('📏 Reconfiguration du slider d\'épaisseur');
            
            // Cloner le slider pour supprimer les anciens événements
            const newSlider = strokeWidthSlider.cloneNode(true);
            strokeWidthSlider.parentNode.replaceChild(newSlider, strokeWidthSlider);
            
            // Réattacher les événements
            newSlider.addEventListener('input', (e) => {
                console.log('🖱️ [REBOUND] Slider input:', e.target.value);
                setStrokeWidth(e.target.value);
            });
            
            newSlider.addEventListener('change', (e) => {
                console.log('🖱️ [REBOUND] Slider change:', e.target.value);
                setStrokeWidth(e.target.value);
            });
            
            console.log('✅ Slider d\'épaisseur reconfiguré');
        } else {
            console.warn('⚠️ Slider d\'épaisseur non trouvé');
        }
        
        // Reconfigurer le color picker
        const colorPicker = document.getElementById('annotationColor');
        if (colorPicker) {
            console.log('🎨 Reconfiguration du color picker');
            
            const newColorPicker = colorPicker.cloneNode(true);
            colorPicker.parentNode.replaceChild(newColorPicker, colorPicker);
            
            newColorPicker.addEventListener('change', (e) => {
                console.log('🖱️ [REBOUND] Color picker:', e.target.value);
                setAnnotationColor(e.target.value);
            });
            
            console.log('✅ Color picker reconfiguré');
        }
        
        console.log('✅ Tous les événements reconfigurés');
    },
    
    // Forcer l'affichage des annotations de la page actuelle
    forceShowAnnotations: function() {
        console.log('🎨 === AFFICHAGE FORCÉ DES ANNOTATIONS ===');
        console.log(`📄 Page actuelle: ${currentPageNum}`);
        console.log(`📊 Annotations disponibles: ${annotations.length}`);
        console.log(`📊 Canvas disponible: ${!!annotationCtx}`);
        console.log(`📊 isDrawing: ${isDrawing}`);
        
        if (annotationCtx) {
            const wasDrawing = isDrawing;
            isDrawing = false; // Forcer isDrawing à false
            console.log('🔄 Forçage du redessinage...');
            redrawAnnotations(true);
            isDrawing = wasDrawing; // Restaurer l'état
            console.log('✅ Redessinage forcé terminé');
        } else {
            console.log('❌ Canvas non disponible');
        }
    }
};

console.log('🎨 Fonctions de debug annotation disponibles: window.annotationDebug');
console.log('   - checkVariables() : Vérifier l\'état des variables');
console.log('   - checkDOMElements() : Vérifier les éléments DOM');
console.log('   - testEvents() : Tester les changements d\'outils');
console.log('   - testSliderEvents() : Tester le slider manuellement');
console.log('   - checkToolButtons() : Vérifier l\'état des boutons');
console.log('   - fullTest() : Test complet de tous les outils');
console.log('   - resetTools() : Réinitialiser tous les outils');
console.log('   - rebindEvents() : Reconfigurer les événements des boutons');
console.log('   - watchAnnotations() : Surveiller qui efface les annotations');
console.log('   - forceShowAnnotations() : NOUVEAU - Forcer l\'affichage des annotations');

// Fonction de correction automatique du scroll (appliquée à chaque chargement de PDF)
function applyScrollFix() {
    console.log('🛠️ Application automatique de la correction de scroll...');
    
    const viewerContainer = document.getElementById('viewerContainer');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    const firstPage = document.getElementById('page-wrapper-1');
    
    if (!viewerContainer || !pagesContainer || !firstPage) {
        console.warn('⚠️ Éléments non trouvés pour la correction - retry dans 100ms');
        setTimeout(applyScrollFix, 100);
        return;
    }
    
    // Vérifier si la correction est nécessaire
    const rect = firstPage.getBoundingClientRect();
    const containerRect = viewerContainer.getBoundingClientRect();
    const pagePosition = rect.top - containerRect.top;
    
    console.log(`📊 Position actuelle de la page 1: ${Math.round(pagePosition)}px`);
    
    // Si la page 1 est très mal positionnée, appliquer la correction
    if (pagePosition < -100 || pagePosition > viewerContainer.clientHeight) {
        console.log('🚨 Correction nécessaire - page 1 mal positionnée');
        
        // Appliquer les corrections CSS
        viewerContainer.style.scrollBehavior = 'auto';
        viewerContainer.style.height = '100%';
        viewerContainer.style.minHeight = '500px';
        viewerContainer.style.maxHeight = 'none';
        viewerContainer.style.overflow = 'auto';
        viewerContainer.style.position = 'relative';
        
        // Reset du pages container
        pagesContainer.style.paddingTop = '16px';
        pagesContainer.style.marginTop = '0px';
        pagesContainer.style.transform = 'none';
        pagesContainer.style.position = 'relative';
        pagesContainer.style.top = '0px';
        pagesContainer.style.left = '0px';
        
        // Forcer le reflow
        viewerContainer.style.display = 'none';
        viewerContainer.offsetHeight; // Force reflow
        viewerContainer.style.display = 'block';
        
        setTimeout(() => {
            // Vérifier et ajuster le scroll
            const newRect = firstPage.getBoundingClientRect();
            const newContainerRect = viewerContainer.getBoundingClientRect();
            const newPosition = newRect.top - newContainerRect.top;
            
            console.log(`📊 Position après correction CSS: ${Math.round(newPosition)}px`);
            
            if (newPosition < -50 || newPosition > 100) {
                // Correction manuelle du scroll
                const targetScrollTop = firstPage.offsetTop - 16;
                viewerContainer.scrollTop = Math.max(0, targetScrollTop);
                console.log(`🔧 Scroll manuel appliqué: ${viewerContainer.scrollTop}px`);
            }
            
            // Forcer la page courante à 1
            currentPageNum = 1;
            updatePageInfo();
            updateActiveThumbnail();
            
            // Redémarrer l'observer après correction
            if (window.currentPageObserver) {
                window.currentPageObserver.disconnect();
                setTimeout(() => {
                    setupScrollObserver();
                    console.log('✅ Correction automatique terminée - Page 1 active');
                }, 100);
            }
        }, 50);
    } else {
        console.log('✅ Position correcte - aucune correction nécessaire');
        // Juste s'assurer qu'on est à la page 1
        viewerContainer.scrollTop = 0;
        currentPageNum = 1;
        updatePageInfo();
        updateActiveThumbnail();
    }
}

// Rendre une page individuelle dans le mode multi-pages
async function renderSinglePage(pageNum, pdfCanvas, annotationCanvas) {
    try {
        const page = await pdfDoc.getPage(pageNum);
        const defaultScale = 1.5;
        const viewport = page.getViewport({ scale: defaultScale * currentScale });
        
        // Ajuster les dimensions du canvas
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        annotationCanvas.width = viewport.width;
        annotationCanvas.height = viewport.height;
        
        // Ajuster les styles
        pdfCanvas.style.width = viewport.width + 'px';
        pdfCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.width = viewport.width + 'px';
        annotationCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.position = 'absolute';
        annotationCanvas.style.top = '0';
        annotationCanvas.style.left = '0';
        
        const ctx = pdfCanvas.getContext('2d');
        
        // Rendre la page PDF
        const renderContext = {
            canvasContext: ctx,
            viewport: viewport,
            renderTextLayer: false,
            renderAnnotationLayer: false
        };
        
        await page.render(renderContext).promise;
        
        // Dessiner les annotations existantes pour cette page
        const annotCtx = annotationCanvas.getContext('2d');
        if (annotationsByPage[pageNum]) {
            redrawAnnotations(annotCtx, annotationsByPage[pageNum]);
        }
        
    } catch (error) {
        console.error(`Erreur lors du rendu de la page ${pageNum}:`, error);
    }
}

// Configurer les événements d'annotation pour le mode multi-pages
function setupMultiPageAnnotations() {
    console.log('🔍 DEBUG: setupMultiPageAnnotations - Début');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (!pagesContainer) {
        console.error('❌ pdfPagesContainer non trouvé dans setupMultiPageAnnotations');
        return;
    }
    
    let canvasCount = 0;
    
    // Ajouter les événements à chaque canvas d'annotation
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const annotationCanvas = document.getElementById(`annotation-canvas-${pageNum}`);
        if (annotationCanvas) {
            canvasCount++;
            // Ajouter les attributs de page
            annotationCanvas.dataset.pageNum = pageNum;
            
            // S'assurer que le canvas est bien positionné
            annotationCanvas.style.pointerEvents = 'auto';
            annotationCanvas.style.cursor = currentTool === 'eraser' ? 'crosshair' : 'default';
            
            // Événements souris
            annotationCanvas.addEventListener('mousedown', (e) => startDrawingMultiPage(e, pageNum));
            annotationCanvas.addEventListener('mousemove', (e) => drawMultiPage(e, pageNum));
            annotationCanvas.addEventListener('mouseup', (e) => stopDrawingMultiPage(e, pageNum));
            annotationCanvas.addEventListener('mouseleave', (e) => stopDrawingMultiPage(e, pageNum));
            
            // Événements tactiles
            annotationCanvas.addEventListener('touchstart', (e) => handleTouchMultiPage(e, pageNum), { passive: false });
            annotationCanvas.addEventListener('touchmove', (e) => handleTouchMultiPage(e, pageNum), { passive: false });
            annotationCanvas.addEventListener('touchend', (e) => handleTouchMultiPage(e, pageNum), { passive: false });
        } else {
            console.warn(`⚠️ Canvas d'annotation non trouvé pour la page ${pageNum}`);
        }
    }
    
    console.log(`✅ setupMultiPageAnnotations - ${canvasCount} canvas configurés sur ${pdfDoc.numPages} pages`);
}

// Gérer le début du dessin en mode multi-pages
function startDrawingMultiPage(e, pageNum) {
    console.log(`🖊️ DEBUG: startDrawingMultiPage - Page ${pageNum}, Tool: ${currentTool}`);
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    isDrawing = true;
    currentPageNum = pageNum;
    annotationCanvas = e.target;
    annotationCtx = annotationCanvas.getContext('2d');
    
    // Configurer le contexte d'annotation
    annotationCtx.lineCap = 'round';
    annotationCtx.lineJoin = 'round';
    annotationCtx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
    annotationCtx.lineWidth = currentStrokeWidth;
    annotationCtx.strokeStyle = currentColor;
    
    if (currentTool === 'eraser') {
        console.log('🔍 Mode gomme activé');
        eraseAt(x, y);
    } else {
        console.log('✏️ Mode dessin activé - Début du trait');
        // Commencer un nouveau trait
        currentAnnotation = {
            type: currentTool,
            color: currentColor,
            strokeWidth: currentStrokeWidth,
            points: [{ x, y }],
            page: pageNum
        };
        
        annotationCtx.beginPath();
        annotationCtx.moveTo(x, y);
    }
}

// Gérer le dessin en mode multi-pages
function drawMultiPage(e, pageNum) {
    if (!isDrawing || pageNum !== currentPageNum) return;
    
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (currentTool === 'eraser') {
        eraseAt(x, y);
    } else {
        // Continuer le trait
        if (currentAnnotation) {
            currentAnnotation.points.push({ x, y });
            annotationCtx.lineTo(x, y);
            annotationCtx.stroke();
        }
    }
}

// Arrêter le dessin en mode multi-pages
function stopDrawingMultiPage(e, pageNum) {
    if (!isDrawing) return;
    
    isDrawing = false;
    
    // Sauvegarder l'annotation pour cette page
    if (currentAnnotation && currentAnnotation.points.length > 0) {
        currentAnnotation.page = pageNum;
        
        if (!annotationsByPage[pageNum]) {
            annotationsByPage[pageNum] = [];
        }
        annotationsByPage[pageNum].push(currentAnnotation);
        
        // Ajouter à la liste globale
        annotations.push(currentAnnotation);
    }
    
    currentAnnotation = null;
    
    // Programmer la sauvegarde automatique
    if (typeof scheduleAutoSave === 'function') {
        scheduleAutoSave();
    } else {
        // Sauvegarde immédiate si la fonction n'existe pas
        setTimeout(() => {
            saveAnnotations();
        }, 1000);
    }
}

// Gérer les événements tactiles en mode multi-pages
function handleTouchMultiPage(e, pageNum) {
    e.preventDefault();
    
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(
            e.type === 'touchstart' ? 'mousedown' : 
            e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
            {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            }
        );
        
        if (e.type === 'touchstart') {
            startDrawingMultiPage(mouseEvent, pageNum);
        } else if (e.type === 'touchmove') {
            drawMultiPage(mouseEvent, pageNum);
        } else if (e.type === 'touchend') {
            stopDrawingMultiPage(mouseEvent, pageNum);
        }
    }
}

// Observer le scroll pour détecter la page visible
function setupScrollObserver() {
    const viewerContainer = document.getElementById('viewerContainer');
    if (!viewerContainer) return;
    
    // Configuration plus permissive pour détecter toutes les pages, y compris celles du haut
    const observerOptions = {
        root: viewerContainer,
        rootMargin: '0px 0px 0px 0px', // Pas de marge pour garantir la détection des pages du haut
        threshold: [0.1, 0.3, 0.5, 0.7, 0.9] // Plus de seuils pour une détection plus précise
    };
    
    const pageObserver = new IntersectionObserver((entries) => {
        let maxIntersectionRatio = 0;
        let mostVisiblePage = currentPageNum;
        
        entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > maxIntersectionRatio) {
                maxIntersectionRatio = entry.intersectionRatio;
                const pageWrapper = entry.target;
                const pageNum = parseInt(pageWrapper.id.replace('page-wrapper-', ''));
                if (pageNum) {
                    mostVisiblePage = pageNum;
                }
            }
        });
        
        // Mettre à jour seulement si la page la plus visible a changé ET si le ratio d'intersection est significatif
        // ET si on n'est pas en train de charger les annotations initiales
        if (mostVisiblePage !== currentPageNum && maxIntersectionRatio > 0.3 && !isLoadingInitialAnnotations) {
            console.log(`🔄 === CHANGEMENT DE PAGE VIA OBSERVER ===`);
            console.log(`📄 Page visible changée: ${currentPageNum} → ${mostVisiblePage} (ratio: ${maxIntersectionRatio.toFixed(2)})`);
            
            const oldPageNum = currentPageNum;
            currentPageNum = mostVisiblePage;
            
            console.log(`📊 Avant changement - annotations page ${oldPageNum}: ${annotations.length}`);
            console.log(`🔄 Chargement des annotations pour la nouvelle page ${currentPageNum}...`);
            
            // IMPORTANT: Réinitialiser les variables de dessin lissé lors du changement de page
            resetSmoothDrawingVariables();
            
            // Charger les annotations de la nouvelle page
            loadPageAnnotations(currentPageNum);
            
            // NOUVEAU: Forcer le redessinage après changement de page
            setTimeout(() => {
                if (annotationCtx && annotations.length > 0) {
                    console.log(`🎨 REDESSINAGE POST-CHANGEMENT PAGE - ${annotations.length} annotations pour page ${currentPageNum}`);
                    const wasDrawing = isDrawing;
                    isDrawing = false; // Temporairement désactiver isDrawing
                    redrawAnnotations(true);
                    isDrawing = wasDrawing; // Restaurer l'état précédent
                } else {
                    console.log(`ℹ️ Aucune annotation à redessiner pour la page ${currentPageNum}`);
                }
            }, 100);
            
            updatePageInfo();
            updateActiveThumbnail();
            
            console.log(`🏁 === FIN CHANGEMENT DE PAGE ===`);
        } else if (isLoadingInitialAnnotations) {
            console.log(`⏸️ Observer en pause - chargement initial des annotations en cours`);
        }
    }, observerOptions);
    
    // Stocker une référence globale pour pouvoir le réinitialiser
    window.currentPageObserver = pageObserver;
    
    // Observer toutes les pages
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
        if (pageWrapper) {
            pageObserver.observe(pageWrapper);
            console.log(`📄 Observing page ${pageNum}`);
        }
    }
    
    // Ajouter un listener de scroll de secours pour garantir la navigation
    let scrollTimeout;
    viewerContainer.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            // Détecter manuellement quelle page est la plus visible
            let mostVisiblePage = 1;
            let maxVisibleArea = 0;
            
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
                if (pageWrapper) {
                    const rect = pageWrapper.getBoundingClientRect();
                    const containerRect = viewerContainer.getBoundingClientRect();
                    
                    // Calculer la surface visible
                    const visibleTop = Math.max(rect.top, containerRect.top);
                    const visibleBottom = Math.min(rect.bottom, containerRect.bottom);
                    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                    const visibleArea = visibleHeight * rect.width;
                    
                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        mostVisiblePage = pageNum;
                    }
                }
            }
            
            if (mostVisiblePage !== currentPageNum) {
                console.log(`📄 Scroll detection: Page ${currentPageNum} → ${mostVisiblePage}`);
                currentPageNum = mostVisiblePage;
                updatePageInfo();
                updateActiveThumbnail();
            }
        }, 100);
    });
}

// Rendre une page PDF (fonction originale pour compatibilité)
async function renderPage(pageNum) {
    if (pageIsRendering) {
        pageNumIsPending = pageNum;
        return;
    }
    
    // Ne pas rerender si on est en train de dessiner
    if (isDrawing) {
        console.log('renderPage delayed - currently drawing');
        pageNumIsPending = pageNum;
        return;
    }
    
    pageIsRendering = true;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        
        // Calculer la viewport avec une échelle plus élevée pour la qualité
        const baseScale = 2.0; // Base scale pour la qualité
        const displayScale = currentScale;
        const renderScale = baseScale * displayScale;
        
        const viewport = page.getViewport({ scale: renderScale });
        
        // Configurer les canvas
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        
        // Ne redimensionner le canvas d'annotation que si nécessaire
        if (annotationCanvas.width !== viewport.width || annotationCanvas.height !== viewport.height) {
            console.log('📐 Resizing annotation canvas from', annotationCanvas.width, 'x', annotationCanvas.height, 'to', viewport.width, 'x', viewport.height);
            
            // Si on est en train de dessiner, arrêter le trait en cours
            if (isDrawing) {
                console.warn('⚠️ Canvas resize during drawing! Stopping current stroke...');
                isDrawing = false;
                currentStroke = [];
            }
            
            annotationCanvas.width = viewport.width;
            annotationCanvas.height = viewport.height;
            
            // Récréer le contexte après redimensionnement
            annotationCtx = annotationCanvas.getContext('2d');
            ctx = annotationCtx; // Variable de compatibilité
            
            // Forcer le repositionnement après redimensionnement
            forceCanvasPositioning();
        }
        
        // Appliquer le scale CSS pour l'affichage
        const cssScale = displayScale / baseScale;
        const transform = `scale(${cssScale})`;
        
        // D'abord définir les dimensions CSS explicites AVANT la transformation
        pdfCanvas.style.width = viewport.width + 'px';
        pdfCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.width = viewport.width + 'px';
        annotationCanvas.style.height = viewport.height + 'px';
        
        // Ensuite appliquer la transformation
        pdfCanvas.style.transform = transform;
        annotationCanvas.style.transform = transform;
        pdfCanvas.style.transformOrigin = '0 0';
        annotationCanvas.style.transformOrigin = '0 0';
        
        // Ajuster la taille du conteneur pour contenir les canvas transformés
        const container = pdfCanvas.parentElement;
        const containerWidth = viewport.width * cssScale;
        const containerHeight = viewport.height * cssScale;
        
        container.style.width = containerWidth + 'px';
        container.style.height = containerHeight + 'px';
        
        // Rendre la page
        const renderContext = {
            canvasContext: pdfCtx,
            viewport: viewport
        };
        
        await page.render(renderContext).promise;
        
        // Redessiner les annotations (seulement si on n'est pas en train de charger les annotations initiales)
        if (!isLoadingInitialAnnotations) {
            redrawAnnotations();
        } else {
            console.log('📄 Redessinage d\'annotations sauté - chargement initial en cours');
        }
        
        // Forcer l'alignement parfait des canvas après le rendu
        forceCanvasPositioning();
        
        pageIsRendering = false;
        
        // Rendre une page en attente si nécessaire
        if (pageNumIsPending !== null) {
            const pending = pageNumIsPending;
            pageNumIsPending = null;
            await renderPage(pending);
        }
        
    } catch (error) {
        console.error('Erreur lors du rendu de la page:', error);
        pageIsRendering = false;
    }
}

// Charger une image avec qualité améliorée
async function loadImage(fileId) {
    const imageUrl = `/file_manager/serve_file/${fileId}`;
    
    try {
        const img = new Image();
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = imageUrl;
        });
        
        // Configurer les canvas pour l'image
        const scale = Math.min(800 / img.width, 600 / img.height, 2.0);
        const width = img.width * scale;
        const height = img.height * scale;
        
        pdfCanvas.width = width;
        pdfCanvas.height = height;
        annotationCanvas.width = width;
        annotationCanvas.height = height;
        
        // Dessiner l'image avec anti-aliasing
        pdfCtx.imageSmoothingEnabled = true;
        pdfCtx.imageSmoothingQuality = 'high';
        pdfCtx.drawImage(img, 0, 0, width, height);
        
        // Masquer les contrôles PDF (supprimés)
        
    } catch (error) {
        console.error('Erreur lors du chargement de l\'image:', error);
        throw error;
    }
}

// ===== FONCTIONS DE NAVIGATION PDF =====

// Navigation entre pages
// Fonction previousPage() supprimée - navigation via scroll uniquement
/*
function previousPage() {
    if (currentPageNum <= 1 || !pdfDoc) return;
    if (isDrawing) {
        console.log('previousPage delayed - currently drawing');
        return;
    }
    
    isNavigating = true; // Marquer le début de la navigation
    
    // En mode multi-pages, faire défiler jusqu'à la page
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (pagesContainer) {
        currentPageNum--;
        const targetPage = document.getElementById(`page-wrapper-${currentPageNum}`);
        if (targetPage) {
            targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    } else {
        // Mode single page - ancien comportement
        // Sauvegarder les annotations de la page actuelle avant de changer
        console.log(`📄 Changement de page ${currentPageNum} vers ${currentPageNum - 1}`);
        saveCurrentPageAnnotations();
        
        currentPageNum--;
        
        // Charger les annotations de la nouvelle page AVANT de rendre
        loadPageAnnotations(currentPageNum);
        
        renderPage(currentPageNum);
    }
    
    updatePageInfo();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}
*/

// Fonction nextPage() supprimée - navigation via scroll uniquement  
/*
function nextPage() {
    if (currentPageNum >= pdfDoc.numPages || !pdfDoc) return;
    if (isDrawing) {
        console.log('nextPage delayed - currently drawing');
        return;
    }
    
    isNavigating = true; // Marquer le début de la navigation
    
    // En mode multi-pages, faire défiler jusqu'à la page
    const pagesContainer = document.getElementById('pdfPagesContainer');
    if (pagesContainer) {
        currentPageNum++;
        const targetPage = document.getElementById(`page-wrapper-${currentPageNum}`);
        if (targetPage) {
            targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    } else {
        // Mode single page - ancien comportement
        // Sauvegarder les annotations de la page actuelle avant de changer
        console.log(`📄 Changement de page ${currentPageNum} vers ${currentPageNum + 1}`);
        saveCurrentPageAnnotations();
        
        currentPageNum++;
        
        // Charger les annotations de la nouvelle page AVANT de rendre
        loadPageAnnotations(currentPageNum);
        
        renderPage(currentPageNum);
    }
    
    updatePageInfo();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}
*/

function goToPage(pageNum) {
    console.log(`🔍 DEBUG: goToPage - Aller à la page ${pageNum}`);
    if (pageNum < 1 || pageNum > pdfDoc.numPages) {
        console.warn(`⚠️ Page ${pageNum} hors limites (1-${pdfDoc.numPages})`);
        return;
    }
    if (pageNum === currentPageNum) {
        console.log('ℹ️ Déjà sur cette page');
        return; // Déjà sur cette page
    }
    
    isNavigating = true; // Marquer le début de la navigation
    
    // En mode multi-pages, faire défiler jusqu'à la page
    const pagesContainer = document.getElementById('pdfPagesContainer');
    const viewerContainer = document.getElementById('viewerContainer');
    
    if (pagesContainer && pagesContainer.children.length > 0 && viewerContainer) {
        console.log('📄 Mode multi-pages - Navigation vers la page', pageNum);
        const targetPage = document.getElementById(`page-wrapper-${pageNum}`);
        
        if (targetPage) {
            // Méthode 1: ScrollIntoView avec behavior instant pour éviter les blocages
            console.log('🎯 ScrollIntoView instant');
            targetPage.scrollIntoView({ behavior: 'instant', block: 'start' });
            
            // Méthode 2: Calcul manuel de la position si scrollIntoView échoue
            setTimeout(() => {
                const targetRect = targetPage.getBoundingClientRect();
                const containerRect = viewerContainer.getBoundingClientRect();
                
                // Si la page n'est pas visible après scrollIntoView, utiliser offsetTop
                if (targetRect.top < containerRect.top - 50 || targetRect.top > containerRect.bottom + 50) {
                    console.log('🚨 ScrollIntoView échoué, calcul manuel de la position');
                    const targetOffset = targetPage.offsetTop;
                    const containerPadding = 16; // padding du container
                    const scrollPosition = Math.max(0, targetOffset - containerPadding);
                    
                    console.log(`📊 Target offset: ${targetOffset}, scroll to: ${scrollPosition}`);
                    viewerContainer.scrollTop = scrollPosition;
                    
                    // Vérification finale
                    setTimeout(() => {
                        const finalRect = targetPage.getBoundingClientRect();
                        const finalContainerRect = viewerContainer.getBoundingClientRect();
                        const isVisible = finalRect.top >= finalContainerRect.top && finalRect.top <= finalContainerRect.bottom;
                        console.log(`✅ Page ${pageNum} ${isVisible ? 'visible' : 'TOUJOURS INVISIBLE'} après navigation manuelle`);
                        
                        if (!isVisible) {
                            // Dernière tentative: scroll avec scrollTo
                            viewerContainer.scrollTo(0, scrollPosition);
                            console.log('🔧 Tentative scrollTo finale');
                        }
                    }, 50);
                }
            }, 50);
            
            // Mettre à jour l'état de la page
            currentPageNum = pageNum;
            updatePageInfo();
            updateActiveThumbnail();
            
            console.log(`✅ Navigation vers page ${pageNum} initiée`);
        } else {
            console.error(`❌ page-wrapper-${pageNum} non trouvé`);
            console.log('Pages disponibles:', Array.from(pagesContainer.children).map(c => c.id));
        }
    } else {
        // Mode single page - ancien comportement
        console.log('📄 Mode single page - Render page');
        console.log('pagesContainer trouvé:', !!pagesContainer, 'Enfants:', pagesContainer ? pagesContainer.children.length : 0);
        
        // Sauvegarder les annotations de la page actuelle avant de changer
        saveCurrentPageAnnotations();
        
        currentPageNum = pageNum;
        
        // Charger les annotations de la nouvelle page AVANT de rendre
        loadPageAnnotations(currentPageNum);
        
        renderPage(currentPageNum);
    }
    
    updatePageInfo();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}

// Fonction pour calculer les coordonnées du canvas - corrigée pour la scale CSS
function getCanvasCoordinates(e) {
    try {
        // Utiliser getBoundingClientRect pour obtenir la position et taille actuelles du canvas
        const rect = annotationCanvas.getBoundingClientRect();
        
        // Vérifier si la souris est au-dessus du canvas
        const isOverCanvas = (
            e.clientX >= rect.left && 
            e.clientX <= rect.right && 
            e.clientY >= rect.top && 
            e.clientY <= rect.bottom
        );
        
        // Calculer les coordonnées relatives au canvas visible
        // Important: utiliser rect.width/height (taille visible) plutôt que canvas.width/height (taille logique)
        const x = (e.clientX - rect.left) * (annotationCanvas.width / rect.width);
        const y = (e.clientY - rect.top) * (annotationCanvas.height / rect.height);
        
        // Debug temporaire pour vérifier les calculs
        if (Math.random() < 0.05) { // Log 5% des événements pour éviter le spam
            console.log('🔍 Coordinate calculation:');
            console.log('  Mouse screen:', e.clientX, e.clientY);
            console.log('  Canvas rect (visible):', Math.round(rect.left), Math.round(rect.top), Math.round(rect.width), Math.round(rect.height));
            console.log('  Canvas logical:', annotationCanvas.width, annotationCanvas.height);
            console.log('  Scale factors:', Math.round(annotationCanvas.width / rect.width * 100) / 100, Math.round(annotationCanvas.height / rect.height * 100) / 100);
            console.log('  Calculated coords:', Math.round(x), Math.round(y));
            console.log('  Within bounds:', x >= 0 && x <= annotationCanvas.width && y >= 0 && y <= annotationCanvas.height);
        }
        
        // Retourner les coordonnées, en s'assurant qu'elles restent dans les limites du canvas logique
        return { 
            x: Math.max(0, Math.min(x, annotationCanvas.width - 1)),
            y: Math.max(0, Math.min(y, annotationCanvas.height - 1)),
            isOverCanvas: isOverCanvas
        };
        
    } catch (error) {
        console.error('❌ Erreur dans getCanvasCoordinates:', error);
        
        // Retourner une coordonnée sûre en cas d'erreur
        return { x: 0, y: 0, isOverCanvas: false };
    }
}

// Fonctions de zoom supprimées - non utilisées

// Mettre à jour les informations de page
function updatePageInfo() {
    // Fonction simplifiée - plus d'affichage d'info de page dans l'interface
    // Les informations de page sont gérées via les miniatures et le scroll
    if (pdfDoc) {
        console.log(`📄 Page actuelle: ${currentPageNum} / ${pdfDoc.numPages}`);
    }
}

// Fonction de navigation supprimée - plus utilisée

// Générer les miniatures
async function generateThumbnails() {
    if (!pdfDoc) return;
    
    const thumbnailsContainer = document.getElementById('pageThumbnails');
    thumbnailsContainer.innerHTML = '';
    
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const thumbnailItem = document.createElement('div');
        thumbnailItem.className = 'thumbnail-item';
        if (pageNum === currentPageNum) thumbnailItem.classList.add('active');
        
        const thumbnailCanvas = document.createElement('canvas');
        thumbnailCanvas.className = 'thumbnail-canvas';
        thumbnailCanvas.onclick = () => goToPage(pageNum);
        
        try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 0.3 });
            
            thumbnailCanvas.width = viewport.width;
            thumbnailCanvas.height = viewport.height;
            
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            await page.render({
                canvasContext: thumbnailCtx,
                viewport: viewport
            }).promise;
            
        } catch (error) {
            console.error(`Erreur lors de la génération de la miniature ${pageNum}:`, error);
        }
        
        const pageLabel = document.createElement('div');
        pageLabel.textContent = pageNum;
        pageLabel.style.textAlign = 'center';
        pageLabel.style.color = '#e2e8f0';
        pageLabel.style.fontSize = '0.8rem';
        pageLabel.style.marginTop = '0.25rem';
        
        thumbnailItem.appendChild(thumbnailCanvas);
        thumbnailItem.appendChild(pageLabel);
        thumbnailsContainer.appendChild(thumbnailItem);
    }
}

function updateActiveThumbnail() {
    document.querySelectorAll('.thumbnail-item').forEach((item, index) => {
        item.classList.toggle('active', index + 1 === currentPageNum);
    });
}

// Barre latérale permanente - plus besoin de toggle

// ===== SYSTÈME D'ANNOTATION AMÉLIORÉ =====

// Système d'annotation amélioré
function setupAnnotationTools() {
    if (!annotationCanvas) {
        console.error('annotationCanvas not found!');
        return;
    }
    
    console.log('Setting up annotation tools on canvas:', annotationCanvas);
    
    // Debug des styles CSS
    const computedStyle = window.getComputedStyle(annotationCanvas);
    console.log('Canvas CSS styles:');
    console.log('  pointer-events:', computedStyle.pointerEvents);
    console.log('  z-index:', computedStyle.zIndex);
    console.log('  position:', computedStyle.position);
    console.log('  display:', computedStyle.display);
    console.log('  visibility:', computedStyle.visibility);
    
    // Événements de dessin simplifiés
    console.log('Attaching mousedown event listener...');
    annotationCanvas.addEventListener('mousedown', (e) => {
        console.log('🔽 MOUSEDOWN EVENT');
        startDrawing(e);
    });
    
    console.log('Attaching mousemove event listener to DOCUMENT (for global coverage)...');
    document.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            draw(e);
        }
    });
    
    console.log('Attaching mouseup event listener to DOCUMENT (for global coverage)...');
    document.addEventListener('mouseup', (e) => {
        console.log('🔼 MOUSEUP EVENT');
        stopDrawing(e);
    });
    
    console.log('Attaching mouseout event listener (for debugging only)...');
    annotationCanvas.addEventListener('mouseout', (e) => {
        console.log('🚪 MOUSEOUT EVENT (ignored)');
        // NE PAS appeler stopDrawing() ici - l'utilisateur doit pouvoir dessiner hors du canvas
    });
    
    // Support tactile
    annotationCanvas.addEventListener('touchstart', handleTouch, { passive: false });
    annotationCanvas.addEventListener('touchmove', handleTouch, { passive: false });
    annotationCanvas.addEventListener('touchend', handleTouch, { passive: false });
    
    console.log('Event listeners attached successfully');
    
    // Test de débogage AMÉLIORÉ : vérifier quel élément reçoit les clics
    document.addEventListener('mousedown', (e) => {
        if (!annotationCanvas) return;
        
        // Vérifier si le clic est sur un élément d'interface (à exclure de l'interception)
        const isUIElement = e.target.matches('input, button, select, textarea, .tool-btn, .color-btn, .stroke-width-container, .stroke-width-container *, .annotation-toolbar, .annotation-toolbar *');
        
        if (isUIElement) {
            console.log('🎛️ Click on UI element, allowing normal behavior:', e.target);
            return; // Laisser le comportement normal pour les éléments d'interface
        }
        
        const rect = annotationCanvas.getBoundingClientRect();
        const isOverCanvas = e.clientX >= rect.left && e.clientX <= rect.right && 
                           e.clientY >= rect.top && e.clientY <= rect.bottom;
        
        if (isOverCanvas) {
            console.log('🎯 CLICK ANALYSIS:');
            console.log('  📍 Mouse position:', e.clientX, e.clientY);
            console.log('  📦 Canvas bounds:', rect);
            console.log('  🎯 Target element:', e.target);
            console.log('  ❓ Is annotation canvas?', e.target === annotationCanvas);
            console.log('  🔍 Element at point:', document.elementFromPoint(e.clientX, e.clientY));
            console.log('  📊 Target classes:', e.target.className);
            console.log('  🏷️ Target ID:', e.target.id);
            console.log('  🌳 Target parent:', e.target.parentElement);
            
            // CSS debugging
            const targetStyle = window.getComputedStyle(e.target);
            console.log('  🎨 Target z-index:', targetStyle.zIndex);
            console.log('  👆 Target pointer-events:', targetStyle.pointerEvents);
            console.log('  📐 Target position:', targetStyle.position);
            
            const canvasStyle = window.getComputedStyle(annotationCanvas);
            console.log('  🎨 Canvas z-index:', canvasStyle.zIndex);
            console.log('  👆 Canvas pointer-events:', canvasStyle.pointerEvents);
            
            console.log('🎯 Click intercepted and will be redirected to canvas');
            
            // Si le clic n'est pas directement sur le canvas, forcer l'événement
            if (e.target !== annotationCanvas) {
                console.log('🔄 FORCING click to annotation canvas...');
                e.preventDefault();
                e.stopPropagation();
                
                const canvasEvent = new MouseEvent('mousedown', {
                    clientX: e.clientX,
                    clientY: e.clientY,
                    button: e.button,
                    buttons: e.buttons,
                    bubbles: true
                });
                annotationCanvas.dispatchEvent(canvasEvent);
            }
        }
    }, true); // Utiliser capture phase pour intercepter tôt
    
    // Démarrer le monitoring
    // Monitoring désactivé pour simplifier
    
    // Détecteurs de clics globaux supprimés pour simplifier
    
    // Événements des outils configurés maintenant dans le bon ordre après loadAnnotations()
}

// Fonctions de diagnostic supprimées pour simplifier le code

function setupToolEvents() {
    console.log('🔧 === CONFIGURATION DES ÉVÉNEMENTS D\'OUTILS ===');
    
    // Outils de dessin
    const toolButtons = document.querySelectorAll('[data-tool]');
    console.log('🔘 Boutons d\'outils trouvés:', toolButtons.length);
    
    toolButtons.forEach((btn, index) => {
        console.log(`  Bouton ${index}: ${btn.id || 'sans ID'} (data-tool: ${btn.dataset.tool})`);
        btn.addEventListener('click', () => {
            console.log('🖱️ Clic sur bouton outil:', btn.dataset.tool);
            setAnnotationTool(btn.dataset.tool);
        });
    });
    
    // Couleurs
    const colorButtons = document.querySelectorAll('.color-btn');
    console.log('🎨 Boutons de couleur trouvés:', colorButtons.length);
    
    colorButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            console.log('🖱️ Clic sur couleur:', btn.dataset.color);
            setAnnotationColor(btn.dataset.color);
        });
    });
    
    const colorPicker = document.getElementById('annotationColor');
    if (colorPicker) {
        console.log('🎨 Color picker trouvé et configuré');
        colorPicker.addEventListener('change', (e) => {
            console.log('🖱️ Changement color picker:', e.target.value);
            setAnnotationColor(e.target.value);
        });
    } else {
        console.warn('⚠️ Color picker non trouvé');
    }
    
    // Épaisseur
    const strokeWidthSlider = document.getElementById('strokeWidth');
    const strokeWidthValue = document.getElementById('strokeWidthValue');
    
    if (strokeWidthSlider) {
        console.log('📏 Stroke width slider found:', strokeWidthSlider);
        console.log('📏 Initial value:', strokeWidthSlider.value);
        console.log('📏 Min:', strokeWidthSlider.min, 'Max:', strokeWidthSlider.max);
        console.log('📏 Disabled:', strokeWidthSlider.disabled);
        
        strokeWidthSlider.addEventListener('input', (e) => {
            setStrokeWidth(e.target.value);
        });
        
        // Ajouter aussi l'événement 'change' pour les navigateurs qui ne supportent pas bien 'input'
        strokeWidthSlider.addEventListener('change', (e) => {
            setStrokeWidth(e.target.value);
        });
        
        // Test si le curseur est accessible
        strokeWidthSlider.addEventListener('mousedown', (e) => {
            console.log('🖱️ Mouse down on slider');
        });
        
        strokeWidthSlider.addEventListener('click', (e) => {
            console.log('🖱️ Click on slider at position:', e.offsetX);
        });
    } else {
        console.error('❌ Stroke width slider not found!');
    }
    
    // Actions
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);
}

// Changer d'outil d'annotation
function setAnnotationTool(tool) {
    // Synchroniser les deux variables pour éviter les incohérences
    currentAnnotationTool = tool;
    currentTool = tool;
    
    // Réinitialiser les variables de dessin lissé lors du changement d'outil
    resetSmoothDrawingVariables();
    
    console.log('🔧 Outil changé vers:', tool);
    
    // Mettre à jour l'interface
    document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const toolBtn = document.querySelector(`[data-tool="${tool}"]`);
    if (toolBtn) {
        toolBtn.classList.add('active');
    }
    
    // Changer le curseur sur tous les canvas d'annotation
    document.querySelectorAll('.annotation-canvas').forEach(canvas => {
        canvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
    });
    
    // Changer le curseur sur le canvas principal si disponible
    if (annotationCanvas) {
        annotationCanvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
    }
}

// Changer de couleur
function setAnnotationColor(color) {
    currentColor = color;
    currentAnnotationColor = color; // Synchroniser les deux variables
    
    console.log('🎨 Couleur changée vers:', color);
    
    // Mettre à jour l'interface
    document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const colorBtn = document.querySelector(`[data-color="${color}"]`);
    if (colorBtn) {
        colorBtn.classList.add('active');
    }
    
    // Mettre à jour l'input color picker
    const colorPicker = document.getElementById('annotationColor');
    if (colorPicker) {
        colorPicker.value = color;
    }
}

// Fonction pour mettre à jour la taille du trait
function setStrokeWidth(width) {
    currentStrokeWidth = parseInt(width);
    
    console.log('📏 Épaisseur changée vers:', currentStrokeWidth);
    
    // Mettre à jour l'affichage de la valeur
    const strokeWidthValue = document.getElementById('strokeWidthValue');
    if (strokeWidthValue) {
        strokeWidthValue.textContent = currentStrokeWidth;
    }
    
    // Mettre à jour le slider
    const strokeWidthSlider = document.getElementById('strokeWidth');
    if (strokeWidthSlider) {
        strokeWidthSlider.value = currentStrokeWidth;
    }
}

// Fonction de dessin simple - basée sur la logique de la gomme qui fonctionne
function startDrawing(e) {
    if (!annotationCtx || !annotationCanvas) {
        console.error('❌ Canvas ou contexte indisponible');
        return;
    }
    
    isDrawing = true;
    currentStroke = [];
    
    console.log('🎨 Début du dessin avec outil:', currentAnnotationTool);
    
    const coords = getCanvasCoordinates(e);
    coords.timestamp = Date.now(); // Ajouter timestamp pour calculer la vitesse
    currentStroke.push(coords);
    
    if (currentAnnotationTool === 'eraser') {
        eraseAt(coords.x, coords.y);
    } else {
        // Pour le stylo : commencer un nouveau path avec le nouveau système
        initializeSmoothDrawing(coords.x, coords.y);
    }
}

// Fonction de dessin simplifiée
function draw(e) {
    if (!isDrawing) return;
    
    const coords = getCanvasCoordinates(e);
    coords.timestamp = Date.now(); // Ajouter timestamp pour calculer la vitesse
    currentStroke.push(coords);
    
    if (currentAnnotationTool === 'eraser') {
        eraseAt(coords.x, coords.y);
    } else {
        // Pour le stylo : continuer le trait avec lissage
        continueSmoothDrawing(coords.x, coords.y);
    }
}

// Fonction d'arrêt simplifiée
function stopDrawing() {
    if (!isDrawing) return;
    
    console.log('🛑 Arrêt du dessin');
    isDrawing = false;
    
    // Finaliser le dessin lissé
    if (currentAnnotationTool !== 'eraser') {
        finalizeSmoothDrawing();
        // PAS de restore() pour éviter la perte de contexte
    }
    
    // Sauvegarder l'annotation si ce n'est pas la gomme
    if (currentStroke.length > 0 && currentAnnotationTool !== 'eraser') {
        const annotation = {
            type: currentAnnotationTool,
            color: currentColor,
            strokeWidth: currentStrokeWidth,
            points: [...currentStroke],
            page: currentPageNum,
            scale: currentScale,
            timestamp: Date.now()
        };
        
        annotations.push(annotation);
        undoHistory.push(annotations.length - 1);
        console.log('💾 Annotation sauvegardée avec', currentStroke.length, 'points');
    }
    
    currentStroke = [];
    // Réinitialiser les variables de dessin pour le prochain trait
    resetSmoothDrawingVariables();
}

// Fonction de dessin simple - inspirée d'eraseAt qui fonctionne bien
// === SYSTÈME DE DESSIN LISSÉ (STYLE PROCREATE) ===

// Variables pour le dessin lissé style Procreate
let lastPoint = null;
let lastVelocity = 0;
let strokePressure = 1.0;
let smoothDrawingInitialized = false;
let currentPath = null; // Stocke le path en cours
let drawingPoints = []; // Buffer des points pour le lissage
let isRealTimeSmoothing = true;

// Fonction pour réinitialiser les variables de dessin lissé
function resetSmoothDrawingVariables() {
    lastPoint = null;
    lastVelocity = 0;
    strokePressure = 1.0;
    smoothDrawingInitialized = false;
    currentPath = null;
    drawingPoints = [];
    console.log('🔄 Variables de dessin lissé réinitialisées');
}

// Initialiser le dessin lissé style Procreate
function initializeSmoothDrawing(x, y) {
    // Réinitialiser les variables si c'est un nouveau trait
    if (!smoothDrawingInitialized) {
        resetSmoothDrawingVariables();
    }
    
    // Configurer le style pour ce trait - SANS save() pour éviter les problèmes de contexte
    if (currentAnnotationTool === 'pen') {
        annotationCtx.globalCompositeOperation = 'source-over';
        annotationCtx.strokeStyle = currentColor;
        annotationCtx.lineCap = 'round';
        annotationCtx.lineJoin = 'round';
        annotationCtx.globalAlpha = 1.0;
    } else if (currentAnnotationTool === 'highlighter') {
        annotationCtx.globalCompositeOperation = 'multiply';
        annotationCtx.strokeStyle = currentColor;
        annotationCtx.lineCap = 'round';
        annotationCtx.lineJoin = 'round';
        annotationCtx.globalAlpha = 0.3;
    }
    
    // Calculer la largeur initiale
    const initialWidth = calculateStrokeWidth(0);
    annotationCtx.lineWidth = initialWidth;
    
    // Initialiser les variables de lissage
    lastPoint = { x: x, y: y, timestamp: Date.now() };
    lastVelocity = 0;
    strokePressure = 1.0;
    smoothDrawingInitialized = true;
    
    // Initialiser le buffer de points pour le lissage
    drawingPoints = [{ x, y, timestamp: Date.now() }];
    
    // Commencer un nouveau path continu
    annotationCtx.beginPath();
    annotationCtx.moveTo(x, y);
    
    console.log('🎨 Dessin lissé Procreate initialisé à', {x, y});
}

// Continuer le dessin lissé en temps réel (style Procreate)
function continueSmoothDrawing(x, y) {
    if (!lastPoint || !smoothDrawingInitialized) {
        console.warn('⚠️ continueSmoothDrawing appelé sans initialisation');
        return;
    }
    
    // Vérifier que le contexte est encore valide
    if (!annotationCtx) {
        console.error('❌ Context d\'annotation perdu - réinitialisation nécessaire');
        resetSmoothDrawingVariables();
        return;
    }
    
    const currentTime = Date.now();
    
    // Ajouter le nouveau point au buffer
    drawingPoints.push({ x, y, timestamp: currentTime });
    
    // Garder seulement les 4 derniers points pour le lissage
    if (drawingPoints.length > 4) {
        drawingPoints.shift();
    }
    
    // Dessiner en temps réel seulement s'il y a assez de points
    if (drawingPoints.length >= 2) {
        drawSmoothSegment();
    }
    
    // Mettre à jour le dernier point
    lastPoint = { x: x, y: y, timestamp: currentTime };
}

// Dessiner un segment lissé en temps réel
function drawSmoothSegment() {
    if (drawingPoints.length < 2) return;
    
    const len = drawingPoints.length;
    const currentPoint = drawingPoints[len - 1];
    const previousPoint = drawingPoints[len - 2];
    
    // Calculer la vitesse
    const distance = Math.sqrt(
        Math.pow(currentPoint.x - previousPoint.x, 2) + 
        Math.pow(currentPoint.y - previousPoint.y, 2)
    );
    const timeDelta = currentPoint.timestamp - previousPoint.timestamp;
    const velocity = timeDelta > 0 ? distance / Math.max(timeDelta, 1) : 0;
    
    // Lisser la vitesse
    const smoothedVelocity = lastVelocity * 0.6 + velocity * 0.4;
    lastVelocity = smoothedVelocity;
    
    // Calculer la largeur du trait
    const strokeWidth = calculateStrokeWidth(smoothedVelocity);
    annotationCtx.lineWidth = strokeWidth;
    
    // Dessiner selon le nombre de points disponibles
    if (len >= 3) {
        // Utiliser une courbe de Bézier pour un lissage optimal
        const p0 = drawingPoints[len - 3];
        const p1 = drawingPoints[len - 2];
        const p2 = drawingPoints[len - 1];
        
        // Calculer les points de contrôle pour une courbe lisse
        const cp1x = p1.x + (p2.x - p0.x) * 0.2;
        const cp1y = p1.y + (p2.y - p0.y) * 0.2;
        
        // Dessiner la courbe de Bézier quadratique
        annotationCtx.quadraticCurveTo(cp1x, cp1y, p2.x, p2.y);
    } else {
        // Pour les deux premiers points, dessiner une ligne simple
        annotationCtx.lineTo(currentPoint.x, currentPoint.y);
    }
    
    // Appliquer le stroke en temps réel pour voir le trait se former
    annotationCtx.stroke();
    
    // Continuer le path sans le fermer
    annotationCtx.beginPath();
    annotationCtx.moveTo(currentPoint.x, currentPoint.y);
}

// Calculer la largeur du trait basée sur la vitesse (simulation de pression)
function calculateStrokeWidth(velocity) {
    const baseWidth = currentStrokeWidth * (currentScale || 1);
    const multiplier = currentAnnotationTool === 'highlighter' ? 3 : 1;
    
    // Plus la vitesse est élevée, plus le trait est fin (comme avec un vrai stylo)
    // Normaliser la vitesse (valeurs typiques entre 0 et 20 pixels/ms)
    const normalizedVelocity = Math.min(velocity / 5, 1);
    
    // Calculer la variation de largeur (20% de variation max)
    const minWidth = baseWidth * 0.8;
    const maxWidth = baseWidth * 1.2;
    
    // Vitesse faible = trait plus épais, vitesse élevée = trait plus fin
    const dynamicWidth = maxWidth - (normalizedVelocity * (maxWidth - minWidth));
    
    return dynamicWidth * multiplier;
}

// Finaliser le dessin lissé
function finalizeSmoothDrawing() {
    if (drawingPoints.length > 0) {
        // Terminer le path avec une largeur stable
        const finalWidth = calculateStrokeWidth(0);
        annotationCtx.lineWidth = finalWidth;
        
        // Dessiner les derniers segments s'il y en a
        if (drawingPoints.length >= 2) {
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            annotationCtx.lineTo(lastPoint.x, lastPoint.y);
            annotationCtx.stroke();
        }
    }
    
    console.log('🏁 Finalisation du dessin lissé Procreate avec', drawingPoints.length, 'points');
    // Réinitialiser les variables SANS restore() pour éviter les problèmes
    resetSmoothDrawingVariables();
}

// === FIN DU SYSTÈME DE DESSIN LISSÉ ===

function drawAt(x, y, isStart) {
    if (isStart) {
        // Configurer le style pour ce trait
        annotationCtx.save();
        
        if (currentAnnotationTool === 'pen') {
            annotationCtx.globalCompositeOperation = 'source-over';
            annotationCtx.strokeStyle = currentColor;
            annotationCtx.lineWidth = currentStrokeWidth * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 1.0;
        } else if (currentAnnotationTool === 'highlighter') {
            annotationCtx.globalCompositeOperation = 'multiply';
            annotationCtx.strokeStyle = currentColor;
            annotationCtx.lineWidth = currentStrokeWidth * 3 * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 0.3;
        }
        
        // Commencer un nouveau path
        annotationCtx.beginPath();
        annotationCtx.moveTo(x, y);
    } else {
        // Continuer le trait
        annotationCtx.lineTo(x, y);
        annotationCtx.stroke();
    }
}

// Fonction d'effacement améliorée
function eraseAt(x, y) {
    const eraseRadius = currentStrokeWidth * 3 * (currentScale || 1);
    
    // Effacer dans un rayon autour du point
    annotationCtx.save();
    annotationCtx.globalCompositeOperation = 'destination-out';
    annotationCtx.beginPath();
    annotationCtx.arc(x, y, eraseRadius, 0, 2 * Math.PI);
    annotationCtx.fill();
    annotationCtx.restore();
    
    // Marquer les annotations comme effacées dans cette zone
    annotations.forEach(annotation => {
        if (annotation.page && annotation.page !== currentPageNum) return;
        
        annotation.points = annotation.points.filter(point => {
            const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
            return distance > eraseRadius;
        });
    });
    
    // Supprimer les annotations vides
    annotations = annotations.filter(annotation => annotation.points.length > 0);
    
    // Sauvegarde désactivée pendant le dessin pour éviter les blocages
    // scheduleAutoSave();
}

// Fonction stopDrawing supprimée - doublon

// Gestion tactile améliorée
function handleTouch(e) {
    e.preventDefault();
    
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(
            e.type === 'touchstart' ? 'mousedown' : 
            e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
            {
                clientX: touch.clientX,
                clientY: touch.clientY
            }
        );
        
        annotationCanvas.dispatchEvent(mouseEvent);
    }
}

// Redessiner les annotations
function redrawAnnotations() {
    // Ne pas redessiner si on est en train de dessiner pour éviter d'effacer le trait en cours
    // SAUF si c'est pour charger les annotations initiales (forceRedraw = true)
    const forceRedraw = arguments[0] === true;
    if (isDrawing && !forceRedraw) {
        console.log('redrawAnnotations skipped - currently drawing (use redrawAnnotations(true) to force)');
        return;
    }
    
    if (forceRedraw) {
        console.log('🔄 FORCE REDRAW - redessinage forcé même pendant le dessin');
    }
    
    console.log(`🎨 === REDRAW ANNOTATIONS DEBUG ===`);
    console.log(`📄 Page actuelle: ${currentPageNum}`);
    console.log(`📊 Variable annotations.length: ${annotations.length}`);
    console.log(`📊 annotationsByPage[${currentPageNum}]?.length: ${annotationsByPage[currentPageNum]?.length || 0}`);
    console.log(`📊 Contenu annotations:`, annotations);
    console.log(`📊 Contenu annotationsByPage[${currentPageNum}]:`, annotationsByPage[currentPageNum]);
    
    // CORRECTION CRITIQUE: Toujours utiliser le canvas de la page actuelle
    const currentAnnotationCanvas = document.getElementById(`annotation-canvas-${currentPageNum}`);
    if (!currentAnnotationCanvas) {
        console.error(`❌ redrawAnnotations: Canvas annotation-canvas-${currentPageNum} non trouvé!`);
        return;
    }
    
    const currentAnnotationCtx = currentAnnotationCanvas.getContext('2d');
    if (!currentAnnotationCtx) {
        console.error(`❌ redrawAnnotations: Impossible d'obtenir le contexte du canvas annotation-canvas-${currentPageNum}`);
        return;
    }
    
    console.log(`🎯 Utilisation du canvas correct: annotation-canvas-${currentPageNum}`);
    console.log(`📏 Dimensions canvas: ${currentAnnotationCanvas.width}x${currentAnnotationCanvas.height}`);
    
    // Effacer le canvas CORRECT
    console.log('🧹 Effacement du canvas...');
    currentAnnotationCtx.clearRect(0, 0, currentAnnotationCanvas.width, currentAnnotationCanvas.height);
    
    // Compter les annotations qui seront dessinées
    let drawnCount = 0;
    
    annotations.forEach((annotation, index) => {
        if (!annotation || !annotation.points || annotation.points.length === 0) {
            console.log(`❌ Annotation ${index} skipped - no points:`, annotation);
            return;
        }
        
        // Double vérification pour détecter d'éventuels problèmes de filtrage
        if (annotation.page && annotation.page !== currentPageNum) {
            console.error(`🚨 BUG DÉTECTÉ: Annotation ${index} de la page ${annotation.page} trouvée dans le tableau de la page ${currentPageNum}!`, annotation);
            return;
        }
        
        console.log(`✏️ Drawing annotation ${index}:`, {
            type: annotation.type,
            color: annotation.color,
            strokeWidth: annotation.strokeWidth,
            pointsCount: annotation.points.length,
            page: annotation.page
        });
        
        currentAnnotationCtx.beginPath();
        currentAnnotationCtx.moveTo(annotation.points[0].x, annotation.points[0].y);
        
        // Configurer le style
        if (annotation.type === 'pen') {
            currentAnnotationCtx.globalCompositeOperation = 'source-over';
            currentAnnotationCtx.strokeStyle = annotation.color;
            currentAnnotationCtx.lineWidth = annotation.strokeWidth * (currentScale || 1);
            currentAnnotationCtx.lineCap = 'round';
            currentAnnotationCtx.lineJoin = 'round';
            currentAnnotationCtx.globalAlpha = 1.0;
        } else if (annotation.type === 'highlighter') {
            currentAnnotationCtx.globalCompositeOperation = 'multiply';
            currentAnnotationCtx.strokeStyle = annotation.color;
            currentAnnotationCtx.lineWidth = annotation.strokeWidth * 3 * (currentScale || 1);
            currentAnnotationCtx.lineCap = 'round';
            currentAnnotationCtx.lineJoin = 'round';
            currentAnnotationCtx.globalAlpha = 0.3;
        }
        
        // Dessiner le trait avec lissage quadratique pour un meilleur rendu
        if (annotation.points.length === 1) {
            // Point unique - dessiner un petit cercle
            currentAnnotationCtx.arc(annotation.points[0].x, annotation.points[0].y, currentAnnotationCtx.lineWidth / 2, 0, 2 * Math.PI);
            currentAnnotationCtx.fill();
        } else if (annotation.points.length === 2) {
            // Trait simple entre deux points
            currentAnnotationCtx.lineTo(annotation.points[1].x, annotation.points[1].y);
            currentAnnotationCtx.stroke();
        } else {
            // Trait complexe - utiliser des courbes quadratiques pour un rendu plus lisse
            for (let i = 1; i < annotation.points.length - 1; i++) {
                const currentPoint = annotation.points[i];
                const nextPoint = annotation.points[i + 1];
                
                // Point de contrôle au milieu pour la courbe quadratique
                const controlX = (currentPoint.x + nextPoint.x) / 2;
                const controlY = (currentPoint.y + nextPoint.y) / 2;
                
                currentAnnotationCtx.quadraticCurveTo(currentPoint.x, currentPoint.y, controlX, controlY);
            }
            
            // Finir jusqu'au dernier point
            const lastPoint = annotation.points[annotation.points.length - 1];
            currentAnnotationCtx.lineTo(lastPoint.x, lastPoint.y);
            currentAnnotationCtx.stroke();
        }
        
        if (annotation.type === 'highlighter') {
            currentAnnotationCtx.globalAlpha = 1.0;
        }
        
        drawnCount++;
    });
    
    console.log(`✅ redrawAnnotations completed: ${drawnCount}/${annotations.length} annotations drawn on canvas annotation-canvas-${currentPageNum}`);
}

// Charger les annotations
async function loadAnnotations(fileId) {
    try {
        isLoadingInitialAnnotations = true;
        console.log('📄 Chargement des annotations depuis le serveur...');
        const response = await fetch(`/planning/get_file_annotations/${fileId}`);
        const result = await response.json();
        
        if (result.success) {
            // Utiliser le nouveau système pour charger toutes les annotations
            loadAllAnnotations(result.annotations);
            console.log('📄 Annotations chargées avec succès depuis le serveur');
        } else {
            console.log('📄 Aucune annotation trouvée sur le serveur - démarrage avec document vierge');
            loadAllAnnotations({});
        }
    } catch (error) {
        console.error('Erreur lors du chargement des annotations:', error);
        loadAllAnnotations({});
    } finally {
        // Délai de sécurité pour laisser le temps aux annotations de s'afficher
        setTimeout(() => {
            isLoadingInitialAnnotations = false;
            console.log('🔓 Observer réactivé - chargement initial terminé');
        }, 500);
    }
}

// Annuler la dernière action
function undo() {
    if (annotations.length > 0) {
        // Annuler uniquement sur la page actuelle
        annotations.pop(); // Supprimer la dernière annotation
        redrawAnnotations();
        console.log(`↩️ Annulation effectuée sur la page ${currentPageNum}, ${annotations.length} annotations restantes`);
        // Les annotations seront sauvegardées automatiquement lors du changement de page
    }
}

// Tout effacer
function clearAll() {
    if (confirm('Êtes-vous sûr de vouloir effacer toutes les annotations de cette page ?')) {
        const removedCount = annotations.length;
        annotations = []; // Vider toutes les annotations de la page actuelle
        undoHistory = []; // Vider l'historique aussi
        redrawAnnotations();
        console.log(`🗑️ ${removedCount} annotations supprimées de la page ${currentPageNum}`);
        // Les changements seront sauvegardés automatiquement lors du changement de page
    }
}

// === GESTION DES ANNOTATIONS PAR PAGE ===

// Sauvegarder les annotations de la page actuelle dans la structure par page
function saveCurrentPageAnnotations() {
    if (!currentPageNum) return;
    
    // FILTRER les annotations pour ne sauvegarder que celles de la page actuelle
    const pageAnnotations = annotations.filter(annotation => {
        // Inclure les annotations sans page définie (legacy) ou celles de la page actuelle
        return !annotation.page || annotation.page === currentPageNum;
    });
    
    if (pageAnnotations.length > 0) {
        annotationsByPage[currentPageNum] = [...pageAnnotations]; // Copie du tableau FILTRÉ
        console.log(`📄 ${pageAnnotations.length} annotations sauvegardées pour la page ${currentPageNum}:`, pageAnnotations);
    } else {
        // Si aucune annotation, supprimer la page de la structure (économise l'espace)
        if (annotationsByPage[currentPageNum]) {
            delete annotationsByPage[currentPageNum];
            console.log(`📄 Page ${currentPageNum} supprimée (aucune annotation)`);
        }
    }
    
    // Sauvegarder aussi l'historique d'annulation
    if (undoHistory.length > 0) {
        undoHistoryByPage[currentPageNum] = [...undoHistory];
    } else {
        // Nettoyer l'historique vide
        if (undoHistoryByPage[currentPageNum]) {
            delete undoHistoryByPage[currentPageNum];
        }
    }
}

// Charger les annotations d'une page spécifique
function loadPageAnnotations(pageNum) {
    console.log(`🔄 === LOAD PAGE ANNOTATIONS APPELÉE ===`);
    console.log(`📄 Chargement des annotations pour la page ${pageNum}`);
    console.log(`📄 Annotations disponibles par page:`, Object.keys(annotationsByPage));
    console.log(`📄 Variable annotations avant chargement:`, annotations.length, 'éléments');
    
    // Tracer qui appelle cette fonction
    console.trace('📍 Trace de l\'appel loadPageAnnotations:');
    
    // IMPORTANT: Réinitialiser les variables de dessin lissé lors du chargement d'une nouvelle page
    resetSmoothDrawingVariables();
    
    // CORRECTION CRITIQUE: Mettre à jour les variables globales pour pointer vers la bonne page
    annotationCanvas = document.getElementById(`annotation-canvas-${pageNum}`);
    if (annotationCanvas) {
        annotationCtx = annotationCanvas.getContext('2d');
        canvas = annotationCanvas; // Variable de compatibilité
        ctx = annotationCtx; // Variable de compatibilité
        console.log(`🎯 Variables globales mises à jour pour la page ${pageNum}`);
    } else {
        console.error(`❌ Canvas annotation-canvas-${pageNum} introuvable!`);
    }
    
    // Charger les annotations de cette page
    if (annotationsByPage[pageNum]) {
        const rawAnnotations = [...annotationsByPage[pageNum]]; // Copie du tableau
        
        // DOUBLE FILTRAGE pour s'assurer qu'on n'a que les annotations de cette page
        annotations = rawAnnotations.filter(annotation => {
            // Inclure les annotations sans page définie (legacy) ou celles de cette page
            return !annotation.page || annotation.page === pageNum;
        });
        
        if (rawAnnotations.length !== annotations.length) {
            console.warn(`⚠️ NETTOYAGE: ${rawAnnotations.length - annotations.length} annotations d'autres pages supprimées`);
        }
        
        console.log(`✅ ${annotations.length} annotations chargées pour la page ${pageNum}:`, annotations);
    } else {
        annotations = [];
        console.log(`📄 Aucune annotation trouvée pour la page ${pageNum} - page vierge`);
    }
    
    // Charger l'historique d'annulation
    if (undoHistoryByPage[pageNum]) {
        undoHistory = [...undoHistoryByPage[pageNum]];
    } else {
        undoHistory = [];
    }
    
    // Redessiner les annotations sur le canvas (forcé)
    console.log(`🎨 === REDESSINAGE FORCÉ ===`);
    console.log(`📄 Page: ${pageNum}, annotations à dessiner: ${annotations.length}`);
    console.log(`🖼️ Canvas ready: ${!!annotationCtx}`);
    
    if (annotationCtx) {
        console.log('🔄 Appel de redrawAnnotations() depuis loadPageAnnotations...');
        redrawAnnotations();
        console.log('✅ redrawAnnotations() terminé');
    } else {
        console.warn('⚠️ annotationCtx non disponible pour redessiner - report en attente du canvas');
        
        // Reporter le redessinage quand le canvas sera prêt
        const waitForCanvas = () => {
            if (annotationCtx) {
                console.log('🎨 Canvas maintenant disponible - redessinage forcé des annotations chargées');
                redrawAnnotations(true); // Force le redessinage même si isDrawing = true
            } else {
                setTimeout(waitForCanvas, 100);
            }
        };
        waitForCanvas();
    }
    
    console.log(`🏁 === FIN LOAD PAGE ANNOTATIONS ===`);
}

// Obtenir toutes les annotations de toutes les pages pour la sauvegarde
function getAllAnnotations() {
    // D'abord sauvegarder la page actuelle
    saveCurrentPageAnnotations();
    
    // Retourner toutes les annotations organisées par page
    return annotationsByPage;
}

// Charger toutes les annotations depuis les données sauvegardées
function loadAllAnnotations(savedAnnotations) {
    console.log('📄 Chargement de toutes les annotations:', savedAnnotations);
    
    if (savedAnnotations && typeof savedAnnotations === 'object' && !Array.isArray(savedAnnotations)) {
        // Nouveau format par page
        annotationsByPage = savedAnnotations;
        console.log(`📄 ${Object.keys(annotationsByPage).length} pages avec annotations trouvées`);
        
        // Charger les annotations de la page actuelle
        loadPageAnnotations(currentPageNum);
        
        // Forcer un redessinage immédiat des annotations sur la page courante
        setTimeout(() => {
            if (annotations.length > 0) {
                console.log(`🎨 REDRAW INITIAL - Redessinage des annotations chargées (${annotations.length}) sur page ${currentPageNum}`);
                redrawAnnotations(true);
            }
        }, 100);
    } else if (Array.isArray(savedAnnotations)) {
        // Ancien format (compatibility) - toutes les annotations sur la page 1
        console.log('📄 Format legacy détecté - migration vers format par page');
        annotationsByPage = {};
        if (savedAnnotations.length > 0) {
            annotationsByPage[1] = savedAnnotations;
        }
        loadPageAnnotations(currentPageNum);
        
        // Forcer un redessinage immédiat des annotations sur la page courante
        setTimeout(() => {
            if (annotations.length > 0) {
                console.log(`🎨 REDRAW INITIAL (legacy) - Redessinage des annotations chargées (${annotations.length}) sur page ${currentPageNum}`);
                redrawAnnotations(true);
            }
        }, 100);
    } else {
        // Aucune annotation ou format non reconnu
        console.log('📄 Aucune annotation ou format non reconnu - démarrage vierge');
        annotationsByPage = {};
        annotations = [];
        undoHistory = [];
        // S'assurer que le canvas est nettoyé
        if (annotationCtx) {
            redrawAnnotations();
        }
    }
    
    console.log(`📄 Fin du chargement - page actuelle ${currentPageNum} avec ${annotations.length} annotations`);
}

// Fonction scheduleAutoSave supprimée - sauvegarde uniquement à la fermeture

// Sauvegarder les annotations (appelé uniquement à la fermeture)
async function saveAnnotations() {
    if (!currentFileId) return;
    
    // Indicateur visuel
    const saveStatus = document.getElementById('saveStatus');
    if (saveStatus) {
        saveStatus.className = 'save-status saving';
        saveStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...';
    }
    
    try {
        // Utiliser le nouveau système : obtenir toutes les annotations de toutes les pages
        const allAnnotations = getAllAnnotations();
        
        console.log('💾 Sauvegarde de toutes les annotations:', allAnnotations);
        
        const response = await fetch('/planning/save_file_annotations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                file_id: currentFileId,
                annotations: allAnnotations // Maintenant c'est un objet avec les pages
            })
        });
        
        const result = await response.json();
        const saveStatus = document.getElementById('saveStatus');
        
        if (result.success) {
            if (saveStatus) {
                saveStatus.className = 'save-status';
                saveStatus.innerHTML = '<i class="fas fa-check"></i> Annotations sauvegardées';
            }
            console.log('💾 Annotations sauvegardées avec succès pour toutes les pages');
        } else {
            if (saveStatus) {
                saveStatus.className = 'save-status error';
                saveStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Erreur de sauvegarde';
            }
            console.error('Erreur de sauvegarde:', result.message);
        }
    } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        if (saveStatus) {
            saveStatus.className = 'save-status error';
            saveStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Erreur de connexion';
        }
    }
}

// Afficher une erreur
function showError(message) {
    const container = document.getElementById('viewerContainer');
    container.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: #FC8181;">
            <i class="fas fa-exclamation-triangle fa-2x"></i>
            <p>${message}</p>
            <button onclick="closeFileViewer()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #4F46E5; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">
                Fermer
            </button>
        </div>
    `;
}

// Charger le contenu du fichier
async function loadFileContent(fileId, fileType, container) {
    container.innerHTML = '<div style="text-align: center; padding: 2rem;"><i class="fas fa-spinner fa-spin fa-2x"></i><p>Chargement...</p></div>';
    
    console.log('Chargement du fichier:', {fileId, fileType});
    
    try {
        if (fileType.toLowerCase() === 'pdf') {
            await loadPDF(fileId, container);
        } else if (['png', 'jpg', 'jpeg'].includes(fileType.toLowerCase())) {
            await loadImage(fileId, container);
        }
        console.log('Fichier chargé avec succès');
    } catch (error) {
        console.error('Erreur détaillée lors du chargement:', error);
        container.innerHTML = `
            <div style="color: #FC8181; text-align: center; padding: 2rem;">
                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                <h3>Erreur lors du chargement du fichier</h3>
                <p style="margin-top: 1rem; font-size: 0.9rem;">${error.message}</p>
                <button onclick="closeFileViewer()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #4F46E5; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">
                    Fermer
                </button>
            </div>
        `;
    }
}


// Charger une image
async function loadImage(fileId, container) {
    try {
        const img = document.createElement('img');
        img.src = `/file_manager/serve_file/${fileId}`;
        
        // Ajouter un timeout pour éviter l'attente infinie
        const loadTimeout = setTimeout(() => {
            throw new Error('Timeout: L\'image prend trop de temps à charger');
        }, 10000);
        
        img.onload = () => {
            clearTimeout(loadTimeout);
            
            // Créer le conteneur
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            
            // Ajuster la taille de l'image pour qu'elle s'adapte à l'écran
            const maxWidth = window.innerWidth * 0.8;
            const maxHeight = window.innerHeight * 0.6;
            
            let { width, height } = img;
            
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }
            
            img.style.width = width + 'px';
            img.style.height = height + 'px';
            
            imageContainer.appendChild(img);
            
            // Créer le canvas d'annotation
            canvas = document.createElement('canvas');
            canvas.className = 'annotation-canvas';
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx = canvas.getContext('2d');
            
            imageContainer.appendChild(canvas);
            container.innerHTML = '';
            container.appendChild(imageContainer);
        };
        
        img.onerror = () => {
            clearTimeout(loadTimeout);
            throw new Error('Impossible de charger l\'image');
        };
        
    } catch (error) {
        console.error('Erreur lors du chargement de l\'image:', error);
        throw error;
    }
}

// Fonction loadAnnotations dupliquée supprimée - utiliser celle définie plus haut avec le système par page

// Code orphelin supprimé - déjà géré dans setupToolEvents()

// Fonctions de dessin supprimées - dupliquées avec celles qui utilisent annotationCanvas

// Fonctions dupliquées supprimées - déjà définies plus haut dans le fichier

// Fonction saveAnnotations dupliquée supprimée - déjà définie plus haut

// Fermer le viewer amélioré
function closeFileViewer() {
    try {
        // Si on est en vue split, fermer toute la vue split
        if (isSplitViewActive) {
            closeSplitView();
            return;
        }
        
        // Sauvegarder les annotations de la page actuelle avant de fermer
        console.log('📄 Fermeture du viewer - sauvegarde des annotations de la page actuelle...');
        saveCurrentPageAnnotations();
        
        // Sauvegarder toutes les annotations
        if (Object.keys(annotationsByPage).length > 0 || annotations.length > 0) {
            saveAnnotations();
        }
        
        const modal = document.getElementById('fileViewerModal');
        if (modal) {
            modal.classList.remove('show');
        }
        
        // Nettoyer les variables
        currentFileId = null;
        annotations = [];
        annotationsByPage = {}; // Nettoyer les annotations par page
        undoHistoryByPage = {}; // Nettoyer l'historique par page
        pdfDoc = null;
        currentPageNum = 1;
        currentScale = 1.0;
        pdfCanvas = null;
        pdfCtx = null;
        annotationCanvas = null;
        annotationCtx = null;
        
        if (saveTimeout) {
            clearTimeout(saveTimeout);
            saveTimeout = null;
        }
        
        // Masquer la barre latérale
        document.getElementById('pageSidebar').classList.remove('show');
        
    } catch (error) {
        console.error('Erreur lors de la fermeture:', error);
        const modal = document.getElementById('fileViewerModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }
}

// Fonctions pour la vue côte-à-côte (split view)
async function openSplitView(fileId, filename, fileType) {
    isSplitViewActive = true;
    
    // Copier le formulaire de planification dans la vue split
    const planningEdit = document.getElementById('planningEdit');
    const splitViewPlanningEdit = document.getElementById('splitViewPlanningEdit');
    splitViewPlanningEdit.innerHTML = planningEdit.innerHTML;
    
    // Copier les valeurs actuelles
    const originalTitle = document.getElementById('planningTitle').value;
    const originalDescription = document.getElementById('planningDescription').value;
    
    setTimeout(() => {
        const splitTitle = splitViewPlanningEdit.querySelector('#planningTitle');
        const splitDescription = splitViewPlanningEdit.querySelector('#planningDescription');
        if (splitTitle) splitTitle.value = originalTitle;
        if (splitDescription) splitDescription.value = originalDescription;
        
        // Attacher les événements au nouveau formulaire
        const splitForm = splitViewPlanningEdit.querySelector('#planningForm');
        if (splitForm) {
            splitForm.onsubmit = function(e) {
                e.preventDefault();
                savePlanningFromSplitView();
            };
        }
    }, 100);
    
    // Afficher la vue split
    const splitContainer = document.getElementById('splitViewContainer');
    splitContainer.classList.add('active');
    
    // Masquer le contenu normal
    document.querySelector('.lesson-container').style.display = 'none';
    
    // Intégrer le viewer PDF dans la partie droite
    const modal = document.getElementById('fileViewerModal');
    const splitViewRight = document.getElementById('splitViewRight');
    
    modal.classList.add('embedded');
    splitViewRight.appendChild(modal);
    modal.classList.add('show');
    
    // Initialiser les canvas
    initializeCanvases();
    
    // Charger le fichier
    try {
        if (fileType.toLowerCase() === 'pdf') {
            await loadPDF(fileId);
            await loadAnnotations(fileId);
        } else if (['png', 'jpg', 'jpeg'].includes(fileType.toLowerCase())) {
            await loadImage(fileId);
            await loadAnnotations(fileId);
        }
        
        setupAnnotationTools();
        
    } catch (error) {
        console.error('Erreur lors du chargement du fichier:', error);
        showError('Erreur lors du chargement du fichier');
    }
}

function closeSplitView() {
    // Synchroniser les valeurs de retour
    const splitTitle = document.querySelector('#splitViewPlanningEdit #planningTitle');
    const splitDescription = document.querySelector('#splitViewPlanningEdit #planningDescription');
    const originalTitle = document.getElementById('planningTitle');
    const originalDescription = document.getElementById('planningDescription');
    
    if (splitTitle && originalTitle) {
        originalTitle.value = splitTitle.value;
    }
    if (splitDescription && originalDescription) {
        originalDescription.value = splitDescription.value;
    }
    
    // Sauvegarder les annotations avant de fermer
    if (currentFileId && (Object.keys(annotationsByPage).length > 0 || annotations.length > 0)) {
        saveCurrentPageAnnotations();
        saveAnnotations();
    }
    
    // Fermer le viewer PDF sans rappeler closeSplitView
    const modal = document.getElementById('fileViewerModal');
    if (modal) {
        modal.classList.remove('show');
        modal.classList.remove('embedded');
        document.body.appendChild(modal);
    }
    
    // Nettoyer les variables du viewer
    currentFileId = null;
    annotations = [];
    annotationsByPage = {};
    undoHistoryByPage = {};
    pdfDoc = null;
    currentPageNum = 1;
    currentScale = 1.0;
    
    // Masquer la vue split
    const splitContainer = document.getElementById('splitViewContainer');
    splitContainer.classList.remove('active');
    
    // Réafficher le contenu normal
    document.querySelector('.lesson-container').style.display = '';
    
    // Réinitialiser le flag
    isSplitViewActive = false;
}

async function savePlanningFromSplitView() {
    const splitTitle = document.querySelector('#splitViewPlanningEdit #planningTitle');
    const splitDescription = document.querySelector('#splitViewPlanningEdit #planningDescription');
    
    if (!splitTitle || !splitDescription) return;
    
    showSavingIndicator(true);
    
    try {
        const response = await fetch('/planning/save-lesson-planning', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                date: lessonDate,
                period_number: periodNumber,
                classroom_id: classroomId,
                title: splitTitle.value,
                description: splitDescription.value,
                checklist_states: checklistStates
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            showSuccess('Planification enregistrée');
            
            // Synchroniser avec le formulaire original
            const originalTitle = document.getElementById('planningTitle');
            const originalDescription = document.getElementById('planningDescription');
            if (originalTitle) originalTitle.value = splitTitle.value;
            if (originalDescription) originalDescription.value = splitDescription.value;
            
            // Mettre à jour l'affichage si nécessaire
            updatePlanningDisplay();
        } else {
            showError(data.message || 'Erreur lors de la sauvegarde');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showError('Erreur lors de la sauvegarde');
    } finally {
        showSavingIndicator(false);
    }
}

// Événements globaux améliorés
document.addEventListener('keydown', (e) => {
    const modal = document.getElementById('fileViewerModal');
    if (!modal.classList.contains('show')) return;
    
    if (e.key === 'Escape') {
        closeFileViewer();
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        previousPage();
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        nextPage();
    // Raccourcis zoom supprimés
    }
});

document.addEventListener('click', (e) => {
    const modal = document.getElementById('fileViewerModal');
    if (e.target === modal && modal.classList.contains('show')) {
        closeFileViewer();
    }
});

// Fonctions pour la gestion des onglets de suivi
function showTrackingTab(tabName) {
    // Désactiver tous les onglets
    document.querySelectorAll('.tracking-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Masquer tous les contenus
    document.querySelectorAll('.tracking-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Activer l'onglet cliqué
    event.target.closest('.tracking-tab').classList.add('active');
    
    // Afficher le contenu correspondant
    document.getElementById(tabName + '-content').classList.add('active');
    
    // Si c'est l'onglet plan de classe, charger le plan et ajuster l'échelle
    if (tabName === 'seating-plan') {
        setTimeout(() => {
            loadSeatingPlan();
            // Ajustement supplémentaire pour s'assurer que l'échelle est correcte
            setTimeout(() => {
                adjustSeatingScale();
            }, 150);
        }, 100);
    }
}

// Fonctions pour l'initialisation du système de sanctions
function initializeSanctionSystem() {
    // Stocker les compteurs initiaux au début de la période
    document.querySelectorAll('.count-display').forEach(element => {
        const studentId = element.getAttribute('data-student');
        const sanctionId = element.getAttribute('data-sanction');
        const count = parseInt(element.textContent) || 0;
        initialSanctionCounts[`${studentId}_${sanctionId}`] = count;
    });
    
    // Démarrer la surveillance uniquement si on est en cours actuel
    {% if is_current and remaining_seconds > 0 %}
    startSanctionMonitoring();
    {% endif %}
}

function startSanctionMonitoring() {
    // Vérifier 3 minutes avant la fin
    const timeToNotification = {{ remaining_seconds * 1000 }} - NOTIFICATION_TIME_BEFORE_END;
    
    if (timeToNotification > 0) {
        sanctionCheckTimer = setTimeout(() => {
            checkForSanctionThresholds();
        }, timeToNotification);
        
        console.log(`Surveillance des sanctions activée. Vérification dans ${Math.round(timeToNotification / 1000)} secondes.`);
    } else if ({{ remaining_seconds * 1000 }} > 0) {
        // Si il reste moins de 3 minutes, vérifier immédiatement
        checkForSanctionThresholds();
    }
}

async function checkForSanctionThresholds() {
    if (sanctionNotificationShown) return; // Éviter les notifications multiples
    
    try {
        const response = await fetch('{{ url_for("planning.check_sanction_thresholds") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                classroom_id: classroomId,
                initial_counts: initialSanctionCounts
            })
        });
        
        const result = await response.json();
        
        if (result.success && result.threshold_breaches.length > 0) {
            sanctionNotificationShown = true;
            await showSanctionNotification(result.threshold_breaches);
        }
    } catch (error) {
        console.error('Erreur lors de la vérification des seuils:', error);
    }
}

async function showSanctionNotification(breaches) {
    // Créer la notification en haut de la page
    const notification = document.createElement('div');
    notification.className = 'sanction-notification';
    notification.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #FEF3C7 0%, #F59E0B 100%);
        color: #92400E;
        padding: 1rem;
        z-index: 1000;
        border-bottom: 3px solid #F59E0B;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideDown 0.5s ease;
    `;
    
    let notificationHTML = `
        <div style="max-width: 1200px; margin: 0 auto;">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                <i class="fas fa-exclamation-triangle" style="font-size: 1.5rem;"></i>
                <h3 style="margin: 0; font-size: 1.25rem; font-weight: bold;">
                    🎯 Sanctions à attribuer - Demandez aux élèves d'apporter leur agenda
                </h3>
                <button onclick="closeSanctionNotification()" style="margin-left: auto; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #92400E;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div style="font-size: 0.95rem; line-height: 1.5;">
    `;
    
    // Traiter chaque seuil franchi
    for (const breach of breaches) {
        let dateInfo = '';
        if (breach.min_days_deadline) {
            try {
                // Calculer la prochaine date de cours
                const dateResponse = await fetch('{{ url_for("planning.calculate_next_lesson_date") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({
                        classroom_id: classroomId,
                        min_days: breach.min_days_deadline,
                        current_date: lessonDate
                    })
                });
                
                const dateResult = await dateResponse.json();
                if (dateResult.success && dateResult.next_date) {
                    dateInfo = ` - <strong>À rendre le ${dateResult.formatted_date}</strong>`;
                    
                    // Ajouter à la planification
                    await fetch('{{ url_for("planning.add_sanction_to_planning") }}', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            date: dateResult.next_date,
                            period_number: dateResult.period_number,
                            classroom_id: classroomId,
                            student_name: breach.student_name,
                            sanction_text: breach.sanction_text
                        })
                    });
                } else {
                    dateInfo = ' - <em>Date à déterminer</em>';
                }
            } catch (error) {
                console.error('Erreur calcul date:', error);
                dateInfo = ' - <em>Date à déterminer</em>';
            }
        }
        
        notificationHTML += `
            <div style="background: rgba(255, 255, 255, 0.3); padding: 0.75rem; margin: 0.5rem 0; border-radius: 0.5rem; border-left: 4px solid #F59E0B;">
                <strong>${breach.student_name}</strong> - ${breach.sanction_template} (${breach.threshold} coches) : 
                <strong>${breach.sanction_text}</strong>${dateInfo}
            </div>
        `;
    }
    
    notificationHTML += `
            </div>
        </div>
    `;
    
    notification.innerHTML = notificationHTML;
    document.body.appendChild(notification);
    
    // Ajouter le CSS pour l'animation
    if (!document.getElementById('sanction-notification-styles')) {
        const style = document.createElement('style');
        style.id = 'sanction-notification-styles';
        style.textContent = `
            @keyframes slideDown {
                from {
                    transform: translateY(-100%);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }
            @keyframes slideUp {
                from {
                    transform: translateY(0);
                    opacity: 1;
                }
                to {
                    transform: translateY(-100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Décaler le contenu principal vers le bas
    document.body.style.paddingTop = notification.offsetHeight + 'px';
}

function closeSanctionNotification() {
    const notification = document.querySelector('.sanction-notification');
    if (notification) {
        notification.style.animation = 'slideUp 0.5s ease';
        setTimeout(() => {
            notification.remove();
            document.body.style.paddingTop = '0';
        }, 500);
    }
}

// Fonctions pour la gestion des sanctions
async function updateSanctionCount(studentId, sanctionId, delta) {
    const countElement = document.querySelector(`[data-student="${studentId}"][data-sanction="${sanctionId}"]`);
    const currentCount = parseInt(countElement.textContent);
    const newCount = Math.max(0, currentCount + delta); // Ne pas aller en dessous de 0
    
    try {
        const response = await fetch('{{ url_for("planning.update_sanction_count") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                student_id: studentId,
                template_id: sanctionId,
                count: newCount
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            countElement.textContent = result.new_count;
            
            // Mettre à jour les classes CSS selon le nombre
            countElement.className = 'count-display';
            if (result.new_count >= 6) {
                countElement.classList.add('danger');
            } else if (result.new_count >= 3) {
                countElement.classList.add('warning');
            }
            
            // Animation de mise à jour
            countElement.style.transform = 'scale(1.2)';
            setTimeout(() => {
                countElement.style.transform = 'scale(1)';
            }, 200);
        } else {
            alert(result.message || 'Erreur lors de la mise à jour');
        }
    } catch (error) {
        console.error('Erreur:', error);
        alert('Erreur lors de la communication avec le serveur');
    }
}

// Initialiser les classes CSS des compteurs au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Appliquer les classes CSS aux compteurs selon leur valeur
    document.querySelectorAll('.count-display').forEach(element => {
        const count = parseInt(element.textContent);
        if (count >= 6) {
            element.classList.add('danger');
        } else if (count >= 3) {
            element.classList.add('warning');
        }
    });
    
    // Initialiser le système de surveillance des sanctions
    initializeSanctionSystem();
    
    // Gestionnaire de redimensionnement pour le plan de classe
    {% if seating_plan %}
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const seatingContent = document.getElementById('seating-plan-content');
            if (seatingContent && seatingContent.classList.contains('active')) {
                adjustSeatingScale();
            }
        }, 250);
    });
    {% endif %}
});

// Fonction pour afficher des infos debug dans le panneau
function updateDebugPanel(message) {
    const debugPanel = document.getElementById('js-debug-info');
    if (debugPanel) {
        debugPanel.innerHTML += '<div>' + message + '</div>';
    }
}

// Variables globales pour le système d'avertissements et l'historique
let warningHistory = []; // Historique des changements pour le bouton "annuler"
let currentWarnings = {}; // État actuel des avertissements {elementId_slotIndex: warningLevel}

// Fonction pour sauvegarder l'état dans l'historique
function saveToHistory() {
    warningHistory.push(JSON.parse(JSON.stringify(currentWarnings)));
    if (warningHistory.length > 50) { // Limiter l'historique à 50 actions
        warningHistory.shift();
    }
    updateUndoButton();
}

// Fonction pour annuler le dernier changement
function undoLastWarning() {
    if (warningHistory.length > 1) {
        warningHistory.pop(); // Enlever l'état actuel
        currentWarnings = JSON.parse(JSON.stringify(warningHistory[warningHistory.length - 1]));
        applyWarningStates();
        updateUndoButton();
    } else if (warningHistory.length === 1) {
        warningHistory.pop();
        currentWarnings = {};
        applyWarningStates();
        updateUndoButton();
    }
}

// Fonction pour appliquer les états d'avertissement visuellement
function applyWarningStates() {
    // Réinitialiser tous les slots
    document.querySelectorAll('.student-slot').forEach(slot => {
        slot.classList.remove('warning-1', 'warning-2', 'warning-3');
    });
    
    // Appliquer les états actuels
    Object.keys(currentWarnings).forEach(key => {
        const [elementId, slotIndex] = key.split('_');
        const element = document.querySelector(`[data-element-id="${elementId}"]`);
        if (element) {
            const slots = element.querySelectorAll('.student-slot');
            const slot = slots[parseInt(slotIndex)];
            if (slot && currentWarnings[key] > 0) {
                slot.classList.add(`warning-${currentWarnings[key]}`);
            }
        }
    });
}

// Fonction pour mettre à jour l'état du bouton annuler
function updateUndoButton() {
    const undoBtn = document.getElementById('undo-warning-btn');
    if (undoBtn) {
        undoBtn.disabled = warningHistory.length === 0;
    }
}

// Fonction pour charger et afficher le plan de classe
function loadSeatingPlan() {
    console.log('=== DEBUG loadSeatingPlan called ===');
    console.log('seating_plan available:', {{ 'true' if seating_plan else 'false' }});
    {% if seating_plan %}
    console.log('seating_plan data:', {{ seating_plan | tojson | safe }});
    console.log('Chargement du plan de classe...');
    
    const workspace = document.getElementById('seating-workspace');
    const viewer = document.getElementById('seating-plan-viewer');
    
    if (!workspace || !viewer) {
        console.error('Workspace ou viewer non trouvé');
        return;
    }
    
    // Nettoyer le workspace
    workspace.innerHTML = '';
    workspace.style.transform = 'none';
    
    // Récupérer les données du plan
    const planData = {{ seating_plan.plan_data | tojson | safe }};
    console.log('Données du plan:', planData);
    
    const elements = planData.elements || [];
    const studentsPlacement = planData.students_placement || [];
    
    // Créer les éléments du plan
    elements.forEach((elementData) => {
        const element = createSeatingElement(elementData);
        if (element) {
            element.style.left = elementData.x + 'px';
            element.style.top = elementData.y + 'px';
            workspace.appendChild(element);
        }
    });
    
    // Les données des étudiants sont déjà définies globalement
    // studentsData est disponible pour tous les scripts
    
    // Placer les étudiants
    studentsPlacement.forEach((placement) => {
        const element = workspace.querySelector(`[data-element-id="${placement.element_id}"]`);
        if (element) {
            const slots = element.querySelectorAll('.student-slot');
            if (slots[placement.slot_index]) {
                const slot = slots[placement.slot_index];
                
                // D'abord essayer de trouver l'étudiant par ID
                let student = studentsData.find(s => 
                    s.id === placement.student_id || String(s.id) === String(placement.student_id)
                );
                
                // Si pas trouvé par ID et qu'on a un nom dans le placement, essayer de mapper par nom
                if (!student && placement.student_name) {
                    student = studentsData.find(s => 
                        s.full_name === placement.student_name ||
                        (s.first_name + ' ' + (s.last_name || '')).trim() === placement.student_name
                    );
                    console.log(`DEBUG lesson_view: Student ${placement.student_id} not found by ID, trying by name "${placement.student_name}": ${student ? 'found' : 'not found'}`);
                }
                
                // Fallback: si toujours pas trouvé, essayer un mapping intelligent par index
                if (!student && studentsData.length > 0) {
                    // Créer un mapping basé sur l'ordre des IDs dans le placement vs l'ordre dans studentsData
                    const allPlacements = planData.students_placement || [];
                    const placementIds = [...new Set(allPlacements.map(p => p.student_id))].sort((a, b) => a - b);
                    const currentIndex = placementIds.indexOf(placement.student_id);
                    
                    if (currentIndex >= 0 && currentIndex < studentsData.length) {
                        student = studentsData[currentIndex];
                        console.log(`DEBUG lesson_view: Using fallback mapping - placement index ${currentIndex} -> student ${student.full_name}`);
                    }
                }
                
                console.log(`DEBUG lesson_view: Placement student_id=${placement.student_id}, Found student:`, student);
                console.log(`DEBUG lesson_view: Placement data:`, placement);
                console.log(`DEBUG lesson_view: Available students:`, studentsData);
                
                if (student) {
                    slot.innerHTML = `<div class="student-placed">${student.full_name}</div>`;
                    slot.classList.add('occupied');
                    console.log(`DEBUG lesson_view: Placed student ${student.full_name} in slot`);
                } else {
                    // Si vraiment pas trouvé, utiliser le nom stocké dans le placement si disponible
                    if (placement.student_name) {
                        slot.innerHTML = `<div class="student-placed student-not-found">${placement.student_name} (non trouvé)</div>`;
                        slot.classList.add('occupied');
                        console.log(`DEBUG lesson_view: Using stored name for student ${placement.student_id}: ${placement.student_name}`);
                    } else {
                        console.log(`DEBUG lesson_view: Student ${placement.student_id} not found in studentsData:`, studentsData.map(s => ({id: s.id, name: s.full_name})));
                    }
                }
            }
        }
    });
    
    // Ajuster l'échelle après le chargement
    setTimeout(() => {
        adjustSeatingScale();
    }, 200);
    
    // Initialiser l'état du système d'avertissements
    currentWarnings = {};
    warningHistory = [];
    updateUndoButton();
    
    // Observer les changements de taille du conteneur
    if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target.id === 'seating-plan-viewer') {
                    console.log('Plan de classe viewer redimensionné, ajustement de l\'échelle');
                    adjustSeatingScale();
                }
            }
        });
        
        const viewer = document.getElementById('seating-plan-viewer');
        if (viewer) {
            resizeObserver.observe(viewer);
        }
    }
    
    {% else %}
    console.log('Aucun plan de classe disponible pour cette classe');
    console.log('lesson_classroom info:', '{{ lesson_classroom.name if lesson_classroom else "No classroom" }}');
    {% endif %}
}

// Fonction pour créer un élément du plan
function createSeatingElement(elementData) {
    const element = document.createElement('div');
    element.className = 'seating-element';
    element.dataset.elementId = elementData.id;
    element.style.position = 'absolute';
    
    if (elementData.type === 'desk-single') {
        element.className += ' desk-single';
        element.style.minWidth = '80px';
        element.style.width = 'auto';
        element.style.height = '60px';
        element.innerHTML = '<div class="student-slots"><div class="student-slot"></div></div>';
        
        // Ajouter les événements de clic pour les tables d'élèves
        const slot = element.querySelector('.student-slot');
        if (slot) {
            slot.addEventListener('click', function(e) {
                e.stopPropagation();
                handleSlotClick(elementData.id, 0);
            });
            slot.style.cursor = 'pointer';
        }
    } else if (elementData.type === 'desk-double') {
        element.className += ' desk-double';
        element.style.minWidth = '140px';
        element.style.width = 'auto';
        element.style.height = '60px';
        element.innerHTML = '<div class="student-slots"><div class="student-slot"></div><div class="student-slot"></div></div>';
        
        // Ajouter les événements de clic pour les tables doubles
        const slots = element.querySelectorAll('.student-slot');
        slots.forEach((slot, index) => {
            slot.addEventListener('click', function(e) {
                e.stopPropagation();
                handleSlotClick(elementData.id, index);
            });
            slot.style.cursor = 'pointer';
        });
    } else if (elementData.type === 'teacher-desk') {
        element.className += ' teacher-desk';
        element.style.width = '120px';
        element.style.height = '80px';
        element.innerHTML = 'Bureau du professeur';
    }
    
    return element;
}

// Fonction pour gérer les clics sur les slots d'élèves
function handleSlotClick(elementId, slotIndex) {
    const key = `${elementId}_${slotIndex}`;
    
    // Cycles d'avertissement : 0 (normal) -> 1 (jaune) -> 2 (rouge) -> 3 (noir) -> 0 (normal)
    const currentLevel = currentWarnings[key] || 0;
    const nextLevel = (currentLevel + 1) % 4;
    
    if (nextLevel === 0) {
        delete currentWarnings[key];
    } else {
        currentWarnings[key] = nextLevel;
    }
    
    // Sauvegarder l'état actuel dans l'historique APRÈS la modification
    saveToHistory();
    
    // Appliquer visuellement les changements
    applyWarningStates();
    
    console.log(`Slot cliqué: ${elementId}, index: ${slotIndex}, niveau: ${nextLevel}`);
}

// Fonction pour ajuster l'échelle du plan pour qu'il s'adapte au conteneur
function adjustSeatingScale() {
    const workspace = document.getElementById('seating-workspace');
    const viewer = document.getElementById('seating-plan-viewer');
    
    if (!workspace || !viewer) return;
    
    // Attendre que le viewer ait une taille
    if (viewer.offsetWidth === 0) {
        setTimeout(adjustSeatingScale, 100);
        return;
    }
    
    const elements = workspace.querySelectorAll('.seating-element');
    if (elements.length === 0) return;
    
    // Calculer les limites du contenu
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    elements.forEach(element => {
        const x = parseFloat(element.style.left) || 0;
        const y = parseFloat(element.style.top) || 0;
        const width = element.offsetWidth;
        const height = element.offsetHeight;
        
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
    });
    
    // Ajouter une marge
    const margin = 40;
    minX -= margin;
    minY -= margin;
    maxX += margin;
    maxY += margin;
    
    // Calculer les dimensions du contenu
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    // Obtenir les dimensions du viewer
    const viewerWidth = viewer.offsetWidth;
    const viewerHeight = viewer.offsetHeight || 400; // Hauteur par défaut
    
    // Calculer l'échelle pour adapter le contenu
    const scaleX = viewerWidth / contentWidth;
    const scaleY = viewerHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY, 1); // Ne pas agrandir au-delà de 100%
    
    // Centrer le contenu
    const scaledWidth = contentWidth * scale;
    const scaledHeight = contentHeight * scale;
    const translateX = (viewerWidth - scaledWidth) / 2 - minX * scale;
    const translateY = (viewerHeight - scaledHeight) / 2 - minY * scale;
    
    // Appliquer la transformation
    workspace.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    workspace.style.transformOrigin = '0 0';
    
    console.log(`Plan ajusté: échelle ${scale}, translation (${translateX}, ${translateY})`);
}


</script>

<style>
.add-resource-btn, .edit-planning-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.375rem 0.75rem;
    background-color: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
    border-radius: var(--border-radius);
    text-decoration: none;
    font-size: 0.875rem;
    transition: all 0.3s ease;
    cursor: pointer;
}

.add-resource-btn:hover, .edit-planning-btn:hover {
    background-color: var(--primary-color);
    color: white;
}

.add-resource-btn {
    background-color: var(--primary-color);
    color: white;
}

.add-resource-btn:hover {
    background-color: var(--primary-hover);
}

/* Styles pour le formulaire de planification */
#planningEdit {
    animation: fadeIn 0.3s ease;
}

#planningForm .form-group {
    margin-bottom: 1rem;
}

#planningForm .form-label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--dark-color);
}

#planningForm .form-control {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #D1D5DB;
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: border-color 0.3s ease;
    font-family: inherit;
}

#planningForm .form-control:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

#planningForm textarea.form-control {
    resize: vertical;
    min-height: 120px;
}

.form-actions {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
}

.form-actions button {
    flex: 1;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideInNotification {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutNotification {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* Animation pour le changement de vue */
.planning-content > div {
    transition: opacity 0.2s ease;
}

/* Styles pour les ressources */
.resource-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.resource-btn {
    width: 32px;
    height: 32px;
    border: 1px solid var(--primary-color);
    background-color: transparent;
    color: var(--primary-color);
    border-radius: var(--border-radius);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.resource-btn:hover {
    background-color: var(--primary-color);
    color: white;
}

.resources-loading {
    text-align: center;
    padding: 2rem;
    color: var(--gray-color);
}

.resources-loading i {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.pinned-resources {
    margin-bottom: 1.5rem;
}

.pinned-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--light-gray);
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: var(--primary-color);
    font-size: 0.875rem;
}

.pinned-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.folder-navigation {
    margin-bottom: 1rem;
    background-color: #F8FAFC;
    border: 1px solid #E5E7EB;
    border-radius: 0.5rem;
    padding: 0.5rem;
}

.resource-breadcrumb {
    display: flex;
    align-items: center;
    gap: 0.125rem;
    font-size: 0.8rem;
    overflow-x: auto;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.resource-breadcrumb::-webkit-scrollbar {
    display: none;
}

.breadcrumb-item {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.15s ease;
    color: #6B7280;
    background-color: transparent;
    flex-shrink: 0;
    font-weight: 400;
}

.breadcrumb-item:hover {
    background-color: #E5E7EB;
    color: #374151;
}

.breadcrumb-item.active {
    background-color: var(--primary-color);
    color: white;
    font-weight: 500;
}

.breadcrumb-separator {
    color: #9CA3AF;
    margin: 0 0.125rem;
    font-size: 0.75rem;
    flex-shrink: 0;
}

.resources-tree {
    display: flex;
    flex-direction: column;
    gap: 1px;
    border: 1px solid #E5E7EB;
    border-radius: 0.5rem;
    overflow: hidden;
    background-color: white;
}

.resource-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background-color: white;
    transition: all 0.15s ease;
    cursor: pointer;
    border-bottom: 1px solid #F3F4F6;
    min-height: 44px;
}

.resource-item:last-child {
    border-bottom: none;
}

.resource-item:hover {
    background-color: #F8FAFC;
}

.resource-item.pinned {
    background-color: #FFFBEB;
    border-left: 3px solid #F59E0B;
}

.resource-item.pinned:hover {
    background-color: #FEF3C7;
}

.resource-item.folder {
    background-color: #F0F9FF;
    border-left: 3px solid #3B82F6;
    font-weight: 500;
}

.resource-item.folder:hover {
    background-color: #E0F2FE;
}

.resource-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    flex-shrink: 0;
}

.resource-icon.pdf {
    color: #DC2626;
}

.resource-icon.image {
    color: #059669;
}

.resource-icon.folder {
    color: #3B82F6;
}

.resource-icon.pinned {
    color: #F59E0B;
}

.resource-info {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.resource-main {
    flex: 1;
    min-width: 0;
}

.resource-name {
    font-weight: 400;
    color: var(--dark-color);
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.2;
}

.resource-item.folder .resource-name {
    font-weight: 500;
    color: #1E40AF;
}

.resource-meta {
    font-size: 0.75rem;
    color: #6B7280;
    display: flex;
    gap: 0.75rem;
    margin-top: 0.125rem;
    white-space: nowrap;
}

.resource-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
    margin-left: 0.5rem;
}

.resource-action-btn {
    width: 24px;
    height: 24px;
    border: none;
    background-color: transparent;
    color: #9CA3AF;
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    opacity: 0;
    font-size: 0.75rem;
}

.resource-item:hover .resource-action-btn {
    opacity: 1;
}

.resource-action-btn:hover {
    background-color: #F3F4F6;
    color: var(--primary-color);
}

.resource-action-btn.pinned {
    color: #F59E0B;
    opacity: 1;
}

.resource-action-btn.pinned:hover {
    background-color: #FEF3C7;
}

/* Styles pour les fichiers annotables */
.clickable-file {
    cursor: pointer;
    color: var(--primary-color) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.clickable-file:hover {
    text-decoration: underline;
    color: var(--primary-hover) !important;
}

.annotatable-badge {
    background-color: #10B981;
    color: white;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    font-size: 0.6rem;
    font-weight: 600;
}

/* Responsive */
@media (max-width: 1200px) {
    .resource-meta {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .resource-actions {
        flex-direction: column;
    }
}

/* Styles pour le plan de classe dans l'onglet */
.seating-plan-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid #e9ecef;
    background-color: #f8f9fa;
}

.seating-plan-info h3 {
    margin: 0;
    color: #333;
    font-size: 1.1rem;
}

.seating-plan-info p {
    margin: 0.25rem 0 0 0;
    color: #666;
    font-size: 0.875rem;
}

/* Styles supplémentaires pour le bouton d'annulation */
#undo-warning-btn {
    font-size: 0.875rem;
}

#undo-warning-btn i {
    margin-right: 0.25rem;
}

.seating-plan-container {
    height: calc(100% - 80px);
    padding: 1rem;
}

.seating-plan-viewer {
    background: white;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 400px;
}

.seating-workspace {
    width: 100% !important;
    height: 100% !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    background: white;
    background-image: radial-gradient(circle, #e9ecef 1px, transparent 1px);
    background-size: 20px 20px;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    outline: none !important;
    box-sizing: border-box !important;
    min-width: unset !important;
    max-width: none !important;
    min-height: unset !important;
    max-height: none !important;
}

/* Éléments du plan */
.seating-element {
    position: absolute;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: default;
    user-select: none;
}

.desk-single {
    background: white;
    border: 2px solid black;
    color: black;
}

.desk-double {
    background: white;
    border: 2px solid black;
    color: black;
}

.teacher-desk {
    background: #f0f0f0;
    border: 2px solid #333;
    color: #333;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

.student-slots {
    display: flex;
    gap: 4px;
    justify-content: center;
    align-items: center;
    height: 100%;
    padding: 4px;
    flex-wrap: nowrap;
    min-width: 100%;
    width: auto;
}

.student-slot {
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #666;
    border-radius: 4px;
    background: white;
    height: 80%;
    min-width: 30px;
    max-width: 120px;
    width: auto;
    font-size: 0.7rem;
    text-align: center;
    padding: 2px 6px;
    overflow: visible;
    flex: 1 1 auto;
    white-space: nowrap;
}

.student-slot.occupied {
    background: white;
    border-color: black;
    color: black;
}

/* États d'avertissement pour les slots d'élèves */
.student-slot.warning-1 {
    background: #fff3cd !important;
    border-color: #ffc107 !important;
    color: #856404 !important;
}

.student-slot.warning-2 {
    background: #f8d7da !important;
    border-color: #dc3545 !important;
    color: #721c24 !important;
}

.student-slot.warning-3 {
    background: rgba(52, 58, 64, 0.7) !important;
    border-color: rgba(0, 0, 0, 0.8) !important;
    color: #fff !important;
}

.student-placed {
    color: black;
    font-size: 0.65rem;
    line-height: 1.1;
    text-align: center;
    font-weight: 500;
    width: auto;
    white-space: nowrap;
    overflow: visible;
    text-overflow: unset;
    padding: 0 2px;
}

.student-not-found {
    color: #dc3545 !important;
    font-style: italic;
    opacity: 0.7;
}

/* Vue côte-à-côte pour édition de planification avec visualisation PDF */
.split-view-container {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f5f5f5;
    z-index: 9999;
}

.split-view-container.active {
    display: flex;
}

.split-view-left {
    width: 40%;
    height: 100%;
    background-color: white;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
    overflow-y: auto;
    padding: 2rem;
}

.split-view-left .form-group {
    margin-bottom: 1.5rem;
}

.split-view-left .form-control {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #D1D5DB;
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: border-color 0.3s ease;
}

.split-view-left .form-control:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.split-view-left textarea.form-control {
    resize: vertical;
    min-height: 200px;
}

.split-view-right {
    width: 60%;
    height: 100%;
    position: relative;
    overflow: hidden;
}

.split-view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}

.split-view-close {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10001;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.split-view-close:hover {
    background-color: rgba(0, 0, 0, 0.9);
}

/* Styles pour le Modal Viewer/Annotateur Amélioré */
.file-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    display: none;
    flex-direction: column;
}

.file-viewer-modal.show {
    display: flex;
}

/* Mode intégré pour le viewer dans la vue split */
.file-viewer-modal.embedded {
    position: absolute;
    background-color: transparent;
}

.file-viewer-modal.embedded .viewer-header {
    background-color: #2d3748;
    color: white;
}

.viewer-header {
    background-color: #f8fafc;
    color: #2d3748;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    z-index: 1;
    position: relative;
}

.viewer-title {
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 0.95rem;
    font-weight: 500;
}

/* Styles page-info supprimés */

.viewer-tools {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: nowrap;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding-right: 1.5rem;
    border-right: 1px solid #e2e8f0;
}

.tool-group:last-child {
    border-right: none;
    padding-right: 0;
}

.tool-btn {
    width: 40px;
    height: 40px;
    border: 1px solid #e2e8f0;
    background-color: #ffffff;
    color: #4a5568;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.tool-btn:hover {
    background-color: #f7fafc;
    border-color: #cbd5e0;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}

.tool-btn.active {
    background-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
}

.color-picker-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #ffffff;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 1;
}

.preset-colors {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.color-btn {
    width: 28px;
    height: 28px;
    border: 2px solid transparent;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    z-index: 1;
}

.color-btn:hover {
    transform: scale(1.1);
    border-color: white;
}

.color-btn.active {
    border-color: white;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

.color-picker-container input[type="color"] {
    width: 32px;
    height: 32px;
    border: 2px solid transparent;
    border-radius: 0.5rem;
    cursor: pointer;
    background: none;
}

.stroke-width-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #4A5568;
    padding: 0.5rem;
    border-radius: 0.5rem;
    position: relative;
    z-index: 10;
}

.stroke-width-container input[type="range"] {
    width: 80px;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: #6B7280;
    outline: none;
    border-radius: 3px;
    cursor: pointer;
}

.stroke-width-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.stroke-width-container input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    border: none;
}

#strokeWidthValue {
    min-width: 20px;
    text-align: center;
    font-size: 0.9rem;
}

.close-viewer {
    width: 40px;
    height: 40px;
    border: none;
    background-color: #E53E3E;
    color: white;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.close-viewer:hover {
    background-color: #C53030;
    transform: scale(1.05);
}

.viewer-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
    z-index: 0;
}

.viewer-container {
    max-width: 100%;
    max-height: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Styles d'annotation canvas supprimés - dupliqués plus bas */

.pdf-container, .image-container {
    position: relative;
    display: inline-block;
}

.viewer-footer {
    background-color: #2D3748;
    color: white;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-top: 1px solid #4A5568;
}

.save-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #68D391;
    font-size: 0.9rem;
}

.save-status.saving {
    color: #F6AD55;
}

.save-status.error {
    color: #FC8181;
}

/* Styles pour la nouvelle interface améliorée */
/* Styles zoomLevel supprimés */

.viewer-content {
    flex: 1;
    display: flex;
    overflow: hidden;
    position: relative;
    min-height: 0; /* Allow flex children to shrink */
}

/* Barre latérale des pages - permanente à gauche */
.page-sidebar {
    width: 220px;
    background-color: #f8fafc;
    border-right: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
}

.page-sidebar.show {
    display: flex;
}

.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.sidebar-header h6 {
    margin: 0;
    color: white;
    font-size: 0.9rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}


/* Zone de miniatures scrollable moderne */
.page-thumbnails {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f1f5f9;
}

.page-thumbnails.scrollable {
    max-height: calc(100vh - 200px);
}

.page-thumbnails::-webkit-scrollbar {
    width: 8px;
}

.page-thumbnails::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
}

.page-thumbnails::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
    transition: background 0.2s ease;
}

.page-thumbnails::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.thumbnail-item {
    margin-bottom: 0.75rem;
    border: 2px solid transparent;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.thumbnail-item:hover {
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.thumbnail-item.active {
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
}

.thumbnail-canvas {
    width: 100%;
    display: block;
    border-radius: 0.25rem;
}

/* Zone d'affichage principal */
.viewer-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 1rem;
    background-color: #f7fafc;
    position: relative;
    height: 100%;
    scroll-behavior: auto;
}

.pdf-pages-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 1rem 0;
    min-height: 100%;
    width: 100%;
}

.pdf-page-wrapper {
    position: relative;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    margin-bottom: 1rem;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 0.5rem;
    pointer-events: auto;
    z-index: 2;
}

.pdf-page-number {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    z-index: 10;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
    cursor: crosshair;
    border-radius: 0.5rem;
    width: 100%;
    height: 100%;
    pointer-events: auto;
}

/* États des boutons */
.tool-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.tool-btn:disabled:hover {
    background-color: #4A5568;
    transform: none;
}

/* Animation de chargement */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.loading {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Styles pour les erreurs */
.error-message {
    color: #fc8181;
    text-align: center;
    padding: 2rem;
    background-color: #fed7d7;
    border-radius: 0.5rem;
    margin: 1rem;
}

/* Responsive pour le viewer amélioré */
@media (max-width: 768px) {
    .viewer-header {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .viewer-tools {
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .tool-group {
        padding-right: 0.5rem;
        border-right: none;
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    .tool-group:last-child {
        border-bottom: none;
        margin-bottom: 0;
    }
    
    .tool-btn {
        width: 35px;
        height: 35px;
    }
    
    .stroke-width-container input[type="range"] {
        width: 60px;
    }
    
    .viewer-footer {
        padding: 0.5rem 1rem;
    }
    
    .page-sidebar {
        width: 180px;
    }
    
    .page-sidebar.show {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 100;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    .viewer-container {
        padding: 0.5rem;
    }
    
    .viewer-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
    }
    
    /* Styles zoomLevel responsive supprimés */
}

@media (max-width: 480px) {
    .viewer-header {
        padding: 0.5rem;
    }
    
    .viewer-tools {
        justify-content: center;
        width: 100%;
    }
    
    .tool-group {
        gap: 0.25rem;
    }
    
    .tool-btn {
        width: 32px;
        height: 32px;
        font-size: 0.8rem;
    }
    
    .color-btn {
        width: 24px;
        height: 24px;
    }
    
    .page-sidebar {
        width: 160px;
    }
}

/* Styles pour l'intégration du lecteur PDF unifié */
.file-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    display: none;
}

.unified-pdf-viewer-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    background: white;
}

.unified-pdf-viewer-wrapper .close-viewer {
    position: absolute;
    top: 2rem;
    right: 1rem;
    z-index: 10001;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.3s ease;
}

.unified-pdf-viewer-wrapper .close-viewer:hover {
    background: rgba(0, 0, 0, 0.9);
    transform: scale(1.1);
}

#unified-pdf-viewer-container {
    width: 100%;
    height: 100%;
}

/* Correction affichage miniatures - scroll vertical avec miniatures pleine largeur */
.thumbnails-container {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 12px !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    padding: 12px !important;
    height: 100% !important;
    flex: 1 !important;
    grid-auto-rows: max-content !important;
}

.thumbnail-item {
    width: 100% !important;
    min-width: auto !important;
    max-width: none !important;
    height: auto !important;
    min-height: 140px !important;
    padding: 8px !important;
    margin-bottom: 0 !important;
    box-sizing: border-box !important;
    display: flex !important;
    flex-direction: column !important;
}

.thumbnail-canvas {
    width: calc(100% - 16px) !important;
    height: 120px !important;
    min-height: 120px !important;
    max-height: 120px !important;
    max-width: 100% !important;
    display: block !important;
    object-fit: contain !important;
    border: 1px solid #ddd !important;
    margin: 0 auto !important;
    flex-shrink: 0 !important;
}

.thumbnail-number {
    font-size: 10px !important;
    padding: 1px 3px !important;
    position: absolute !important;
    bottom: 4px !important;
    left: 4px !important;
    background: rgba(0, 0, 0, 0.4) !important;
    color: white !important;
    border-radius: 2px !important;
    font-weight: 600 !important;
    line-height: 1 !important;
    min-width: auto !important;
    max-width: fit-content !important;
    width: auto !important;
    height: auto !important;
    text-align: center !important;
    z-index: 10 !important;
    display: inline-block !important;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
}

/* Améliorer la scrollbar verticale */
.thumbnails-container::-webkit-scrollbar {
    width: 8px !important;
    height: auto !important;
}

.thumbnails-container::-webkit-scrollbar-track {
    background: #f1f1f1 !important;
    border-radius: 4px !important;
}

.thumbnails-container::-webkit-scrollbar-thumb {
    background: #c1c1c1 !important;
    border-radius: 4px !important;
}

.thumbnails-container::-webkit-scrollbar-thumb:hover {
    background: #a1a1a1 !important;
}

/* S'assurer que le panneau des miniatures utilise tout l'espace */
#thumbnails-panel {
    display: flex !important;
    flex-direction: column !important;
    height: 100% !important;
    min-height: 200px !important;
    max-height: none !important;
}

/* Surcharger TOUTES les contraintes avec des sélecteurs ultra-spécifiques */
.unified-pdf-viewer .thumbnails-container .thumbnail-item,
#thumbnails-container .thumbnail-item,
#thumbnails-panel .thumbnail-item,
body .thumbnail-item {
    width: 100% !important;
    min-height: 140px !important;
    max-height: none !important;
    height: auto !important;
    padding: 8px !important;
    margin-bottom: 0 !important;
    display: flex !important;
    flex-direction: column !important;
}

.unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
#thumbnails-container .thumbnail-canvas,
#thumbnails-panel .thumbnail-canvas,
body .thumbnail-canvas {
    width: calc(100% - 16px) !important;
    height: 120px !important;
    min-height: 120px !important;
    max-height: 120px !important;
    object-fit: contain !important;
    border: 1px solid #ddd !important;
    margin: 0 auto !important;
    flex-shrink: 0 !important;
}

/* Surcharger toutes les media queries avec des hauteurs fixes */
@media (max-width: 1200px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 140px !important;
        height: auto !important;
        padding: 8px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 120px !important;
        min-height: 120px !important;
        max-height: 120px !important;
        width: calc(100% - 16px) !important;
    }
    
    .thumbnail-number {
        font-size: 9px !important;
        padding: 1px 2px !important;
        bottom: 3px !important;
        left: 3px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 900px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 130px !important;
        height: auto !important;
        padding: 6px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 110px !important;
        min-height: 110px !important;
        max-height: 110px !important;
        width: calc(100% - 12px) !important;
    }
    
    .thumbnail-number {
        font-size: 8px !important;
        padding: 1px 2px !important;
        bottom: 3px !important;
        left: 3px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 768px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 120px !important;
        height: auto !important;
        padding: 6px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 100px !important;
        min-height: 100px !important;
        max-height: 100px !important;
        width: calc(100% - 12px) !important;
    }
    
    .thumbnail-number {
        font-size: 8px !important;
        padding: 1px 2px !important;
        bottom: 2px !important;
        left: 2px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 600px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 110px !important;
        height: auto !important;
        padding: 4px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 90px !important;
        min-height: 90px !important;
        max-height: 90px !important;
        width: calc(100% - 8px) !important;
    }
    
    .thumbnail-number {
        font-size: 7px !important;
        padding: 1px 2px !important;
        bottom: 2px !important;
        left: 2px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}

@media (max-width: 400px) {
    .unified-pdf-viewer .thumbnails-container .thumbnail-item,
    #thumbnails-container .thumbnail-item,
    #thumbnails-panel .thumbnail-item {
        min-height: 100px !important;
        height: auto !important;
        padding: 4px !important;
    }
    
    .unified-pdf-viewer .thumbnails-container .thumbnail-canvas,
    #thumbnails-container .thumbnail-canvas,
    #thumbnails-panel .thumbnail-canvas {
        height: 80px !important;
        min-height: 80px !important;
        max-height: 80px !important;
        width: calc(100% - 8px) !important;
    }
    
    .thumbnail-number {
        font-size: 6px !important;
        padding: 1px 2px !important;
        bottom: 1px !important;
        left: 1px !important;
        background: rgba(0, 0, 0, 0.4) !important;
    }
}
</style>

<!-- Lecteur PDF Unifié -->
<script src="{{ url_for('static', filename='js/unified-pdf-viewer.js') }}"></script>
<script>
// Variables globales pour le lecteur PDF unifié
let unifiedPDFViewer = null;
let currentPDFUrl = null;

// Données des étudiants (définies globalement pour le PDF viewer)
let studentsData = [
    {% for student in students %}
    {
        id: {{ student.id }},
        first_name: "{{ student.first_name }}",
        last_name: "{{ student.last_name or '' }}",
        full_name: "{{ student.full_name }}"
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];

// Fonction pour ouvrir un fichier avec le nouveau lecteur unifié
function openFileWithUnifiedViewer(filePath, fileName) {
    console.log('🎯 Ouverture avec le lecteur unifié:', fileName);
    
    // Afficher la modal
    const modal = document.getElementById('fileViewerModal');
    if (!modal) {
        console.error('Modal fileViewerModal non trouvée');
        return;
    }
    
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Vérifier la disponibilité des données des élèves
    if (typeof studentsData === 'undefined' || !Array.isArray(studentsData)) {
        console.warn('studentsData non défini, utilisation d’un tableau vide');
        studentsData = [];
    }
    
    // Préparer les données des élèves et sanctions pour le PDF viewer
    const sanctionsData = {};
    try {
        // Récupérer les compteurs de sanctions actuels
        document.querySelectorAll('.count-display').forEach(element => {
            const studentId = element.dataset.student;
            const sanctionId = element.dataset.sanction;
            const count = parseInt(element.textContent) || 0;
            if (studentId && sanctionId) {
                sanctionsData[`${studentId}_${sanctionId}`] = count;
            }
        });
    } catch (error) {
        console.warn('Erreur lors de la récupération des sanctions:', error);
    }
    
    // Récupérer le HTML du plan de classe actuel s'il existe
    let seatingPlanHTML = null;
    try {
        const seatingWorkspace = document.querySelector('#seating-workspace');
        if (seatingWorkspace) {
            seatingPlanHTML = seatingWorkspace.outerHTML;
        }
    } catch (error) {
        console.warn('Erreur lors de la récupération du plan de classe:', error);
    }
    
    // Créer l'instance du lecteur unifié s'il n'existe pas
    if (!unifiedPDFViewer) {
        try {
            unifiedPDFViewer = new UnifiedPDFViewer('unified-pdf-viewer-container', {
                mode: 'teacher',
                enableKeyboardShortcuts: true,
                enableTouchGestures: true,
                autoSave: true,
                saveDelay: 3000,
                debug: true,
                studentData: studentsData, // Utiliser les données globales des élèves
                sanctionsData: sanctionsData,
                seatingPlanHTML: seatingPlanHTML,
                apiEndpoints: {
                    saveAnnotations: '/file_manager/api/save-annotations',
                    loadAnnotations: '/file_manager/api/load-annotations',
                    search: '/api/search-pdf'
                }
            });
            console.log('✅ Lecteur PDF unifié créé avec données des élèves');
        } catch (error) {
            console.error('❌ Erreur lors de la création du lecteur:', error);
            return;
        }
    }
    
    // Charger le PDF en utilisant la même URL que l'ancien système
    const pdfUrl = `/file_manager/serve_file/${encodeURIComponent(filePath)}`;
    currentPDFUrl = pdfUrl;
    
    // Passer filePath comme fileId pour permettre le chargement des annotations
    unifiedPDFViewer.loadPDF(pdfUrl, filePath)
        .then(() => {
            console.log('✅ PDF chargé avec succès dans le lecteur unifié');
        })
        .catch(error => {
            console.error('❌ Erreur lors du chargement du PDF:', error);
            alert('Erreur lors du chargement du PDF: ' + error.message);
        });
}

// Fonction pour fermer le viewer (mise à jour pour le nouveau lecteur)
function closeFileViewer() {
    console.log('🔄 Fermeture du lecteur PDF unifié');
    
    const modal = document.getElementById('fileViewerModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
    
    // Nettoyer l'instance du lecteur si nécessaire
    if (unifiedPDFViewer) {
        // Appeler la méthode destroy pour nettoyer tout, y compris le panneau de graphique
        unifiedPDFViewer.destroy();
        console.log('📄 Lecteur PDF unifié nettoyé et panneau de graphique fermé');
    }
    
    currentPDFUrl = null;
}

// Fonction modifiée pour ouvrir les fichiers (remplace l'ancienne fonction openFile)
function openFile(filePath, fileName, fileType) {
    console.log('📁 Ouverture du fichier:', fileName, 'Type:', fileType);
    
    if (fileType === 'pdf') {
        // Utiliser le nouveau lecteur unifié pour les PDF
        openFileWithUnifiedViewer(filePath, fileName);
    } else {
        // Pour les autres types de fichiers, utiliser l'ancienne méthode ou rediriger
        window.open(`/file_manager/serve_file/${encodeURIComponent(filePath)}`, '_blank');
    }
}

// Gérer la fermeture avec Échap
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const modal = document.getElementById('fileViewerModal');
        if (modal && modal.style.display === 'block') {
            closeFileViewer();
        }
    }
});

// Initialiser l'apparence des boutons au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser les boutons de retard pour tous les élèves
    {% for student in students %}
    updateAttendanceButtons({{ student.id }});
    {% endfor %}
});
</script>
{% endblock %}
