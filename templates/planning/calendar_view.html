{% extends "base.html" %}

{% block title %}Calendrier - TeacherPlanner{% endblock %}

{% block extra_css %}
<!-- Cache busting pour forcer le rechargement -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<link rel="stylesheet" href="{{ url_for('static', filename='css/calendar.css') }}">
<!-- PDF.js pour l'affichage des PDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<!-- Font Awesome pour les ic√¥nes -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!-- Dessin natif Canvas optimis√© - pas de d√©pendance externe -->
<!-- Lecteur PDF unifi√© -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/unified-pdf-viewer.css') }}">
<script>
// Configuration du worker PDF.js
if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    console.log('PDF.js worker configur√©');
}
</script>
<style>
/* Styles pour le modal de planification avec gestionnaire de fichiers */
.planning-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    overflow-y: auto;
    padding: 2rem 0;
}

.planning-modal.show {
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding-top: 5vh;
}

.planning-modal .modal-content {
    background-color: var(--white);
    border-radius: var(--border-radius);
    max-width: 500px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: var(--shadow-lg);
    animation: slideUp 0.3s ease-out;
    position: relative;
    margin: 0 auto;
}

.planning-modal.split-view {
    background: none;
}

.planning-modal.split-view .modal-content {
    width: 500px;
    position: fixed;
    left: calc(50% - 510px);
    top: 5vh;
}

.file-manager-panel {
    position: fixed;
    top: 5vh;
    left: calc(50% - 10px);
    width: 500px;
    height: 90vh;
    max-height: 90vh;
    background-color: white;
    border: 1px solid #e5e7eb;
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    z-index: 1001;
}

.file-manager-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    background-color: white;
    border-bottom: 1px solid #e5e7eb;
}

.file-manager-header h3 {
    margin: 0;
    font-size: 1.125rem;
    color: #1f2937;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.file-manager-content {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
}

.modal-header-actions {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.btn-icon {
    background: none;
    border: none;
    padding: 0.5rem;
    cursor: pointer;
    border-radius: 0.375rem;
    color: #6b7280;
    transition: all 0.2s;
}

.btn-icon:hover {
    background-color: #f3f4f6;
    color: #1f2937;
}

.file-loading {
    text-align: center;
    padding: 3rem;
    color: #6b7280;
}

.file-navigation {
    margin-bottom: 1rem;
}

.breadcrumb {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: #6b7280;
}

.breadcrumb-item {
    cursor: pointer;
    transition: color 0.2s;
}

.breadcrumb-item:hover {
    color: var(--primary-color);
}

.breadcrumb-item.active {
    color: #1f2937;
    font-weight: 500;
}

.file-tree {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.file-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.file-item:hover {
    background-color: #e5e7eb;
}

.file-item.folder {
    font-weight: 500;
}

.file-icon {
    font-size: 1.125rem;
    width: 20px;
    text-align: center;
}

.file-icon.fa-folder {
    color: #f59e0b;
}

.file-icon.fa-file-pdf {
    color: #dc2626;
}

.file-icon.fa-file-image {
    color: #10b981;
}

.file-name {
    flex: 1;
    font-size: 0.875rem;
    color: #374151;
}

.no-files {
    text-align: center;
    padding: 3rem;
    color: #9ca3af;
}

.no-files i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

/* Styles pour le Modal Viewer/Annotateur Am√©lior√© (copi√©s exactement de lesson_view.html) */
.file-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    display: none;
    flex-direction: column;
}

.file-viewer-modal.show {
    display: flex;
}

/* Mode int√©gr√© pour le viewer dans la vue split */
.file-viewer-modal.embedded {
    position: fixed;
    top: 5vh;
    left: calc(50% - 10px);
    width: calc(50% + 10px);
    height: 90vh;
    background-color: rgba(0, 0, 0, 0.95);
    border-radius: var(--border-radius);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    z-index: 1001;
}

.file-viewer-modal.embedded .viewer-header {
    background-color: #2d3748;
    color: white;
}

.viewer-header {
    background-color: #f8fafc;
    color: #2d3748;
    padding: 0.5rem 1rem;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    z-index: 1;
    position: relative;
}

.viewer-title {
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 0.95rem;
    font-weight: 500;
}

.viewer-tools {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: nowrap;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding-right: 0.75rem;
    border-right: 1px solid #e2e8f0;
}

.tool-group:last-child {
    border-right: none;
    padding-right: 0;
}

.tool-btn {
    width: 32px;
    height: 32px;
    border: 1px solid #e2e8f0;
    background-color: #ffffff;
    color: #4a5568;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.tool-btn:hover {
    background-color: #f7fafc;
    border-color: #cbd5e0;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}

.tool-btn.active {
    background-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
}

.color-picker-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #ffffff;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 1;
}

.preset-colors {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.color-btn {
    width: 22px;
    height: 22px;
    border: 2px solid transparent;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    z-index: 1;
}

.color-btn:hover {
    transform: scale(1.1);
    border-color: white;
}

.color-btn.active {
    border-color: white;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

.color-picker-container input[type="color"] {
    width: 26px;
    height: 26px;
    border: 2px solid transparent;
    border-radius: 0.5rem;
    cursor: pointer;
    background: none;
}

.stroke-width-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #4A5568;
    padding: 0.5rem;
    border-radius: 0.5rem;
    position: relative;
    z-index: 10;
}

.stroke-width-container input[type="range"] {
    width: 60px;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: #6B7280;
    outline: none;
    border-radius: 3px;
    cursor: pointer;
}

.stroke-width-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.stroke-width-container input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    border: none;
}

#strokeWidthValue {
    min-width: 20px;
    text-align: center;
    font-size: 0.9rem;
}

.close-viewer {
    width: 32px;
    height: 32px;
    border: none;
    background-color: #E53E3E;
    color: white;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: auto;
}

.close-viewer:hover {
    background-color: #C53030;
    transform: scale(1.05);
}

.viewer-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
    z-index: 0;
}

.viewer-container {
    max-width: 100%;
    max-height: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

.pdf-container, .image-container {
    position: relative;
    display: inline-block;
}

.viewer-footer {
    background-color: #2D3748;
    color: white;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-top: 1px solid #4A5568;
}

.save-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #68D391;
    font-size: 0.9rem;
}

.save-status.saving {
    color: #F6AD55;
}

.save-status.error {
    color: #FC8181;
}

.viewer-content {
    flex: 1;
    display: flex;
    overflow: hidden;
    position: relative;
    min-height: 0; /* Allow flex children to shrink */
}

/* Barre lat√©rale des pages - permanente √† gauche */
.page-sidebar {
    width: 220px;
    background-color: #f8fafc;
    border-right: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
}

.page-sidebar.show {
    display: flex;
}

.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.sidebar-header h6 {
    margin: 0;
    color: white;
    font-size: 0.9rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* Zone de miniatures scrollable moderne */
.page-thumbnails {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f1f5f9;
}

.page-thumbnails.scrollable {
    max-height: calc(100vh - 200px);
}

.page-thumbnails::-webkit-scrollbar {
    width: 8px;
}

.page-thumbnails::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
}

.page-thumbnails::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
    transition: background 0.2s ease;
}

.page-thumbnails::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.thumbnail-item {
    margin-bottom: 0.75rem;
    border: 2px solid transparent;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.thumbnail-item:hover {
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.thumbnail-item.active {
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
}

.thumbnail-canvas {
    width: 100%;
    display: block;
    border-radius: 0.25rem;
}

/* Zone d'affichage principal */
.viewer-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 1rem;
    background-color: #f7fafc;
    position: relative;
    height: 100%;
    scroll-behavior: smooth;
    /* Assurer un scroll fluide et pr√©cis */
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f1f5f9;
}

.pdf-pages-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 1rem 0;
    min-height: 100%;
    width: 100%;
}

.pdf-page-wrapper {
    position: relative;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    margin-bottom: 1rem;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 0.5rem;
    pointer-events: auto;
    touch-action: none;
    z-index: 2;
}

.pdf-page-number {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    z-index: 10;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
    cursor: crosshair;
    border-radius: 0.5rem;
    width: 100%;
    height: 100%;
    pointer-events: auto;
    touch-action: none;
}

/* √âtats des boutons */
.tool-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.tool-btn:disabled:hover {
    background-color: #4A5568;
    transform: none;
}

/* Animation de chargement */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.loading {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Styles pour les erreurs */
.error-message {
    color: #fc8181;
    text-align: center;
    padding: 2rem;
    background-color: #fed7d7;
    border-radius: 0.5rem;
    margin: 1rem;
}

/* Responsive pour le viewer am√©lior√© */
@media (max-width: 768px) {
    .viewer-header {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .viewer-tools {
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .tool-group {
        padding-right: 0.5rem;
        border-right: none;
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    .tool-group:last-child {
        border-bottom: none;
        margin-bottom: 0;
    }
    
    .tool-btn {
        width: 35px;
        height: 35px;
    }
    
    .stroke-width-container input[type="range"] {
        width: 60px;
    }
    
    .viewer-footer {
        padding: 0.5rem 1rem;
    }
    
    .page-sidebar {
        width: 180px;
    }
    
    .page-sidebar.show {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 100;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    .viewer-container {
        padding: 0.5rem;
    }
    
    .viewer-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
    }
}

@media (max-width: 480px) {
    .viewer-header {
        padding: 0.5rem;
    }
    
    .viewer-tools {
        justify-content: center;
        width: 100%;
    }
    
    .tool-group {
        gap: 0.25rem;
    }
    
    .tool-btn {
        width: 32px;
        height: 32px;
        font-size: 0.8rem;
    }
    
    .color-btn {
        width: 24px;
        height: 24px;
    }
    
    .page-sidebar {
        width: 160px;
    }
}

/* Overlay pour les modals */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999;
}

/* Styles additionnels pour les indicateurs de checklist */
.checklist-summary {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.65rem;
    margin-top: 0.125rem;
}

.checklist-icon {
    font-size: 0.75rem;
}

.checklist-icon.all-checked {
    color: #10B981;
}

.checklist-icon.partial {
    color: #F59E0B;
}

.checklist-icon.none-checked {
    color: #EF4444;
}

.checklist-count {
    color: rgba(255, 255, 255, 0.8);
    font-weight: 500;
}

/* Pour la vue annuelle */
.annual-planning-checklist {
    display: flex;
    align-items: center;
    gap: 0.125rem;
    font-size: 0.5rem;
    margin-bottom: 0.125rem;
}

.annual-checklist-icon {
    font-size: 0.5rem;
}

/* Styles pour le modal de planification journali√®re */
.day-plannings-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-top: 1rem;
}

.day-planning-item {
    background-color: white;
    border-radius: 0.5rem;
    padding: 1rem;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease;
}

.day-planning-item:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.planning-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.planning-period {
    font-weight: 600;
    color: #1f2937;
    font-size: 0.875rem;
}

.planning-time {
    font-size: 0.75rem;
    color: #6b7280;
    background-color: #f3f4f6;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
}

.planning-content {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.planning-class {
    font-weight: 500;
    color: #374151;
    font-size: 0.875rem;
}

.planning-title {
    font-size: 0.65rem;
    font-weight: 400;
    color: white;
}

.planning-description {
    font-size: 0.875rem;
    color: #6b7280;
    margin-top: 0.5rem;
    line-height: 1.4;
}

/* Styles pour les cr√©neaux journaliers √©ditables */
.day-schedules-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-top: 1rem;
}

.day-schedule-slot {
    background-color: white;
    border-radius: 0.5rem;
    padding: 1rem;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease;
    cursor: pointer;
}

.day-schedule-slot:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.slot-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.slot-period {
    font-weight: 600;
    color: #1f2937;
    font-size: 0.875rem;
}

.slot-time {
    font-size: 0.75rem;
    color: #6b7280;
    background-color: #f3f4f6;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
}

.btn-edit-slot {
    background: none;
    border: none;
    color: #6b7280;
    cursor: pointer;
    padding: 0.25rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
}

.btn-edit-slot:hover {
    background-color: #f3f4f6;
    color: #4f46e5;
}

.slot-content {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.slot-class {
    font-weight: 500;
    color: #374151;
    font-size: 0.875rem;
}

.slot-title {
    font-size: 1rem;
    font-weight: 600;
    color: #1f2937;
}

.slot-title.placeholder {
    color: #9ca3af;
    font-style: italic;
    font-weight: 400;
}

.slot-description {
    font-size: 0.875rem;
    color: #6b7280;
    margin-top: 0.5rem;
    line-height: 1.4;
}

.slot-empty {
    font-size: 0.875rem;
    color: #9ca3af;
    font-style: italic;
    margin-top: 0.25rem;
}

/* Modal d'√©dition de cr√©neau */
.day-edit-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.day-edit-modal.show {
    opacity: 1;
}

.day-edit-content {
    background-color: white;
    border-radius: 0.5rem;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    transform: translateY(-20px);
    transition: transform 0.3s ease;
}

.day-edit-modal.show .day-edit-content {
    transform: translateY(0);
}

.day-edit-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem;
    border-bottom: 1px solid #e5e7eb;
}

.day-edit-header h4 {
    margin: 0;
    font-size: 1.25rem;
    color: #1f2937;
}

.day-edit-close {
    background: none;
    border: none;
    color: #6b7280;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
}

.day-edit-close:hover {
    background-color: #f3f4f6;
    color: #1f2937;
}

.day-edit-body {
    padding: 1.5rem;
}

.day-edit-footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
    padding: 1.5rem;
    border-top: 1px solid #e5e7eb;
    background-color: #f9fafb;
}

/* Styles pour les p√©riodes fusionn√©es */
.time-slot.merged-period {
    background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
    border-left: 4px solid #3b82f6;
}

.time-slot.merged-period .period-number {
    font-weight: 600;
    color: #1e40af;
}

.merged-indicator {
    font-size: 0.75rem;
    color: #3b82f6;
    font-weight: 500;
    margin-top: 2px;
}

.schedule-cell.merged-period {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
    position: relative;
}

.schedule-cell.merged-period::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: #3b82f6;
}

/* Styles pour les slots fusionn√©s dans le modal */
.day-schedule-slot.merged-slot {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
    border-left-width: 6px;
    position: relative;
}

.day-schedule-slot.merged-slot .slot-period {
    color: #1e40af;
    font-weight: 700;
}

.day-schedule-slot.merged-slot::after {
    content: 'Fusionn√©';
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 0.65rem;
    color: #3b82f6;
    background: rgba(59, 130, 246, 0.1);
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: 500;
}


/* Styles pour les class-block fusionn√©s dans la vue hebdomadaire */
.class-block.merged-block {
    /* Position absolue pour s'√©tendre au-del√† de la cellule courante */
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    /* La hauteur sera calcul√©e dynamiquement par JavaScript */
    /* height sera d√©finie via style inline par le JS */
    /* S'assurer que le bloc appara√Æt au-dessus de la cellule suivante */
    z-index: 5;
    /* Indicateur visuel subtil de fusion avec bordure un peu plus marqu√©e */
    border-left: 4px solid rgba(59, 130, 246, 0.7);
    /* Ombre plus marqu√©e pour se distinguer */
    box-shadow: 0 2px 6px rgba(59, 130, 246, 0.15);
    /* S'assurer que le bloc ne d√©borde pas */
    box-sizing: border-box;
    /* Limiter le d√©bordement */
    overflow: hidden;
}

/* Style pour les cellules qui sont la continuation d'une p√©riode fusionn√©e */
.schedule-cell.merged-continuation {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(59, 130, 246, 0.02) 100%);
    position: relative;
}

.schedule-cell.merged-continuation::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-left: 3px solid rgba(59, 130, 246, 0.4);
    pointer-events: none;
}
</style>
{% endblock %}

{% block content %}
<div class="calendar-container">
    <!-- En-t√™te avec navigation -->
    <div class="calendar-header">
        <div class="calendar-nav">
            <button class="nav-btn" onclick="navigateWeek('prev')">
                <i class="fas fa-chevron-left"></i>
            </button>

            <h2 class="current-week-title">
                Semaine du {{ week_dates[0] | format_date_full }} au {{ week_dates[4] | format_date }}
            </h2>

            <button class="nav-btn" onclick="navigateWeek('next')">
                <i class="fas fa-chevron-right"></i>
            </button>

            <button class="btn btn-primary btn-today" onclick="navigateToToday()">
                <i class="fas fa-calendar-day"></i> Aujourd'hui
            </button>

            <button class="btn btn-outline btn-toggle-view" onclick="toggleViewMode()" title="Basculer la vue">
                <i class="fas fa-expand-alt" id="toggleIcon"></i>
                <span id="toggleText">Vue √©tendue</span>
            </button>
        </div>
    </div>

    <!-- Conteneur principal avec deux colonnes -->
    <div class="calendar-main">
        <!-- Vue hebdomadaire -->
        <div class="weekly-view">
            <div class="weekly-view-loading">
                <i class="fas fa-spinner fa-spin fa-2x"></i>
            </div>
            <h3 class="section-title">
                <i class="fas fa-calendar-week"></i> Vue hebdomadaire
            </h3>

            <div class="weekly-schedule">
                <table class="schedule-table">
                    <thead>
                        <tr>
                            <th class="time-column">Heure</th>
                            {% for date in week_dates %}
                            <th class="day-header {% if date == today %}today{% endif %}">
                                <div class="day-name">{{ days[loop.index0] }}</div>
                                <div class="day-date">{{ date.strftime('%d/%m') }}</div>
                            </th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody>
                        {% for period in periods %}
                        {% set period_num = period.number %}
                        
                        {# V√©rifier si cette p√©riode doit √™tre skipp√©e car fusionn√©e avec la pr√©c√©dente #}
                        {% set should_skip = false %}
                        {% for day_idx in range(5) %}
                            {% if not should_skip and merged_info.get(day_idx, {}).get(period_num, {}).get('merged_with_previous', false) %}
                                {% set should_skip = true %}
                            {% endif %}
                        {% endfor %}
                        
                        {% if not should_skip %}
                        <tr>
                            <td class="time-slot">
                                <div class="period-number">P{{ period_num }}</div>
                                <div class="period-time">
                                    {{ period.start.strftime('%H:%M') }}<br>
                                    {{ period.end.strftime('%H:%M') }}
                                </div>
                            </td>
                            {% for date in week_dates %}
                            {% set i = loop.index0 %}
                            {% set planning_key = date.strftime('%Y-%m-%d') + '_' + period_num|string %}
                            {% set schedule_key = i|string + '_' + period_num|string %}
                            
                            {# V√©rifier si cette p√©riode est fusionn√©e pour ce jour sp√©cifique #}
                            {% set day_merged_info = merged_info.get(i, {}).get(period_num, {}) %}
                            {% set is_merged_for_day = day_merged_info.get('has_merged_next', false) %}
                            {% set is_merged_with_previous = day_merged_info.get('merged_with_previous', false) %}
                            
                            <td class="schedule-cell {% if date == today %}today{% endif %}{% if is_merged_for_day %} merged-period{% endif %}{% if is_merged_with_previous %} merged-continuation{% endif %}"
                                data-date="{{ date.strftime('%Y-%m-%d') }}"
                                data-period="{% if is_merged_for_day %}{{ period_num }}-{{ period_num + 1 }}{% else %}{{ period_num }}{% endif %}"
                                {% if schedule_key in schedule_grid %}
                                    {% set schedule = schedule_grid[schedule_key] %}
                                    {% if schedule.classroom_id %}
                                        data-default-classroom="{{ schedule.classroom_id }}"
                                    {% elif schedule.mixed_group_id %}
                                        data-default-mixed-group="{{ schedule.mixed_group_id }}"
                                    {% elif schedule.custom_task_title %}
                                        data-default-custom-task="true"
                                    {% endif %}
                                {% endif %}
                                data-debug-schedule-key="{{ schedule_key }}"
                                data-debug-has-schedule="{{ schedule_key in schedule_grid }}"
                                onclick="openPlanningModal(this)">
                                {% set holiday_info = holidays_info[date.strftime('%Y-%m-%d')] %}

                                {# Si cette p√©riode est fusionn√©e avec la pr√©c√©dente, ne rien afficher #}
                                {% if is_merged_with_previous %}
                                    <!-- Cellule fusionn√©e - contenu affich√© dans la p√©riode pr√©c√©dente -->
                                {% elif holiday_info.is_holiday %}
                                    <!-- Jour f√©ri√© -->
                                    <div class="holiday-block">
                                        <div class="holiday-day-name">{{ holiday_info.name }}</div>
                                    </div>
                                {% elif date >= current_user.school_year_start and date <= current_user.school_year_end %}
                                    {% if planning_key in planning_grid %}
                                        <!-- Planification sp√©cifique -->
                                        {% set planning = planning_grid[planning_key] %}
                                        {% if planning.classroom_id %}
                                        <div class="class-block planned {% if is_merged_for_day %}merged-block{% endif %}" style="background-color: {{ planning.classroom.color }};">
                                            <div class="class-name">{{ planning.classroom.name }}</div>
                                            <div class="class-subject">{{ planning.classroom.subject }}</div>
                                        {% elif planning.mixed_group_id %}
                                        <div class="class-block planned {% if is_merged_for_day %}merged-block{% endif %}" style="background-color: {{ planning.mixed_group.color }};">
                                            <div class="class-name"><i class="fas fa-users"></i> {{ planning.mixed_group.name }}</div>
                                            <div class="class-subject">{{ planning.mixed_group.subject }}</div>
                                        {% elif not planning.classroom_id and not planning.mixed_group_id and planning.title %}
                                        <div class="class-block planned {% if is_merged_for_day %}merged-block{% endif %}" style="background-color: #6B7280;">
                                            <div class="class-name"><i class="fas fa-tasks"></i> T√¢che personnalis√©e</div>
                                            <div class="class-subject">Autre</div>
                                        {% endif %}
                                            {% if planning.title %}
                                            <div class="planning-title">
                                                {{ planning.title }}
                                            </div>
                                            {% endif %}
                                            {% if planning.group %}
                                            <div class="group-name" style="font-size: 0.65rem; color: white; font-style: italic; margin-top: 2px;">
                                                {{ planning.group.name }}
                                            </div>
                                            {% endif %}
                                            {% if planning.checklist_summary %}
                                            <div class="checklist-summary">
                                                {% if planning.checklist_summary.all_checked %}
                                                    <i class="fas fa-check-circle checklist-icon all-checked"></i>
                                                {% elif planning.checklist_summary.checked > 0 %}
                                                    <i class="fas fa-tasks checklist-icon partial"></i>
                                                {% else %}
                                                    <i class="fas fa-times-circle checklist-icon none-checked"></i>
                                                {% endif %}
                                                <span class="checklist-count">{{ planning.checklist_summary.checked }}/{{ planning.checklist_summary.total }}</span>
                                            </div>
                                            {% endif %}
                                        </div>
                                    {% elif schedule_key in schedule_grid %}
                                        <!-- Horaire type -->
                                        {% set schedule = schedule_grid[schedule_key] %}
                                        {% if schedule.classroom_id %}
                                            <div class="class-block {% if is_merged_for_day %}merged-block{% endif %}" style="background-color: {{ schedule.classroom.color }}; opacity: 0.7;">
                                                <div class="class-name">{{ schedule.classroom.name }}</div>
                                                <div class="class-subject">{{ schedule.classroom.subject }}</div>
                                            </div>
                                        {% elif schedule.mixed_group_id %}
                                            <div class="class-block {% if is_merged_for_day %}merged-block{% endif %}" style="background-color: {{ schedule.mixed_group.color }}; opacity: 0.7;">
                                                <div class="class-name"><i class="fas fa-users"></i> {{ schedule.mixed_group.name }}</div>
                                                <div class="class-subject">{{ schedule.mixed_group.subject }}</div>
                                            </div>
                                        {% elif schedule.custom_task_title %}
                                            <div class="class-block {% if is_merged_for_day %}merged-block{% endif %}" style="background-color: #6B7280; opacity: 0.7;">
                                                <div class="class-name"><i class="fas fa-tasks"></i> {{ schedule.custom_task_title }}</div>
                                                <div class="class-subject">Autre</div>
                                            </div>
                                        {% endif %}
                                    {% endif %}
                                {% endif %}
                            </td>
                            {% endfor %}
                        </tr>
                        {% endif %}
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Vue annuelle par classe -->
        <div class="annual-view">
            <h3 class="section-title">
                <i class="fas fa-calendar-alt"></i> Vue annuelle
            </h3>

            <!-- Onglets des classes et groupes mixtes -->
            <div class="class-tabs">
                {% for item in classrooms_json %}
                {% set item_key = item.type + '_' + item.id|string %}
                <button class="tab-btn {% if item_key == selected_classroom_id %}active{% endif %}"
                        data-classroom-id="{{ item_key|e }}"
                        style="border-bottom-color: {{ item.color }};"
                        onclick="switchClassroomTab('{{ item_key|e }}', this)">
                    {% if item.type == 'mixed_group' %}
                        <i class="fas fa-users" style="margin-right: 0.25rem;"></i>
                    {% endif %}
                    <div class="tab-content">
                        <div class="tab-name">{{ item.name|e }}</div>
                        <div class="tab-subject">{{ item.subject|e }}</div>
                    </div>
                </button>
                {% endfor %}
            </div>

            <!-- Calendrier annuel -->
            <div class="annual-calendar">
                {% if selected_classroom_id and selected_classroom_id in annual_data %}
                    {% if selected_classroom_id.startswith('mixed_group_') %}
                        {% set item_id = selected_classroom_id.split('_')[2]|int %}
                        {% set selected_item = classrooms_json | selectattr('type', 'equalto', 'mixed_group') | selectattr('id', 'equalto', item_id) | first %}
                    {% else %}
                        {% set item_id = selected_classroom_id.split('_')[1]|int %}
                        {% set selected_item = classrooms_json | selectattr('type', 'equalto', 'classroom') | selectattr('id', 'equalto', item_id) | first %}
                    {% endif %}
                    <div class="annual-grid" data-classroom-color="{{ selected_item.color if selected_item else '#4F46E5' }}">
                        {% for week in annual_data[selected_classroom_id] %}
                        <div class="annual-week {% if week.start_date <= today and today <= week.dates[4] %}current-week{% endif %} {% if week.is_holiday %}holiday-week{% endif %}">
                            <div class="week-info">
                                <div class="week-date">{{ week.formatted_date }}</div>
                                <div class="week-number" {% if not week.is_holiday %}onclick="navigateToWeek('{{ week.start_date.strftime('%Y-%m-%d') }}')" title="Cliquez pour voir cette semaine"{% endif %}>
                                    {% if week.is_holiday %}
                                        <span class="holiday-label" title="{{ week.holiday_name }}">
                                            {% if week.holiday_name_short %}
                                                {{ week.holiday_name_short }}
                                            {% else %}
                                                {% set holiday_parts = week.holiday_name.split(' ') %}
                                                {% if holiday_parts|length > 1 and week.holiday_name|length > 12 %}
                                                    {{ holiday_parts[0] }}<br>{{ holiday_parts[1:] | join(' ') }}
                                                {% else %}
                                                    {{ week.holiday_name }}
                                                {% endif %}
                                            {% endif %}
                                        </span>
                                    {% else %}
                                        <span class="week-number-link">S{{ week.week_number }}</span>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="week-days">
                                {% for has_class in week.has_class %}
                                {% set i = loop.index0 %}
                                {% set date = week.dates[i] %}
                                {% set date_str = date.strftime('%Y-%m-%d') %}
                                {% set holiday_name = week.holidays_by_day[i] %}
                                <div class="annual-day {% if has_class %}has-class{% endif %} {% if date == today %}today{% endif %} {% if holiday_name %}holiday single-day-holiday{% endif %}"
                                     data-date="{{ date_str }}"
                                     data-weekday="{{ i }}"
                                     data-has-class="{{ 'true' if has_class else 'false' }}"
                                     onclick="{% if has_class and not holiday_name %}handleAnnualDayClick(this, '{{ date_str }}'){% endif %}"
                                     title="{{ days[i] }} {{ date.strftime('%d/%m') }}{% if holiday_name %} - {{ holiday_name }}{% endif %}">
                                    <div class="annual-day-content">
                                        {% if holiday_name %}
                                            <div class="annual-holiday-name">{{ holiday_name[:3] }}</div>
                                        {% elif week.plannings and date_str in week.plannings %}
                                            <div class="annual-plannings">
                                                {% for planning in week.plannings[date_str][:3] %}
                                                    <div class="annual-planning-item" title="{{ planning.title }}">
                                                        {% if planning.checklist_summary %}
                                                        <div class="annual-planning-checklist">
                                                            {% if planning.checklist_summary.all_checked %}
                                                                <i class="fas fa-check-circle annual-checklist-icon all-checked"></i>
                                                            {% elif planning.checklist_summary.checked > 0 %}
                                                                <i class="fas fa-tasks annual-checklist-icon partial"></i>
                                                            {% else %}
                                                                <i class="fas fa-times-circle annual-checklist-icon none-checked"></i>
                                                            {% endif %}
                                                        </div>
                                                        {% endif %}
                                                        <span class="annual-planning-text">{{ planning.title }}</span>
                                                    </div>
                                                {% endfor %}
                                                {% if week.plannings[date_str]|length > 3 %}
                                                    <div class="annual-planning-more">+{{ week.plannings[date_str]|length - 3 }}</div>
                                                {% endif %}
                                            </div>
                                        {% endif %}
                                    </div>
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                {% endif %}
            </div>

            <!-- L√©gende -->
            <div class="annual-legend">
                <div class="legend-item">
                    <div class="legend-box has-class"></div>
                    <span>Jour avec cours</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box"></div>
                    <span>Jour sans cours</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box today"></div>
                    <span>Aujourd'hui</span>
                </div>
                <div class="legend-item">
                    <i class="fas fa-check-circle" style="color: #10B981;"></i>
                    <span>T√¢ches compl√©t√©es</span>
                </div>
                <div class="legend-item">
                    <i class="fas fa-tasks" style="color: #F59E0B;"></i>
                    <span>T√¢ches en cours</span>
                </div>
                <div class="legend-item">
                    <i class="fas fa-times-circle" style="color: #EF4444;"></i>
                    <span>T√¢ches non commenc√©es</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Overlay pour les modals -->
<div class="modal-overlay" id="modalOverlay" style="display: none;"></div>

<!-- Modal de planification -->
<div class="planning-modal" id="planningModal">
    <div class="modal-content" id="planningModalContent">
        <div class="modal-header">
            <h3 id="modalTitle">Planifier le cours</h3>
            <div class="modal-header-actions">
                <button class="btn-icon" onclick="toggleSplitView()" title="Afficher/Masquer les fichiers">
                    <i class="fas fa-folder-open"></i>
                </button>
                <button class="modal-close" onclick="closePlanningModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>

        <div class="modal-body">
            <div class="form-group">
                <label class="form-label">Classe</label>
                <select id="modalClassroom" class="form-control" onchange="loadGroupsForClass(this.value)">
                    <option value="">-- S√©lectionner une classe --</option>
                    {% for item in classrooms_json %}
                    <option value="{{ item.type }}_{{ item.id }}" data-color="{{ item.color }}" data-type="{{ item.type }}">
                        {% if item.type == 'mixed_group' %}üë• {% endif %}{{ item.name }} - {{ item.subject }}
                    </option>
                    {% endfor %}
                    <!-- Option pour les t√¢ches personnalis√©es -->
                    <option value="custom_task" data-color="#6B7280" data-type="custom">
                        üìù Autre
                    </option>
                </select>
            </div>

            <div class="form-group" id="groupSelectionDiv" style="display: none;">
                <label class="form-label">Groupe</label>
                <select id="modalGroup" class="form-control" onchange="toggleGroupRepeatOptions()">
                    <option value="">Classe enti√®re</option>
                </select>
                <small class="form-text text-muted">S√©lectionnez un groupe ou laissez "Classe enti√®re" pour tous les √©l√®ves</small>
                
                <!-- Options de r√©p√©tition des groupes -->
                <div id="groupRepeatOptions" style="display: none; margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 4px;">
                    <label class="form-label" style="font-weight: 600; margin-bottom: 8px; display: block;">Application automatique :</label>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="groupRepeat" value="same" style="margin-right: 8px;">
                            <span>R√©p√©ter le m√™me groupe chaque semaine jusqu'√† la fin de l'ann√©e</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="groupRepeat" value="alternate" style="margin-right: 8px;">
                            <span>Alterner entre tous les groupes de la classe chaque semaine</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="groupRepeat" value="none" checked style="margin-right: 8px;">
                            <span>Appliquer seulement pour cette date</span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Titre du cours</label>
                <input type="text" id="modalPlanningTitle" class="form-control"
                       placeholder="Ex: Introduction aux fractions">
            </div>

            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea id="modalDescription" class="form-control" rows="3"
                          placeholder="D√©tails du cours, exercices pr√©vus..."></textarea>
            </div>
        </div>

        <div class="modal-footer">
            <button class="btn btn-outline" onclick="closePlanningModal()">Annuler</button>
            <button class="btn btn-primary" onclick="savePlanning()">
                <i class="fas fa-save"></i> Enregistrer
            </button>
        </div>
    </div>

    <!-- Panneau gestionnaire de fichiers (cach√© par d√©faut) -->
    <div class="file-manager-panel" id="fileManagerPanel" style="display: none;">
        <div class="file-manager-header">
            <h3><i class="fas fa-folder-open"></i> Fichiers de la classe</h3>
            <button class="btn-icon" onclick="toggleSplitView()" title="Fermer">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="file-manager-content" id="fileManagerContent">
            <!-- Chargement initial -->
            <div class="file-loading" id="fileLoading">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Chargement des fichiers...</p>
            </div>

            <!-- Navigation des dossiers -->
            <div class="file-navigation" id="fileNavigation" style="display: none;">
                <div class="breadcrumb" id="fileBreadcrumb">
                    <span class="breadcrumb-item active" data-path="" onclick="navigateToFileFolder('')">
                        <i class="fas fa-home"></i> Racine
                    </span>
                </div>
            </div>

            <!-- Arborescence des fichiers -->
            <div class="file-tree" id="fileTree" style="display: none;">
                <!-- L'arborescence sera charg√©e ici -->
            </div>

            <!-- √âtat vide -->
            <div class="no-files" id="noFiles" style="display: none;">
                <i class="fas fa-folder-open"></i>
                <p>Aucun fichier dans cette classe</p>
            </div>
        </div>
    </div>

    <!-- Conteneur pour le lecteur PDF unifi√© en mode split -->
    <div id="pdf-viewer-container" style="display: none; z-index: 11000; position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: #F8FAFC;"></div>

</div>

<!-- Modal de planification journali√®re (pour la vue annuelle) -->
<div class="planning-modal" id="dayPlanningModal">
    <div class="modal-content" id="dayModalContent">
        <div class="modal-header">
            <h3 id="dayModalTitle">Planification de la journ√©e</h3>
            <div class="modal-header-actions">
                <button class="btn-icon" onclick="toggleDaySplitView()" title="Afficher/Masquer les fichiers">
                    <i class="fas fa-folder-open"></i>
                </button>
                <button class="modal-close" onclick="closeDayPlanningModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>

        <div class="modal-body">
            <div class="form-group">
                <label class="form-label">Classe s√©lectionn√©e</label>
                <select id="dayModalClassroom" class="form-control" disabled>
                    <option value="">-- Classe pr√©d√©finie --</option>
                    {% for item in classrooms_json %}
                    <option value="{{ item.type }}_{{ item.id }}" data-color="{{ item.color }}" data-type="{{ item.type }}">
                        {% if item.type == 'mixed_group' %}üë• {% endif %}{{ item.name }} - {{ item.subject }}
                    </option>
                    {% endfor %}
                </select>
            </div>

            <div id="dayPlanningsContainer">
                <!-- Les cr√©neaux de la journ√©e seront charg√©s ici -->
            </div>
        </div>

        <div class="modal-footer">
            <button class="btn btn-outline" onclick="closeDayPlanningModal()">Fermer</button>
        </div>
    </div>

    <!-- Panneau gestionnaire de fichiers pour la vue journali√®re -->
    <div class="file-manager-panel" id="dayFileManagerPanel" style="display: none;">
        <div class="file-manager-header">
            <h3><i class="fas fa-folder-open"></i> Fichiers de la classe</h3>
            <button class="btn-icon" onclick="toggleDaySplitView()" title="Fermer">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="file-manager-content" id="dayFileManagerContent">
            <!-- Chargement initial -->
            <div class="file-loading" id="dayFileLoading">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Chargement des fichiers...</p>
            </div>

            <!-- Navigation des dossiers -->
            <div class="file-navigation" id="dayFileNavigation" style="display: none;">
                <div class="breadcrumb" id="dayFileBreadcrumb">
                    <span class="breadcrumb-item active" data-path="" onclick="navigateToDayFileFolder('')">
                        <i class="fas fa-home"></i> Racine
                    </span>
                </div>
            </div>

            <!-- Arborescence des fichiers -->
            <div class="file-tree" id="dayFileTree" style="display: none;">
                <!-- L'arborescence sera charg√©e ici -->
            </div>

            <!-- √âtat vide -->
            <div class="no-files" id="dayNoFiles" style="display: none;">
                <i class="fas fa-folder-open"></i>
                <p>Aucun fichier dans cette classe</p>
            </div>
        </div>
    </div>


</div>

<form id="weekNavigationForm" method="GET" style="display: none;">
    <input type="hidden" name="week" id="weekInput">
    <input type="hidden" name="classroom" value="{{ selected_classroom_id }}">
</form>

{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/planning.js') }}"></script>
<script src="{{ url_for('static', filename='js/unified-pdf-viewer.js') }}?v=NATIVE20250923&cache_bust={{ range(1000000, 9999999) | random }}&native=true&nopf=true&simple=drawing"></script>
<script>
const currentWeek = '{{ current_week.strftime("%Y-%m-%d") }}';
const selectedClassroomId = {{ selected_classroom_id|tojson if selected_classroom_id else 'null' }};
const periodsData = {{ periods_json | tojson }};
const classrooms = {{ classrooms_json | tojson }};
const scheduleGrid = {{ schedule_grid_json | tojson }};
const mergedInfo = {{ merged_info | tojson }};
let currentPlanningCell = null;
let isExtendedView = false;

// Variables globales pour les mises √† jour dynamiques
window.selectedClassroomId = selectedClassroomId;
window.classroomsData = classrooms;

// G√©rer le clic sur une case de la vue annuelle
function handleAnnualDayClick(element, dateStr) {
    if (element.dataset.hasClass !== 'true' || element.classList.contains('single-day-holiday')) return;

    // R√©cup√©rer l'ID de la classe actuellement s√©lectionn√©e dans la vue annuelle
    const classroomId = selectedClassroomId;

    // Ouvrir le modal de planification journali√®re avec filtrage par classe
    openDayPlanningModal(dateStr, classroomId);
}

function navigateToWeek(weekStartDate) {
    // Ajouter un effet visuel de chargement sur la vue hebdomadaire uniquement
    const weeklyView = document.querySelector('.weekly-view');
    weeklyView.classList.add('loading');

    // Utiliser le formulaire existant avec la date de d√©but de semaine
    document.getElementById('weekInput').value = weekStartDate;

    // Soumettre le formulaire
    document.getElementById('weekNavigationForm').submit();
}

function navigateWeek(direction) {
    // Ajouter un effet de chargement sur la vue hebdomadaire
    const weeklyView = document.querySelector('.weekly-view');
    weeklyView.classList.add('loading');

    const currentDate = new Date('{{ current_week }}');
    if (direction === 'prev') {
        currentDate.setDate(currentDate.getDate() - 7);
    } else {
        currentDate.setDate(currentDate.getDate() + 7);
    }

    document.getElementById('weekInput').value = formatDate(currentDate);
    document.getElementById('weekNavigationForm').submit();
}

function navigateToToday() {
    // Ajouter un effet de chargement sur la vue hebdomadaire
    const weeklyView = document.querySelector('.weekly-view');
    weeklyView.classList.add('loading');

    const today = new Date();
    document.getElementById('weekInput').value = formatDate(today);
    document.getElementById('weekNavigationForm').submit();
}

function selectClassroom(classroomId) {
    const url = new URL(window.location);
    url.searchParams.set('classroom', classroomId);
    window.location = url;
}

function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Basculer entre vue normale et vue √©tendue
function toggleViewMode() {
    const calendarMain = document.querySelector('.calendar-main');
    const toggleIcon = document.getElementById('toggleIcon');
    const toggleText = document.getElementById('toggleText');

    isExtendedView = !isExtendedView;

    if (isExtendedView) {
        calendarMain.classList.add('extended-view');
        toggleIcon.className = 'fas fa-compress-alt';
        toggleText.textContent = 'Vue normale';
    } else {
        calendarMain.classList.remove('extended-view');
        toggleIcon.className = 'fas fa-expand-alt';
        toggleText.textContent = 'Vue √©tendue';
    }

    // Sauvegarder la pr√©f√©rence
    localStorage.setItem('calendarViewMode', isExtendedView ? 'extended' : 'normal');
}

// Appliquer la couleur de la classe s√©lectionn√©e
function applyClassroomColor() {
    console.log('üé® applyClassroomColor called with selectedClassroomId:', selectedClassroomId);
    
    // Debug: afficher les donn√©es annuelles pour la classe s√©lectionn√©e
    const annualDataForClass = {{ annual_data | tojson }}[selectedClassroomId];
    console.log('üìä Annual data for selected class:', annualDataForClass);
    
    // Debug: chercher la semaine qui contient 2025-06-18
    if (annualDataForClass) {
        const targetDate = '2025-06-18';
        console.log('üîç Looking for week containing:', targetDate);
        
        // Debug: afficher les dates de quelques semaines
        annualDataForClass.slice(0, 3).forEach((week, index) => {
            console.log(`üìÖ Week ${index} dates:`, week.dates);
            console.log(`üìÖ Week ${index} has_class:`, week.has_class);
        });
        
        const targetWeek = annualDataForClass.find(week => 
            week.dates && week.dates.some(date => date === targetDate)
        );
        if (targetWeek) {
            console.log('üîç Week containing 2025-06-18:', targetWeek);
            console.log('üìÖ has_class array:', targetWeek.has_class);
            console.log('üìù plannings:', targetWeek.plannings);
        } else {
            console.log('‚ùå No week found containing 2025-06-18');
            
            // Debug: chercher avec diff√©rents formats de date
            const targetWeekAlt = annualDataForClass.find(week => 
                week.dates && week.dates.some(date => {
                    // Essayer de convertir la date si c'est un objet
                    const dateStr = typeof date === 'string' ? date : (date.toString ? date.toString() : JSON.stringify(date));
                    return dateStr.includes('2025-06-18') || dateStr.includes('18');
                })
            );
            if (targetWeekAlt) {
                console.log('üîç Found week with alternative search:', targetWeekAlt);
            }
        }
    }
    
    if (!selectedClassroomId) {
        console.log('‚ùå No selectedClassroomId');
        return;
    }
    
    // Parser l'ID pour extraire le type et l'ID
    let type, numericId;
    if (selectedClassroomId.startsWith('mixed_group_')) {
        type = 'mixed_group';
        numericId = parseInt(selectedClassroomId.split('_')[2]);
    } else if (selectedClassroomId.startsWith('classroom_')) {
        type = 'classroom';
        numericId = parseInt(selectedClassroomId.split('_')[1]);
    } else {
        // Format ancien (ID num√©rique direct)
        type = 'classroom';
        numericId = parseInt(selectedClassroomId);
    }
    
    const selectedItem = {{ classrooms_json | tojson }}.find(c => 
        c.id === numericId && c.type === type
    );
    
    console.log('üè´ Found selectedItem:', selectedItem);
    
    if (selectedItem && selectedItem.color) {
        console.log('üé® Applying color:', selectedItem.color);
        const annualGrid = document.querySelector('.annual-grid');
        if (annualGrid) {
            // Appliquer la couleur comme variable CSS
            annualGrid.style.setProperty('--classroom-color', selectedItem.color);
            console.log('‚úÖ Color applied to annual grid');
        } else {
            console.log('‚ùå Annual grid not found');
        }
    } else {
        console.log('‚ùå No selectedItem or color');
    }
}

// Changer d'onglet de classe dans la vue annuelle
function switchClassroomTab(classroomId, buttonElement) {
    console.log('üîÑ Switching to classroom:', classroomId);
    
    // Mettre √† jour l'URL pour recharger avec la nouvelle classe
    const currentUrl = new URL(window.location);
    currentUrl.searchParams.set('classroom', classroomId);
    
    // Recharger la page avec la nouvelle classe s√©lectionn√©e
    window.location.href = currentUrl.toString();
}

// Calculer dynamiquement les hauteurs des blocs fusionn√©s
function calculateMergedBlockHeights() {
    console.log('üîß Calculating merged block heights...');
    
    // Attendre un peu que le DOM soit compl√®tement rendu
    setTimeout(() => {
        const mergedBlocks = document.querySelectorAll('.class-block.merged-block');
        console.log('Found', mergedBlocks.length, 'merged blocks to adjust');
        
        mergedBlocks.forEach(block => {
            try {
                // Trouver la cellule parente
                const parentCell = block.closest('.schedule-cell.merged-period');
                if (!parentCell) {
                    console.warn('No parent cell found for merged block');
                    return;
                }
                
                // Trouver la ligne de tableau de la cellule parente
                const parentRow = parentCell.closest('tr');
                if (!parentRow) {
                    console.warn('No parent row found');
                    return;
                }
                
                // Trouver la ligne suivante (celle qui contient la p√©riode fusionn√©e)
                const nextRow = parentRow.nextElementSibling;
                if (!nextRow) {
                    console.warn('No next row found');
                    return;
                }
                
                // Calculer la hauteur totale des deux lignes
                const parentRowHeight = parentRow.getBoundingClientRect().height;
                const nextRowHeight = nextRow.getBoundingClientRect().height;
                const totalHeight = parentRowHeight + nextRowHeight;
                
                console.log(`Setting merged block height: ${totalHeight}px (${parentRowHeight}px + ${nextRowHeight}px)`);
                
                // Appliquer la hauteur calcul√©e
                block.style.height = totalHeight + 'px';
                
            } catch (error) {
                console.error('Error calculating merged block height:', error);
            }
        });
    }, 500); // D√©lai pour laisser le temps au CSS de se charger
}

// Initialiser les donn√©es de planification au chargement
document.addEventListener('DOMContentLoaded', function() {
    loadWeeklyPlannings();
    applyClassroomColor();
    calculateMergedBlockHeights();

    // Restaurer la pr√©f√©rence de vue
    const savedViewMode = localStorage.getItem('calendarViewMode');
    if (savedViewMode === 'extended' && !isExtendedView) {
        toggleViewMode();
    }
    
    // Gestionnaire pour les onglets de classe
    document.querySelectorAll('.tab-btn').forEach(button => {
        button.addEventListener('click', function() {
            const classroomId = this.getAttribute('data-classroom-id');
            if (classroomId) {
                selectClassroom(classroomId);
            }
        });
    });
});


// Ajout des styles CSS inline pour les √©l√©ments de p√©riode pass√©e
const styleSheet = document.createElement('style');
styleSheet.textContent = `
    .past-period-description {
        background-color: #F9FAFB;
        border: 1px solid #E5E7EB;
        border-radius: 0.375rem;
        padding: 1rem;
        min-height: 60px;
        line-height: 1.5;
    }

    .checklist-item {
        display: flex;
        align-items: center;
        margin: 0.5rem 0;
        padding: 0.25rem 0;
    }

    .checklist-item.completed {
        color: #10B981;
    }

    .checklist-item.completed span {
        text-decoration: line-through;
    }

    .checklist-item.not-completed {
        color: #EF4444;
    }

    .checklist-item i {
        margin-right: 0.5rem;
        font-size: 1rem;
    }

    .modal-body .form-control:disabled {
        background-color: #F3F4F6;
        cursor: not-allowed;
    }

    .checklist-help {
        font-size: 0.75rem;
        color: var(--gray-color);
        margin-top: 0.5rem;
        font-style: italic;
    }
`;
document.head.appendChild(styleSheet);

// S'assurer que la notification est disponible
if (typeof showNotification === 'undefined') {
    window.showNotification = function(type, message) {
        // Cr√©er le conteneur de notifications s'il n'existe pas
        let container = document.querySelector('.notifications-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'notifications-container';
            container.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 1000;';
            document.body.appendChild(container);
        }

        // Cr√©er la notification
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.style.cssText = `
            background-color: ${type === 'success' ? '#D1FAE5' : '#FEE2E2'};
            color: ${type === 'success' ? '#065F46' : '#991B1B'};
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideInNotification 0.3s ease;
            max-width: 400px;
        `;

        const icon = document.createElement('i');
        icon.className = `fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}`;

        const text = document.createElement('span');
        text.textContent = message;

        notification.appendChild(icon);
        notification.appendChild(text);
        container.appendChild(notification);

        // Supprimer la notification apr√®s 5 secondes
        setTimeout(() => {
            notification.style.animation = 'slideOutNotification 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }, 5000);
    };
}

// Variables pour le gestionnaire de fichiers
let currentFilePath = '';
let isSplitViewOpen = false;


// Basculer l'affichage du gestionnaire de fichiers
function toggleSplitView() {
    const modal = document.getElementById('planningModal');
    const fileManagerPanel = document.getElementById('fileManagerPanel');
    
    isSplitViewOpen = !isSplitViewOpen;
    
    if (isSplitViewOpen) {
        modal.classList.add('split-view');
        fileManagerPanel.style.display = 'flex';
        
        // Charger les fichiers de la classe s√©lectionn√©e
        const classroomId = document.getElementById('modalClassroom').value;
        if (classroomId) {
            loadClassFiles(classroomId);
        } else {
            // Si aucune classe n'est s√©lectionn√©e, afficher un message
            document.getElementById('fileLoading').style.display = 'none';
            document.getElementById('fileNavigation').style.display = 'none';
            document.getElementById('fileTree').style.display = 'none';
            document.getElementById('noFiles').style.display = 'block';
            document.getElementById('noFiles').innerHTML = `
                <i class="fas fa-exclamation-circle"></i>
                <p>Veuillez s√©lectionner une classe</p>
            `;
        }
    } else {
        modal.classList.remove('split-view');
        fileManagerPanel.style.display = 'none';
    }
}

// Charger les fichiers d'une classe
async function loadClassFiles(classroomId) {
    const fileLoading = document.getElementById('fileLoading');
    const fileNavigation = document.getElementById('fileNavigation');
    const fileTree = document.getElementById('fileTree');
    const noFiles = document.getElementById('noFiles');
    
    console.log('Chargement des fichiers pour la classe:', classroomId);
    
    // Extraire l'ID num√©rique si la valeur contient un pr√©fixe (ex: "classroom_21" -> "21")
    const numericId = classroomId.toString().includes('_') ? classroomId.split('_')[1] : classroomId;
    
    // Afficher le chargement
    fileLoading.style.display = 'block';
    fileNavigation.style.display = 'none';
    fileTree.style.display = 'none';
    noFiles.style.display = 'none';
    
    try {
        const response = await fetch(`/planning/get-class-resources/${numericId}`);
        console.log('R√©ponse API:', response);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Donn√©es re√ßues:', data);
        
        fileLoading.style.display = 'none';
        
        if (data.success && data.files && data.files.length > 0) {
            // Stocker tous les fichiers globalement
            allClassFiles = data.files;
            fileNavigation.style.display = 'block';
            fileTree.style.display = 'block';
            renderFileTree(data.files, currentFilePath);
        } else {
            console.log('Aucun fichier trouv√© ou erreur dans la r√©ponse');
            noFiles.style.display = 'block';
        }
    } catch (error) {
        console.error('Erreur lors du chargement des fichiers:', error);
        fileLoading.style.display = 'none';
        noFiles.style.display = 'block';
    }
}

// Afficher l'arborescence des fichiers
function renderFileTree(files, currentPath = '') {
    const fileTree = document.getElementById('fileTree');
    fileTree.innerHTML = '';
    
    // Organiser les fichiers par dossier
    const folders = {};
    const currentLevelFiles = [];
    const allFolders = new Set();
    
    files.forEach(file => {
        if (file.folder_path) {
            // Extraire tous les dossiers du chemin
            const pathParts = file.folder_path.split('/').filter(p => p);
            let accumulatedPath = '';
            
            pathParts.forEach((part, index) => {
                const parentPath = accumulatedPath;
                accumulatedPath = accumulatedPath ? `${accumulatedPath}/${part}` : part;
                
                allFolders.add(accumulatedPath);
                
                if (!folders[accumulatedPath]) {
                    folders[accumulatedPath] = {
                        name: part,
                        path: accumulatedPath,
                        parent: parentPath,
                        files: [],
                        subfolders: new Set()
                    };
                }
                
                // Ajouter le sous-dossier au parent
                if (parentPath && folders[parentPath]) {
                    folders[parentPath].subfolders.add(accumulatedPath);
                }
                
                // Ajouter le fichier au dernier dossier
                if (index === pathParts.length - 1) {
                    folders[accumulatedPath].files.push(file);
                }
            });
            
            // Si on navigue dans un dossier sp√©cifique
            if (currentPath && file.folder_path.startsWith(currentPath)) {
                const relativePath = file.folder_path.substring(currentPath.length).replace(/^\//, '');
                const relativePathParts = relativePath.split('/').filter(p => p);
                
                // Si le fichier est directement dans le dossier courant
                if (relativePathParts.length === 0 || (relativePathParts.length === 1 && relativePathParts[0] === '')) {
                    currentLevelFiles.push(file);
                }
            }
        } else if (!currentPath) {
            // Fichiers √† la racine seulement si on est √† la racine
            currentLevelFiles.push(file);
        }
    });
    
    // Si on navigue dans un dossier, ajouter un bouton retour
    if (currentPath) {
        const backItem = document.createElement('div');
        backItem.className = 'file-item';
        backItem.innerHTML = `
            <i class="fas fa-arrow-left file-icon"></i>
            <span class="file-name">..</span>
        `;
        backItem.onclick = () => {
            const parentPath = currentPath.includes('/') ? 
                currentPath.substring(0, currentPath.lastIndexOf('/')) : '';
            navigateToFolder(parentPath);
        };
        fileTree.appendChild(backItem);
    }
    
    // Afficher les dossiers du niveau actuel
    Object.values(folders).forEach(folder => {
        const shouldShow = currentPath ? 
            folder.parent === currentPath : 
            !folder.parent;
        
        if (shouldShow) {
            const folderItem = document.createElement('div');
            folderItem.className = 'file-item folder';
            folderItem.innerHTML = `
                <i class="fas fa-folder file-icon"></i>
                <span class="file-name">${folder.name}</span>
            `;
            folderItem.onclick = () => navigateToFolder(folder.path);
            fileTree.appendChild(folderItem);
        }
    });
    
    // Afficher les fichiers du niveau actuel
    currentLevelFiles.forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        
        const icon = getFileIconByType(file.file_type);
        
        fileItem.innerHTML = `
            <i class="${icon} file-icon"></i>
            <span class="file-name">${file.original_filename}</span>
        `;
        
        if (file.file_type === 'pdf') {
            fileItem.onclick = () => openPdfInViewer(file.id, file.original_filename);
        }
        
        fileTree.appendChild(fileItem);
    });
    
    // Mettre √† jour le fil d'Ariane
    updateBreadcrumb(currentPath);
}

// Variable globale pour stocker tous les fichiers
let allClassFiles = [];

// Obtenir l'ic√¥ne appropri√©e pour un type de fichier
function getFileIconByType(fileType) {
    switch (fileType) {
        case 'pdf':
            return 'fas fa-file-pdf';
        case 'jpg':
        case 'jpeg':
        case 'png':
        case 'gif':
            return 'fas fa-file-image';
        default:
            return 'fas fa-file';
    }
}

// Naviguer dans un dossier
function navigateToFolder(folderPath) {
    currentFilePath = folderPath;
    console.log('Navigation vers le dossier:', folderPath);
    
    // Re-render l'arbre avec le nouveau chemin
    renderFileTree(allClassFiles, folderPath);
}

// Mettre √† jour le fil d'Ariane
function updateBreadcrumb(path) {
    const breadcrumb = document.getElementById('fileBreadcrumb');
    breadcrumb.innerHTML = '';
    
    // Racine
    const rootItem = document.createElement('span');
    rootItem.className = 'breadcrumb-item';
    rootItem.innerHTML = '<i class="fas fa-home"></i> Racine';
    rootItem.onclick = () => navigateToFolder('');
    breadcrumb.appendChild(rootItem);
    
    // Ajouter les parties du chemin
    if (path) {
        const parts = path.split('/').filter(p => p);
        let accumulatedPath = '';
        
        parts.forEach((part, index) => {
            // Ajouter le s√©parateur
            const separator = document.createElement('i');
            separator.className = 'fas fa-chevron-right';
            separator.style.cssText = 'margin: 0 0.5rem; font-size: 0.75rem; color: #9ca3af;';
            breadcrumb.appendChild(separator);
            
            // Construire le chemin accumul√©
            accumulatedPath = accumulatedPath ? `${accumulatedPath}/${part}` : part;
            
            // Cr√©er l'√©l√©ment du fil d'Ariane
            const partItem = document.createElement('span');
            partItem.className = index === parts.length - 1 ? 'breadcrumb-item active' : 'breadcrumb-item';
            partItem.textContent = part;
            
            if (index < parts.length - 1) {
                const pathToNavigate = accumulatedPath;
                partItem.onclick = () => navigateToFolder(pathToNavigate);
            }
            
            breadcrumb.appendChild(partItem);
        });
    }
}


// Variables pour le lecteur PDF (copi√©es de lesson_view.html)
let currentFileId = null;
let currentPageNum = 1;
let currentScale = 1.0;
let pdfDocument = null;
let annotations = [];
let isDrawing = false;
let lastPoint = null;
let currentTool = 'pen';
let currentColor = '#000000';
let currentLineWidth = 3;
let annotationCanvas = null;
let annotationCtx = null;
let pdfCanvas = null;
let pdfCtx = null;

// Ouvrir un PDF avec le lecteur unifi√© en mode split
async function openPdfInViewer(fileId, fileName) {
    console.log('üìÑ Ouverture du PDF avec lecteur unifi√© en mode split:', fileName);
    console.log('üìç FileId:', fileId, 'FileName:', fileName);
    
    try {
        // Utiliser la m√™me approche que openDayPdfInViewer
        let container = document.getElementById('pdf-viewer-container-main');
        if (container) {
            document.body.removeChild(container);
        }
        
        container = document.createElement('div');
        container.id = 'pdf-viewer-container-main';
        container.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            right: 0 !important;
            width: 50vw !important;
            height: 100vh !important;
            z-index: 15000 !important;
            background: #F8FAFC !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1) !important;
        `;
        
        document.body.appendChild(container);
        console.log('‚úÖ Nouveau conteneur principal cr√©√© dans le body');
        
        // V√©rifier les dimensions apr√®s ajout au body
        console.log('üîç Debug nouveau conteneur principal:', {
            width: container.offsetWidth,
            height: container.offsetHeight,
            visible: container.offsetParent !== null
        });
        
        // D√©terminer quelle classe utiliser pour l'envoi de fichiers
        let currentClassId = selectedClassroomId;
        
        // R√©cup√©rer les √©tudiants de la classe actuelle
        const studentsData = await getStudentsForClass(currentClassId);
        
        // Configuration pour le mode split sans suivi d'√©l√®ves
        const options = {
            mode: 'split',
            enableStudentTracking: false, // D√©sactiver le bouton de suivi d'√©l√®ves
            enableSendToStudents: true,   // Activer l'envoi aux √©l√®ves
            currentClassId: currentClassId,
            studentData: studentsData,
            autoSave: true,
            saveDelay: 3000,
            apiEndpoints: {
                saveAnnotations: '/file_manager/api/save-annotations',
                loadAnnotations: '/file_manager/api/load-annotations',
                search: '/api/search-pdf'
            }
        };
        
        // D√©truire l'instance pr√©c√©dente si elle existe
        if (window.currentPdfViewer) {
            window.currentPdfViewer.destroy();
        }
        
        // Cr√©er la nouvelle instance avec le nouveau conteneur
        window.currentPdfViewer = new UnifiedPDFViewer('pdf-viewer-container-main', options);
        
        // Attendre que le DOM se mette √† jour
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Forcer les dimensions des conteneurs internes
        const pdfViewerArea = container.querySelector('.pdf-viewer-area');
        const pdfMain = container.querySelector('.pdf-main');
        
        if (pdfViewerArea) {
            pdfViewerArea.style.width = '100%';
            pdfViewerArea.style.height = '100%';
            pdfViewerArea.style.display = 'flex';
            console.log('üîß Dimensions forc√©es pour pdf-viewer-area principal:', {
                width: pdfViewerArea.offsetWidth,
                height: pdfViewerArea.offsetHeight
            });
        }
        if (pdfMain) {
            pdfMain.style.width = '100%';
            pdfMain.style.height = '100%';
            pdfMain.style.display = 'flex';
            console.log('üîß Dimensions forc√©es pour pdf-main principal:', {
                width: pdfMain.offsetWidth,
                height: pdfMain.offsetHeight
            });
        }
        
        // Charger le PDF avec fileId pour la sauvegarde
        const pdfUrl = `/file_manager/serve_file/${fileId}`;
        console.log('üìé URL du PDF:', pdfUrl);
        await window.currentPdfViewer.loadPDF(pdfUrl, fileId);
        
        // Forcer le recalcul des dimensions apr√®s le chargement
        setTimeout(() => {
            if (window.currentPdfViewer && window.currentPdfViewer.handleToolbarResize) {
                console.log('üîß Recalcul forc√© des dimensions de la toolbar principal');
                window.currentPdfViewer.handleToolbarResize();
            }
        }, 200);
        
        console.log('‚úÖ PDF charg√© avec succ√®s en mode split unifi√©');
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement du PDF:', error);
    }
}

// Charger un document PDF (copi√© de lesson_view.html)
async function loadPDF(fileId) {
    try {
        const url = `/file_manager/preview/${fileId}`;
        console.log('üìÑ Chargement du PDF depuis:', url);
        
        const loadingTask = pdfjsLib.getDocument(url);
        pdfDocument = await loadingTask.promise;
        
        console.log(`üìÑ PDF charg√© avec ${pdfDocument.numPages} pages`);
        
        // Effacer le conteneur et les miniatures
        const pagesContainer = document.getElementById('pdfPagesContainer');
        const thumbnailContainer = document.getElementById('pageThumbnails');
        
        pagesContainer.innerHTML = '';
        thumbnailContainer.innerHTML = '';
        
        // Cr√©er toutes les pages
        for (let pageNum = 1; pageNum <= pdfDocument.numPages; pageNum++) {
            await createPDFPageWithCanvas(pageNum);
            await createThumbnail(pageNum);
        }
        
        // Configurer l'observer pour d√©tecter les pages visibles
        setupPageVisibilityObserver();
        
        // Configurer la gestion du scroll
        setupScrollHandling();
        
        // Appliquer automatiquement la correction du probl√®me de scroll apr√®s un petit d√©lai
        setTimeout(() => {
            console.log('üîß Application automatique de la correction de scroll...');
            applyScrollFixToViewer();
        }, 300);
        
        console.log('üìÑ Toutes les pages cr√©√©es avec succ√®s');
        
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement du PDF:', error);
        showError('Erreur lors du chargement du PDF');
    }
}

// Cr√©er une page PDF avec canvas d'annotation
async function createPDFPageWithCanvas(pageNum) {
    try {
        const page = await pdfDocument.getPage(pageNum);
        const viewport = page.getViewport({ scale: currentScale });
        
        // Cr√©er le wrapper de la page
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'pdf-page-wrapper';
        pageWrapper.id = `page-wrapper-${pageNum}`;
        
        // Canvas pour le PDF
        const pdfCanvas = document.createElement('canvas');
        pdfCanvas.className = 'pdf-canvas';
        pdfCanvas.id = `pdf-canvas-${pageNum}`;
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        
        // Canvas pour les annotations
        const annotationCanvas = document.createElement('canvas');
        annotationCanvas.className = 'annotation-canvas';
        annotationCanvas.id = `annotation-canvas-${pageNum}`;
        annotationCanvas.width = viewport.width;
        annotationCanvas.height = viewport.height;
        
        // Num√©ro de page
        const pageNumber = document.createElement('div');
        pageNumber.className = 'pdf-page-number';
        pageNumber.textContent = `Page ${pageNum}`;
        
        // Assembler la page
        pageWrapper.appendChild(pdfCanvas);
        pageWrapper.appendChild(annotationCanvas);
        pageWrapper.appendChild(pageNumber);
        
        // Ajouter au conteneur
        document.getElementById('pdfPagesContainer').appendChild(pageWrapper);
        
        // Rendre le PDF
        const ctx = pdfCanvas.getContext('2d');
        await page.render({
            canvasContext: ctx,
            viewport: viewport
        }).promise;
        
        // Configurer les √©v√©nements d'annotation
        setupAnnotationEvents(annotationCanvas, pageNum);
        
        console.log(`üìÑ Page ${pageNum} cr√©√©e avec succ√®s`);
        
    } catch (error) {
        console.error(`‚ùå Erreur lors de la cr√©ation de la page ${pageNum}:`, error);
    }
}

// Cr√©er une miniature
async function createThumbnail(pageNum) {
    try {
        const page = await pdfDocument.getPage(pageNum);
        const thumbnailScale = 0.25;
        const viewport = page.getViewport({ scale: thumbnailScale });
        
        const thumbnailCanvas = document.createElement('canvas');
        thumbnailCanvas.className = 'thumbnail-canvas';
        thumbnailCanvas.width = viewport.width;
        thumbnailCanvas.height = viewport.height;
        
        const ctx = thumbnailCanvas.getContext('2d');
        await page.render({
            canvasContext: ctx,
            viewport: viewport
        }).promise;
        
        // Wrapper pour la miniature
        const thumbnailItem = document.createElement('div');
        thumbnailItem.className = 'thumbnail-item';
        thumbnailItem.id = `thumbnail-${pageNum}`;
        thumbnailItem.appendChild(thumbnailCanvas);
        
        // √âv√©nement de clic pour navigation
        thumbnailItem.addEventListener('click', () => scrollToPage(pageNum));
        
        document.getElementById('pageThumbnails').appendChild(thumbnailItem);
        
    } catch (error) {
        console.error(`‚ùå Erreur lors de la cr√©ation de la miniature ${pageNum}:`, error);
    }
}

// Faire d√©filer vers une page sp√©cifique
function scrollToPage(pageNum) {
    const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
    if (pageWrapper) {
        // Utiliser scrollIntoView avec des options plus pr√©cises
        const viewerContainer = document.getElementById('viewerContainer');
        const containerRect = viewerContainer.getBoundingClientRect();
        const pageRect = pageWrapper.getBoundingClientRect();
        
        // Calculer la position de scroll n√©cessaire
        const scrollTop = viewerContainer.scrollTop + pageRect.top - containerRect.top - 20;
        
        // Faire le scroll avec une animation fluide
        viewerContainer.scrollTo({
            top: scrollTop,
            behavior: 'smooth'
        });
        
        // Mettre √† jour la miniature active
        updateActiveThumbnail(pageNum);
        
        currentPageNum = pageNum;
    }
}

// Mettre √† jour la miniature active
function updateActiveThumbnail(pageNum) {
    document.querySelectorAll('.thumbnail-item').forEach(item => {
        item.classList.remove('active');
    });
    document.getElementById(`thumbnail-${pageNum}`)?.classList.add('active');
}

// Configurer l'observer pour d√©tecter automatiquement les pages visibles
function setupPageVisibilityObserver() {
    const viewerContainer = document.getElementById('viewerContainer');
    if (!viewerContainer) return;
    
    // Cr√©er l'intersection observer
    const observer = new IntersectionObserver((entries) => {
        let mostVisiblePage = null;
        let maxVisibilityRatio = 0;
        
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const pageId = entry.target.id;
                const pageNum = parseInt(pageId.split('-').pop());
                
                // Trouver la page la plus visible
                if (entry.intersectionRatio > maxVisibilityRatio) {
                    maxVisibilityRatio = entry.intersectionRatio;
                    mostVisiblePage = pageNum;
                }
            }
        });
        
        // Mettre √† jour la page active si on a trouv√© une page visible
        if (mostVisiblePage && mostVisiblePage !== currentPageNum) {
            currentPageNum = mostVisiblePage;
            updateActiveThumbnail(mostVisiblePage);
        }
    }, {
        root: viewerContainer,
        rootMargin: '-50px 0px -50px 0px',
        threshold: [0.1, 0.5, 0.9]
    });
    
    // Observer toutes les pages
    for (let pageNum = 1; pageNum <= pdfDocument.numPages; pageNum++) {
        const pageWrapper = document.getElementById(`page-wrapper-${pageNum}`);
        if (pageWrapper) {
            observer.observe(pageWrapper);
        }
    }
    
    // Stocker l'observer pour pouvoir le nettoyer plus tard
    window.pdfPageObserver = observer;
}

// Am√©liorer la gestion du scroll dans le conteneur
function setupScrollHandling() {
    const viewerContainer = document.getElementById('viewerContainer');
    if (!viewerContainer) return;
    
    // G√©rer le scroll avec throttling pour les performances
    let scrollTimeout;
    viewerContainer.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            // Le scroll sera g√©r√© par l'intersection observer
        }, 100);
    });
}

// Fonction de correction automatique du scroll (adapt√©e de lesson_view.html)
function applyScrollFixToViewer() {
    console.log('üõ†Ô∏è Application automatique de la correction de scroll...');
    
    const viewerContainer = document.getElementById('viewerContainer');
    const pagesContainer = document.getElementById('pdfPagesContainer');
    const firstPage = document.getElementById('page-wrapper-1');
    
    if (!viewerContainer || !pagesContainer || !firstPage) {
        console.warn('‚ö†Ô∏è √âl√©ments non trouv√©s pour la correction - retry dans 100ms');
        setTimeout(applyScrollFixToViewer, 100);
        return;
    }
    
    // V√©rifier si la correction est n√©cessaire
    const rect = firstPage.getBoundingClientRect();
    const containerRect = viewerContainer.getBoundingClientRect();
    const pagePosition = rect.top - containerRect.top;
    
    console.log(`üìä Position actuelle de la page 1: ${Math.round(pagePosition)}px`);
    
    // Si la page 1 est tr√®s mal positionn√©e, appliquer la correction
    if (pagePosition < -100 || pagePosition > viewerContainer.clientHeight) {
        console.log('üö® Correction n√©cessaire - page 1 mal positionn√©e');
        
        // Appliquer les corrections CSS
        viewerContainer.style.scrollBehavior = 'auto';
        viewerContainer.style.height = '100%';
        viewerContainer.style.minHeight = '500px';
        viewerContainer.style.maxHeight = 'none';
        viewerContainer.style.overflow = 'auto';
        viewerContainer.style.position = 'relative';
        
        // Reset du pages container
        pagesContainer.style.paddingTop = '16px';
        pagesContainer.style.marginTop = '0px';
        pagesContainer.style.transform = 'none';
        pagesContainer.style.position = 'relative';
        pagesContainer.style.top = '0px';
        pagesContainer.style.left = '0px';
        
        // Forcer le reflow
        viewerContainer.style.display = 'none';
        viewerContainer.offsetHeight; // Force reflow
        viewerContainer.style.display = 'block';
        
        setTimeout(() => {
            // V√©rifier et ajuster le scroll
            const newRect = firstPage.getBoundingClientRect();
            const newContainerRect = viewerContainer.getBoundingClientRect();
            const newPosition = newRect.top - newContainerRect.top;
            
            console.log(`üìä Position apr√®s correction CSS: ${Math.round(newPosition)}px`);
            
            if (newPosition < -50 || newPosition > 100) {
                // Correction manuelle du scroll
                const targetScrollTop = firstPage.offsetTop - 16;
                viewerContainer.scrollTop = Math.max(0, targetScrollTop);
                console.log(`üîß Scroll manuel appliqu√©: ${viewerContainer.scrollTop}px`);
            }
            
            // Forcer la page courante √† 1
            currentPageNum = 1;
            updateActiveThumbnail(1);
            
            // Red√©marrer l'observer apr√®s correction
            if (window.pdfPageObserver) {
                window.pdfPageObserver.disconnect();
                setTimeout(() => {
                    setupPageVisibilityObserver();
                    console.log('‚úÖ Correction automatique termin√©e - Page 1 active');
                }, 100);
            }
        }, 50);
    } else {
        console.log('‚úÖ Position correcte - aucune correction n√©cessaire');
        // Juste s'assurer qu'on est √† la page 1
        viewerContainer.scrollTop = 0;
        currentPageNum = 1;
        updateActiveThumbnail(1);
    }
}

// Configurer les √©v√©nements d'annotation pour un canvas
function setupAnnotationEvents(canvas, pageNum) {
    let isPageDrawing = false;
    let currentStroke = [];
    
    // Fonctions de dessin
    function startDrawing(e) {
        e.preventDefault();
        isPageDrawing = true;
        currentPageNum = pageNum;
        
        const coords = getCanvasCoordinates(e, canvas);
        currentStroke = [coords];
        
        // Configurer le contexte
        const ctx = canvas.getContext('2d');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
        ctx.lineWidth = currentLineWidth;
        ctx.strokeStyle = currentColor;
        
        if (currentTool === 'highlighter') {
            ctx.globalAlpha = 0.3;
        } else {
            ctx.globalAlpha = 1.0;
        }
        
        ctx.beginPath();
        ctx.moveTo(coords.x, coords.y);
    }
    
    function continueDrawing(e) {
        if (!isPageDrawing) return;
        e.preventDefault();
        
        const coords = getCanvasCoordinates(e, canvas);
        currentStroke.push(coords);
        
        const ctx = canvas.getContext('2d');
        ctx.lineTo(coords.x, coords.y);
        ctx.stroke();
    }
    
    function stopDrawing(e) {
        if (!isPageDrawing) return;
        e.preventDefault();
        
        isPageDrawing = false;
        
        // Sauvegarder l'annotation
        if (currentStroke.length > 1) {
            const annotation = {
                page: pageNum,
                tool: currentTool,
                color: currentColor,
                lineWidth: currentLineWidth,
                points: [...currentStroke]
            };
            
            annotations.push(annotation);
            console.log(`üìù Annotation sauvegard√©e sur page ${pageNum}`);
        }
        
        currentStroke = [];
    }
    
    // √âv√©nements de souris
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', continueDrawing);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);
    
    // √âv√©nements tactiles
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', continueDrawing);
    canvas.addEventListener('touchend', stopDrawing);
}

// Obtenir les coordonn√©es relatives au canvas
function getCanvasCoordinates(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    let clientX, clientY;
    
    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
}

// Fermer le lecteur de fichier
function closeFileViewer() {
    const modal = document.getElementById('fileViewerModal');
    modal.classList.remove('show', 'embedded');
    
    // Sauvegarder les annotations avant fermeture
    if (annotations.length > 0) {
        saveAnnotations();
    }
    
    // Nettoyer l'observer
    if (window.pdfPageObserver) {
        window.pdfPageObserver.disconnect();
        window.pdfPageObserver = null;
    }
    
    // R√©initialiser les variables
    currentFileId = null;
    currentPageNum = 1;
    currentScale = 1.0;
    pdfDocument = null;
    annotations = [];
}

// Afficher une erreur
function showError(message) {
    const container = document.getElementById('pdfPagesContainer');
    container.innerHTML = `<div class="error-message">${message}</div>`;
}

// Charger les annotations depuis le serveur
async function loadAnnotations(fileId) {
    try {
        const response = await fetch(`/file-manager/api/annotations/${fileId}`);
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.annotations) {
                annotations = data.annotations;
                console.log(`üìù ${annotations.length} annotations charg√©es`);
                // Redessiner les annotations
                setTimeout(() => redrawAllAnnotations(), 500);
            }
        }
    } catch (error) {
        console.log('‚ÑπÔ∏è Aucune annotation existante:', error);
        annotations = [];
    }
}

// Sauvegarder les annotations
async function saveAnnotations() {
    if (!currentFileId || annotations.length === 0) {
        console.log('üíæ Aucune annotation √† sauvegarder');
        return;
    }

    try {
        const response = await fetch('/file-manager/api/save-annotations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_id: currentFileId,
                annotations: annotations
            })
        });

        if (response.ok) {
            console.log('üíæ Annotations sauvegard√©es avec succ√®s');
            updateSaveStatus('Sauvegard√©', 'success');
        } else {
            throw new Error('Erreur de sauvegarde');
        }
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde:', error);
        updateSaveStatus('Erreur de sauvegarde', 'error');
    }
}

// Configurer les outils d'annotation
function setupAnnotationTools() {
    console.log('üîß Configuration des outils d\'annotation...');
    
    // Outils de dessin
    document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => {
            currentTool = btn.dataset.tool;
            document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            console.log('üîß Outil s√©lectionn√©:', currentTool);
        });
    });

    // Couleurs
    document.querySelectorAll('[data-color]').forEach(btn => {
        btn.addEventListener('click', () => {
            currentColor = btn.dataset.color;
            document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            console.log('üé® Couleur s√©lectionn√©e:', currentColor);
        });
    });

    // Couleur personnalis√©e
    const colorPicker = document.getElementById('annotationColor');
    if (colorPicker) {
        colorPicker.addEventListener('change', (e) => {
            currentColor = e.target.value;
            document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
            console.log('üé® Couleur personnalis√©e:', currentColor);
        });
    }

    // √âpaisseur du trait
    const strokeWidth = document.getElementById('strokeWidth');
    const strokeWidthValue = document.getElementById('strokeWidthValue');
    if (strokeWidth && strokeWidthValue) {
        strokeWidth.addEventListener('input', (e) => {
            currentLineWidth = parseInt(e.target.value);
            strokeWidthValue.textContent = currentLineWidth;
            console.log('üìè √âpaisseur:', currentLineWidth);
        });
    }
}

// Configurer les √©v√©nements des outils
function setupToolEvents() {
    console.log('üîß Configuration des √©v√©nements d\'outils...');
    
    // Bouton d'annulation
    const undoBtn = document.getElementById('undoBtn');
    if (undoBtn) {
        undoBtn.addEventListener('click', undoLastAnnotation);
    }

    // Bouton de suppression
    const clearAllBtn = document.getElementById('clearAllBtn');
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', clearAllAnnotations);
    }
}

// Annuler la derni√®re annotation
function undoLastAnnotation() {
    if (annotations.length > 0) {
        const lastAnnotation = annotations.pop();
        redrawAllAnnotations();
        console.log('‚Ü∂ Annotation annul√©e');
    }
}

// Effacer toutes les annotations
function clearAllAnnotations() {
    if (confirm('Voulez-vous vraiment effacer toutes les annotations ?')) {
        annotations = [];
        redrawAllAnnotations();
        console.log('üóëÔ∏è Toutes les annotations effac√©es');
    }
}

// Redessiner toutes les annotations
function redrawAllAnnotations() {
    if (!pdfDocument) return;
    
    // Effacer tous les canvas d'annotation
    for (let pageNum = 1; pageNum <= pdfDocument.numPages; pageNum++) {
        const canvas = document.getElementById(`annotation-canvas-${pageNum}`);
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }
    
    // Redessiner toutes les annotations
    annotations.forEach(annotation => {
        const canvas = document.getElementById(`annotation-canvas-${annotation.page}`);
        if (canvas) {
            drawAnnotationOnCanvas(canvas.getContext('2d'), annotation);
        }
    });
}

// Dessiner une annotation sur le canvas
function drawAnnotationOnCanvas(ctx, annotation) {
    if (!annotation.points || annotation.points.length === 0) return;

    ctx.save();
    ctx.globalCompositeOperation = annotation.tool === 'eraser' ? 'destination-out' : 'source-over';
    ctx.strokeStyle = annotation.color || '#000000';
    ctx.lineWidth = annotation.lineWidth || 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    if (annotation.tool === 'highlighter') {
        ctx.globalAlpha = 0.3;
    } else {
        ctx.globalAlpha = 1.0;
    }

    ctx.beginPath();
    ctx.moveTo(annotation.points[0].x, annotation.points[0].y);
    
    for (let i = 1; i < annotation.points.length; i++) {
        ctx.lineTo(annotation.points[i].x, annotation.points[i].y);
    }
    
    ctx.stroke();
    ctx.restore();
}

// Mettre √† jour le statut de sauvegarde
function updateSaveStatus(message, type = 'info') {
    const saveStatus = document.getElementById('saveStatus');
    if (saveStatus) {
        const icon = type === 'success' ? 'check-circle' : 'info-circle';
        saveStatus.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;
        
        if (type === 'success') {
            setTimeout(() => {
                saveStatus.innerHTML = '<i class="fas fa-info-circle"></i> Sauvegarde √† la fermeture';
            }, 3000);
        }
    }
}

// Mettre √† jour la fermeture du modal pour inclure le PDF viewer
const originalClosePlanningModal2 = window.closePlanningModal;
window.closePlanningModal = function() {
    // Fermer le lecteur PDF s'il est ouvert
    const fileViewerModal = document.getElementById('fileViewerModal');
    if (fileViewerModal && fileViewerModal.classList.contains('show')) {
        closeFileViewer();
    }
    
    // Appeler la fonction originale
    if (typeof originalClosePlanningModal2 === 'function') {
        originalClosePlanningModal2();
    }
};

// √âcouter les changements de classe s√©lectionn√©e
document.addEventListener('DOMContentLoaded', function() {
    const classroomSelect = document.getElementById('modalClassroom');
    if (classroomSelect) {
        classroomSelect.addEventListener('change', function() {
            if (isSplitViewOpen && this.value) {
                loadClassFiles(this.value);
            }
        });
    }
});

// Modifier la fonction closePlanningModal pour r√©initialiser l'√©tat
const originalClosePlanningModal = window.closePlanningModal || function() {};
window.closePlanningModal = function() {
    // Fermer le split view si ouvert
    if (isSplitViewOpen) {
        toggleSplitView();
    }
    
    // Masquer l'overlay
    document.getElementById('modalOverlay').style.display = 'none';
    
    // R√©initialiser le contenu du gestionnaire de fichiers
    document.getElementById('noFiles').innerHTML = `
        <i class="fas fa-folder-open"></i>
        <p>Aucun fichier dans cette classe</p>
    `;
    
    // Fermer le lecteur PDF s'il est ouvert
    // TODO: Impl√©menter la fermeture du PDF viewer
    
    // Appeler la fonction originale
    if (typeof originalClosePlanningModal === 'function') {
        originalClosePlanningModal();
    } else {
        document.getElementById('planningModal').classList.remove('show');
    }
};

// Surcharger la fonction openPlanningModal pour afficher l'overlay
document.addEventListener('DOMContentLoaded', function() {
    // Attendre un peu pour que planning.js soit charg√©
    setTimeout(function() {
        const originalOpenPlanningModal = window.openPlanningModal;
        if (typeof originalOpenPlanningModal === 'function') {
            window.openPlanningModal = function(cell, fromAnnualView) {
                // Afficher l'overlay
                const overlay = document.getElementById('modalOverlay');
                if (overlay) {
                    overlay.style.display = 'block';
                }
                
                // Appeler la fonction originale
                originalOpenPlanningModal(cell, fromAnnualView);
            };
        }
    }, 100);
});

// Fermer le modal en cliquant sur l'overlay
document.addEventListener('DOMContentLoaded', function() {
    const overlay = document.getElementById('modalOverlay');
    if (overlay) {
        overlay.addEventListener('click', function() {
            closePlanningModal();
            closeDayPlanningModal();
        });
    }
});

// ============================================
// FONCTIONS POUR LE MODAL DE VUE JOURNALI√àRE
// ============================================

// Variables pour le modal journalier
let isDaySplitViewOpen = false;
let currentDayFilePath = '';
let allDayClassFiles = [];

// Variables pour le lecteur PDF journalier
let dayCurrentFileId = null;
let dayCurrentPageNum = 1;
let dayCurrentScale = 1.0;
let dayPdfDocument = null;
let dayAnnotations = [];
let dayCurrentTool = 'pen';
let dayCurrentColor = '#000000';
let dayCurrentLineWidth = 3;

// Ouvrir le modal de planification journali√®re
function openDayPlanningModal(dateStr, classroomId) {
    console.log('üìÖ Ouverture du modal journalier pour:', dateStr, 'classe:', classroomId);
    
    // Afficher l'overlay
    const overlay = document.getElementById('modalOverlay');
    if (overlay) {
        overlay.style.display = 'block';
    }
    
    // Mettre √† jour le titre
    const dateObj = new Date(dateStr);
    const dateStrFormatted = dateObj.toLocaleDateString('fr-FR', {
        weekday: 'long',
        day: 'numeric',
        month: 'long',
        year: 'numeric'
    });
    document.getElementById('dayModalTitle').textContent = `Planification - ${dateStrFormatted}`;
    
    // S√©lectionner la classe dans le dropdown
    const classroomSelect = document.getElementById('dayModalClassroom');
    if (classroomId) {
        classroomSelect.value = classroomId;
    }
    
    // Charger les planifications de la journ√©e
    loadDayPlannings(dateStr, classroomId);
    
    // Afficher le modal
    document.getElementById('dayPlanningModal').classList.add('show');
}

// Charger les cr√©neaux de la journ√©e avec planifications existantes
async function loadDayPlannings(dateStr, classroomId) {
    const container = document.getElementById('dayPlanningsContainer');
    container.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin"></i> Chargement...</div>';
    
    try {
        // Charger les planifications existantes
        const response = await fetch(`/planning/api/day/${dateStr}?classroom_id=${classroomId || ''}`);
        console.log('üì° R√©ponse API status:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Erreur HTTP:', response.status, errorText);
            container.innerHTML = '<div class="text-center text-danger">Erreur lors du chargement (HTTP ' + response.status + ')</div>';
            return;
        }
        
        const data = await response.json();
        console.log('üìä Donn√©es re√ßues:', data);
        
        // Cr√©er un objet des planifications par p√©riode
        const planningsByPeriod = {};
        if (data.success && data.plannings) {
            data.plannings.forEach(planning => {
                planningsByPeriod[planning.period] = planning;
            });
        }
        
        // Charger les cr√©neaux du jour pour cette classe
        await loadDayScheduleSlots(dateStr, classroomId, planningsByPeriod);
        
    } catch (error) {
        console.error('Erreur lors du chargement des planifications:', error);
        container.innerHTML = '<div class="text-center text-danger">Erreur lors du chargement</div>';
    }
}

// Charger les cr√©neaux du jour (horaire type + planifications)
async function loadDayScheduleSlots(dateStr, classroomId, existingPlannings) {
    const container = document.getElementById('dayPlanningsContainer');
    
    if (!classroomId) {
        container.innerHTML = '<div class="text-center text-muted">Veuillez s√©lectionner une classe pour voir les cr√©neaux</div>';
        return;
    }
    
    try {
        // R√©cup√©rer l'horaire type pour cette classe
        const dayOfWeek = new Date(dateStr).getDay();
        const weekday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Convertir dimanche=0 en lundi=0
        
        // Utiliser les donn√©es d√©j√† disponibles dans la page
        const periods = periodsData; // D√©fini globalement dans calendar_view.html
        
        // Filtrer les horaires pour cette classe et ce jour
        const todaySchedules = [];
        
        // Parcourir toutes les p√©riodes en g√©rant les fusions
        const skipPeriods = new Set();
        
        periods.forEach(period => {
            // Si cette p√©riode doit √™tre ignor√©e (d√©j√† trait√©e comme partie d'une fusion)
            if (skipPeriods.has(period.number)) {
                return;
            }
            
            // V√©rifier si cette classe a cours √† cette p√©riode ce jour dans l'horaire type
            const scheduleKey = `${weekday}_${period.number}`;
            const schedule = scheduleGrid[scheduleKey];
            
            // Parser l'ID de classe pour la comparaison
            let targetId, targetType;
            if (classroomId.startsWith('mixed_group_')) {
                targetId = parseInt(classroomId.split('_')[2]);
                targetType = 'mixed_group';
            } else if (classroomId.startsWith('classroom_')) {
                targetId = parseInt(classroomId.split('_')[1]);
                targetType = 'classroom';
            } else {
                // Format ancien (ID num√©rique direct)
                targetId = parseInt(classroomId);
                targetType = 'classroom';
            }
            
            // V√©rifier si l'horaire type correspond
            const scheduleMatches = schedule && (
                (schedule.classroom_id == targetId && targetType === 'classroom') ||
                (schedule.mixed_group_id == targetId && targetType === 'mixed_group')
            );
            
            // V√©rifier s'il y a une planification existante pour cette p√©riode
            const existingPlanning = existingPlannings[period.number];
            const hasExistingPlanning = existingPlanning && (
                (existingPlanning.classroom_id == targetId && targetType === 'classroom') ||
                (existingPlanning.mixed_group_id == targetId && targetType === 'mixed_group')
            );
            
            // Cr√©er un cr√©neau s'il y a soit un horaire type, soit une planification existante
            if (scheduleMatches || hasExistingPlanning) {
                // V√©rifier si cette p√©riode est fusionn√©e avec la suivante
                const mergedData = mergedInfo[weekday] && mergedInfo[weekday][period.number];
                const hasMergedNext = mergedData && mergedData.has_merged_next;
                
                let slotData = {
                    period_number: period.number,
                    period_start: period.start,
                    period_end: period.end,
                    planning: existingPlanning || null
                };
                
                // Si cette p√©riode est fusionn√©e avec la suivante
                if (hasMergedNext) {
                    const nextPeriod = periods.find(p => p.number === period.number + 1);
                    if (nextPeriod) {
                        // Cr√©er un slot √©tendu
                        slotData = {
                            period_number: `${period.number}-${nextPeriod.number}`,
                            period_start: period.start,
                            period_end: nextPeriod.end,
                            planning: existingPlanning || null,
                            is_merged: true,
                            has_merged_next: true
                        };
                        
                        // Ignorer la p√©riode suivante
                        skipPeriods.add(nextPeriod.number);
                        console.log(`Created merged slot: P${period.number}-${nextPeriod.number}`);
                    }
                }
                
                todaySchedules.push(slotData);
            }
        });
        
        renderDayScheduleSlots(todaySchedules, dateStr, classroomId);
        
    } catch (error) {
        console.error('Erreur lors du chargement des cr√©neaux:', error);
        container.innerHTML = '<div class="text-center text-danger">Erreur lors du chargement des cr√©neaux</div>';
    }
}

// Afficher les cr√©neaux de la journ√©e avec possibilit√© d'√©dition
function renderDayScheduleSlots(scheduleSlots, dateStr, classroomId) {
    const container = document.getElementById('dayPlanningsContainer');
    
    if (scheduleSlots.length === 0) {
        container.innerHTML = '<div class="text-center text-muted">Aucun cr√©neau configur√© pour cette journ√©e</div>';
        return;
    }
    
    // V√©rifier si la date est pass√©e (plus de 24h)
    const targetDate = new Date(dateStr);
    const now = new Date();
    const isPastDate = (now - targetDate) > (24 * 60 * 60 * 1000);
    
    // R√©cup√©rer les informations de la classe ou du groupe mixte
    let selectedItem = null;
    if (classroomId) {
        let type, numericId;
        if (classroomId.startsWith('mixed_group_')) {
            type = 'mixed_group';
            numericId = parseInt(classroomId.split('_')[2]);
        } else if (classroomId.startsWith('classroom_')) {
            type = 'classroom';
            numericId = parseInt(classroomId.split('_')[1]);
        } else {
            // Format ancien (ID num√©rique direct)
            type = 'classroom';
            numericId = parseInt(classroomId);
        }
        selectedItem = classrooms.find(c => c.id === numericId && c.type === type);
    }
    
    const classroomColor = selectedItem ? selectedItem.color : '#4F46E5';
    const classroomName = selectedItem ? selectedItem.name : 'Classe inconnue';
    const classroomSubject = selectedItem ? selectedItem.subject : '';
    
    let html = '<div class="day-schedules-list">';
    
    // Les slots arrivent d√©j√† avec la fusion g√©r√©e depuis loadDayScheduleSlots
    scheduleSlots.forEach(slot => {
        const planning = slot.planning;
        const hasPlanning = planning !== null;
        
        html += `
            <div class="day-schedule-slot ${slot.is_merged ? 'merged-slot' : ''}" style="border-left: 4px solid ${classroomColor}" onclick="editDaySlot('${slot.period_number}', '${dateStr}', '${classroomId}')">
                <div class="slot-header">
                    <div class="slot-period">P√©riode ${slot.period_number}</div>
                    <div class="slot-time">${slot.period_start} - ${slot.period_end}</div>
                    ${!isPastDate ? `<button class="btn-edit-slot" onclick="event.stopPropagation(); editDaySlot('${slot.period_number}', '${dateStr}', '${classroomId}')" title="Modifier ce cr√©neau">
                        <i class="fas fa-edit"></i>
                    </button>` : ''}
                </div>
                <div class="slot-content">
                    <div class="slot-class">${classroomName}${classroomSubject ? ' - ' + classroomSubject : ''}</div>
                    <div class="slot-title ${!hasPlanning ? 'placeholder' : ''}">
                        ${hasPlanning ? (planning.title || 'Sans titre') : 'Cliquez pour planifier ce cr√©neau'}
                    </div>
                    ${hasPlanning && planning.description ? `<div class="slot-description">${planning.description}</div>` : ''}
                    ${!hasPlanning && !isPastDate ? '<div class="slot-empty">Cr√©neau libre - Cliquez pour ajouter une planification</div>' : ''}
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
}

// Variables pour l'√©dition des cr√©neaux journaliers
let currentEditingSlot = null;

// √âditer un cr√©neau sp√©cifique
function editDaySlot(periodNumber, dateStr, classroomId) {
    console.log(`üìù √âdition cr√©neau: P√©riode ${periodNumber}, Date: ${dateStr}, Classe: ${classroomId}`);
    
    // Extraire le num√©ro de p√©riode de base pour les appels API (pour "1-2", prendre "1")
    const basePeriodNumber = periodNumber.includes('-') ? periodNumber.split('-')[0] : periodNumber;
    
    // Stocker les informations du cr√©neau en cours d'√©dition
    currentEditingSlot = {
        period: periodNumber,        // Garder le format complet pour l'affichage ("1-2")
        basePeriod: basePeriodNumber, // P√©riode de base pour les API (1)
        date: dateStr,
        classroomId: classroomId
    };
    
    // R√©cup√©rer les donn√©es existantes pour ce cr√©neau (utiliser la p√©riode de base)
    getDaySlotData(dateStr, basePeriodNumber, classroomId).then(data => {
        if (data.success && data.planning) {
            // Pr√©-remplir avec les donn√©es existantes
            showDaySlotEditModal(data.planning.title || '', data.planning.description || '');
        } else {
            // Nouveau cr√©neau vide
            showDaySlotEditModal('', '');
        }
    });
}

// R√©cup√©rer les donn√©es d'un cr√©neau sp√©cifique
async function getDaySlotData(dateStr, periodNumber, classroomId) {
    try {
        const response = await fetch(`/planning/api/slot/${dateStr}/${periodNumber}?classroom_id=${classroomId}`);
        if (response.ok) {
            return await response.json();
        }
        return { success: false };
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration du cr√©neau:', error);
        return { success: false };
    }
}

// Afficher le modal d'√©dition de cr√©neau
function showDaySlotEditModal(title, description) {
    // Cr√©er un modal d'√©dition simple
    const modalHtml = `
        <div class="day-edit-modal" id="dayEditModal">
            <div class="day-edit-content">
                <div class="day-edit-header">
                    <h4>Planifier le cr√©neau - P√©riode ${currentEditingSlot.period}</h4>
                    <button class="day-edit-close" onclick="closeDayEditModal()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="day-edit-body">
                    <div class="form-group" id="dayGroupSelectionDiv" style="display: none;">
                        <label class="form-label">Groupe</label>
                        <select id="dayModalGroup" class="form-control" onchange="toggleDayGroupRepeatOptions()">
                            <option value="">Classe enti√®re</option>
                        </select>
                        <small class="form-text text-muted">S√©lectionnez un groupe ou laissez "Classe enti√®re" pour tous les √©l√®ves</small>
                        
                        <!-- Options de r√©p√©tition des groupes pour le modal jour -->
                        <div id="dayGroupRepeatOptions" style="display: none; margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 4px;">
                            <label class="form-label" style="font-weight: 600; margin-bottom: 8px; display: block;">Application automatique :</label>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="dayGroupRepeat" value="same" style="margin-right: 8px;">
                                    <span>R√©p√©ter le m√™me groupe chaque semaine jusqu'√† la fin de l'ann√©e</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="dayGroupRepeat" value="alternate" style="margin-right: 8px;">
                                    <span>Alterner entre tous les groupes de la classe chaque semaine</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="dayGroupRepeat" value="none" checked style="margin-right: 8px;">
                                    <span>Appliquer seulement pour cette date</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Titre du cours</label>
                        <input type="text" id="daySlotTitle" class="form-control" 
                               value="${title}" placeholder="Ex: Introduction aux fractions">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <textarea id="daySlotDescription" class="form-control" rows="4"
                                  placeholder="D√©tails du cours, exercices pr√©vus...">${description}</textarea>
                    </div>
                </div>
                <div class="day-edit-footer">
                    <button class="btn btn-outline" onclick="closeDayEditModal()">Annuler</button>
                    <button class="btn btn-primary" onclick="saveDaySlot()">
                        <i class="fas fa-save"></i> Enregistrer
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Ajouter le modal au DOM
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Attacher la conversion des tirets en checkboxes
    attachDayDashConversion();
    
    // Charger les groupes pour cette classe
    loadGroupsForDayModal(currentEditingSlot.classroomId);
    
    // Afficher le modal
    setTimeout(() => {
        document.getElementById('dayEditModal').classList.add('show');
    }, 10);
}

// Fermer le modal d'√©dition
function closeDayEditModal() {
    const modal = document.getElementById('dayEditModal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => {
            modal.remove();
        }, 300);
    }
    currentEditingSlot = null;
}

// Attacher la conversion des tirets en checkboxes pour le modal journalier
function attachDayDashConversion() {
    const textarea = document.getElementById('daySlotDescription');
    if (!textarea) return;

    textarea.addEventListener('input', function(e) {
        const cursorPos = textarea.selectionStart;
        const value = textarea.value;

        // V√©rifier si on vient de taper un tiret en d√©but de ligne
        if (e.inputType === 'insertText' && e.data === '-') {
            const lines = value.substring(0, cursorPos).split('\n');
            const currentLine = lines[lines.length - 1];

            // Si le tiret est au d√©but de la ligne (avec √©ventuellement des espaces avant)
            if (currentLine.trim() === '-') {
                e.preventDefault();

                // Remplacer le tiret par [ ]
                const beforeCursor = value.substring(0, cursorPos - 1);
                const afterCursor = value.substring(cursorPos);
                const spaces = currentLine.match(/^\s*/)[0]; // Pr√©server l'indentation

                textarea.value = beforeCursor + spaces + '[ ] ' + afterCursor;

                // Placer le curseur apr√®s [ ]
                const newCursorPos = cursorPos - 1 + spaces.length + 4;
                textarea.setSelectionRange(newCursorPos, newCursorPos);
            }
        }
    });
}

// Sauvegarder les modifications du cr√©neau
async function saveDaySlot() {
    if (!currentEditingSlot) return;
    
    const title = document.getElementById('daySlotTitle').value;
    const description = document.getElementById('daySlotDescription').value;
    const groupId = document.getElementById('dayModalGroup').value || null;
    
    // V√©rifier les options de r√©p√©tition des groupes
    const groupRepeatOption = document.querySelector('input[name="dayGroupRepeat"]:checked');
    const shouldApplyPattern = groupRepeatOption && groupRepeatOption.value !== 'none' && groupId;
    
    try {
        // Sauvegarder d'abord la planification actuelle
        const response = await fetch('/planning/save_planning', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                date: currentEditingSlot.date,
                period_number: currentEditingSlot.basePeriod,
                classroom_id: currentEditingSlot.classroomId,
                title: title,
                description: description,
                checklist_states: {}, // Pas de checkboxes dans ce modal simple
                group_id: groupId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('‚úÖ Cr√©neau sauvegard√© avec succ√®s');
            
            // Si une option de r√©p√©tition est s√©lectionn√©e, appliquer le pattern
            if (shouldApplyPattern) {
                const patternResponse = await fetch('/planning/apply-group-pattern', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        start_date: currentEditingSlot.date,
                        period_number: currentEditingSlot.basePeriod,
                        classroom_id: currentEditingSlot.classroomId,
                        title: title,
                        description: description,
                        checklist_states: {},
                        pattern_type: groupRepeatOption.value,
                        group_id: parseInt(groupId)
                    })
                });

                const patternResult = await patternResponse.json();
                
                if (patternResult.success) {
                    console.log(`‚úÖ Pattern appliqu√©: ${patternResult.message}`);
                } else {
                    console.log(`‚ö†Ô∏è Erreur lors de l'application du pattern: ${patternResult.message}`);
                }
            }
            
            // Sauvegarder les valeurs avant de fermer le modal
            const dateToReload = currentEditingSlot.date;
            const classroomToReload = currentEditingSlot.classroomId;
            closeDayEditModal();
            // Recharger les cr√©neaux de la journ√©e
            loadDayPlannings(dateToReload, classroomToReload);
        } else {
            console.error('‚ùå Erreur lors de la sauvegarde:', result.message || 'Erreur inconnue');
            alert('Erreur lors de la sauvegarde: ' + (result.message || 'Erreur inconnue'));
        }
    } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        alert('Erreur lors de la sauvegarde: ' + error.message);
    }
}

// Charger les groupes pour une classe (modal principal)
async function loadGroupsForClass(classroomId) {
    const groupDiv = document.getElementById('groupSelectionDiv');
    const groupSelect = document.getElementById('modalGroup');
    
    if (!classroomId) {
        groupDiv.style.display = 'none';
        return;
    }
    
    // G√©rer le cas des t√¢ches personnalis√©es
    if (classroomId === 'custom_task') {
        groupDiv.style.display = 'none';
        
        // Cacher le bouton fichiers pour les t√¢ches personnalis√©es
        const fileButton = document.querySelector('.modal-header-actions .btn-icon[onclick="toggleSplitView()"]');
        if (fileButton) {
            fileButton.style.display = 'none';
        }
        
        // Changer le label du titre
        const titleLabel = document.querySelector('label[for="modalPlanningTitle"], .form-group label:has(+ #modalPlanningTitle)');
        if (!titleLabel) {
            // Si on ne trouve pas avec for, chercher le label pr√©c√©dent
            const titleInput = document.getElementById('modalPlanningTitle');
            if (titleInput) {
                const parentGroup = titleInput.closest('.form-group');
                if (parentGroup) {
                    const label = parentGroup.querySelector('label');
                    if (label) {
                        label.textContent = 'Titre';
                    }
                }
            }
        } else {
            titleLabel.textContent = 'Titre';
        }
        
        return;
    }
    
    // Pour les classes normales, r√©afficher le bouton fichiers et remettre le label par d√©faut
    const fileButton = document.querySelector('.modal-header-actions .btn-icon[onclick="toggleSplitView()"]');
    if (fileButton) {
        fileButton.style.display = 'inline-block';
    }
    
    // Remettre le label par d√©faut
    const titleInput = document.getElementById('modalPlanningTitle');
    if (titleInput) {
        const parentGroup = titleInput.closest('.form-group');
        if (parentGroup) {
            const label = parentGroup.querySelector('label');
            if (label) {
                label.textContent = 'Titre du cours';
            }
        }
    }
    
    try {
        // Extraire l'ID num√©rique si classroomId contient un pr√©fixe
        const numericId = classroomId.toString().includes('_') ? classroomId.split('_')[1] : classroomId;
        const response = await fetch(`/planning/get-groups/${numericId}`);
        const data = await response.json();
        
        if (data.success && data.groups.length > 0) {
            // R√©initialiser les options
            groupSelect.innerHTML = '<option value="">Classe enti√®re</option>';
            
            // Ajouter les groupes
            data.groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                option.style.color = group.color;
                groupSelect.appendChild(option);
            });
            
            groupDiv.style.display = 'block';
        } else {
            groupDiv.style.display = 'none';
        }
    } catch (error) {
        console.error('Erreur lors du chargement des groupes:', error);
        groupDiv.style.display = 'none';
    }
}

// Charger les groupes pour le modal journalier
async function loadGroupsForDayModal(classroomId) {
    const groupDiv = document.getElementById('dayGroupSelectionDiv');
    const groupSelect = document.getElementById('dayModalGroup');
    
    if (!classroomId) {
        groupDiv.style.display = 'none';
        return;
    }
    
    try {
        // Extraire l'ID num√©rique si classroomId contient un pr√©fixe
        const numericId = classroomId.toString().includes('_') ? classroomId.split('_')[1] : classroomId;
        const response = await fetch(`/planning/get-groups/${numericId}`);
        const data = await response.json();
        
        if (data.success && data.groups.length > 0) {
            // R√©initialiser les options
            groupSelect.innerHTML = '<option value="">Classe enti√®re</option>';
            
            // Ajouter les groupes
            data.groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                option.style.color = group.color;
                groupSelect.appendChild(option);
            });
            
            groupDiv.style.display = 'block';
        } else {
            groupDiv.style.display = 'none';
        }
    } catch (error) {
        console.error('Erreur lors du chargement des groupes:', error);
        groupDiv.style.display = 'none';
    }
}

// Fermer le modal journalier
function closeDayPlanningModal() {
    // Fermer le lecteur PDF s'il est ouvert
    const dayFileViewerModal = document.getElementById('dayFileViewerModal');
    if (dayFileViewerModal && dayFileViewerModal.classList.contains('show')) {
        closeDayFileViewer();
    }
    
    // Fermer le split view si ouvert
    if (isDaySplitViewOpen) {
        toggleDaySplitView();
    }
    
    // Masquer l'overlay
    document.getElementById('modalOverlay').style.display = 'none';
    
    // Fermer le modal
    document.getElementById('dayPlanningModal').classList.remove('show');
}

// Basculer l'affichage du gestionnaire de fichiers pour la vue journali√®re
function toggleDaySplitView() {
    const modal = document.getElementById('dayPlanningModal');
    const fileManagerPanel = document.getElementById('dayFileManagerPanel');
    
    isDaySplitViewOpen = !isDaySplitViewOpen;
    
    if (isDaySplitViewOpen) {
        modal.classList.add('split-view');
        fileManagerPanel.style.display = 'flex';
        
        // Charger les fichiers de la classe s√©lectionn√©e
        const classroomId = document.getElementById('dayModalClassroom').value;
        if (classroomId) {
            loadDayClassFiles(classroomId);
        } else {
            // Si aucune classe n'est s√©lectionn√©e, afficher un message
            document.getElementById('dayFileLoading').style.display = 'none';
            document.getElementById('dayFileNavigation').style.display = 'none';
            document.getElementById('dayFileTree').style.display = 'none';
            document.getElementById('dayNoFiles').style.display = 'block';
            document.getElementById('dayNoFiles').innerHTML = `
                <i class="fas fa-exclamation-circle"></i>
                <p>Veuillez s√©lectionner une classe</p>
            `;
        }
    } else {
        modal.classList.remove('split-view');
        fileManagerPanel.style.display = 'none';
    }
}

// Charger les fichiers d'une classe pour la vue journali√®re
async function loadDayClassFiles(classroomId) {
    const fileLoading = document.getElementById('dayFileLoading');
    const fileNavigation = document.getElementById('dayFileNavigation');
    const fileTree = document.getElementById('dayFileTree');
    const noFiles = document.getElementById('dayNoFiles');
    
    console.log('Chargement des fichiers pour la classe:', classroomId);
    
    // Extraire l'ID num√©rique si la valeur contient un pr√©fixe (ex: "classroom_21" -> "21")
    const numericId = classroomId.toString().includes('_') ? classroomId.split('_')[1] : classroomId;
    
    // Afficher le chargement
    fileLoading.style.display = 'block';
    fileNavigation.style.display = 'none';
    fileTree.style.display = 'none';
    noFiles.style.display = 'none';
    
    try {
        const response = await fetch(`/planning/get-class-resources/${numericId}`);
        console.log('R√©ponse API:', response);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Donn√©es re√ßues:', data);
        
        fileLoading.style.display = 'none';
        
        if (data.success && data.files && data.files.length > 0) {
            allDayClassFiles = data.files;
            fileNavigation.style.display = 'block';
            fileTree.style.display = 'block';
            renderDayFileTree(data.files, currentDayFilePath);
        } else {
            console.log('Aucun fichier trouv√© ou erreur dans la r√©ponse');
            noFiles.style.display = 'block';
        }
    } catch (error) {
        console.error('Erreur lors du chargement des fichiers:', error);
        fileLoading.style.display = 'none';
        noFiles.style.display = 'block';
    }
}

// Afficher l'arborescence des fichiers pour la vue journali√®re
function renderDayFileTree(files, currentPath = '') {
    const fileTree = document.getElementById('dayFileTree');
    fileTree.innerHTML = '';
    
    // Organiser les fichiers par dossier (m√™me logique que l'original)
    const folders = {};
    const currentLevelFiles = [];
    const allFolders = new Set();
    
    files.forEach(file => {
        if (file.folder_path) {
            // Extraire tous les dossiers du chemin
            const pathParts = file.folder_path.split('/').filter(p => p);
            let accumulatedPath = '';
            
            pathParts.forEach((part, index) => {
                const parentPath = accumulatedPath;
                accumulatedPath = accumulatedPath ? `${accumulatedPath}/${part}` : part;
                
                allFolders.add(accumulatedPath);
                
                if (!folders[accumulatedPath]) {
                    folders[accumulatedPath] = {
                        name: part,
                        path: accumulatedPath,
                        parent: parentPath,
                        files: [],
                        subfolders: new Set()
                    };
                }
                
                if (parentPath && folders[parentPath]) {
                    folders[parentPath].subfolders.add(accumulatedPath);
                }
                
                if (index === pathParts.length - 1) {
                    folders[accumulatedPath].files.push(file);
                }
            });
            
            if (currentPath && file.folder_path.startsWith(currentPath)) {
                const relativePath = file.folder_path.substring(currentPath.length).replace(/^\//, '');
                const relativePathParts = relativePath.split('/').filter(p => p);
                
                if (relativePathParts.length === 0 || (relativePathParts.length === 1 && relativePathParts[0] === '')) {
                    currentLevelFiles.push(file);
                }
            }
        } else if (!currentPath) {
            currentLevelFiles.push(file);
        }
    });
    
    // Si on navigue dans un dossier, ajouter un bouton retour
    if (currentPath) {
        const backItem = document.createElement('div');
        backItem.className = 'file-item';
        backItem.innerHTML = `
            <i class="fas fa-arrow-left file-icon"></i>
            <span class="file-name">..</span>
        `;
        backItem.onclick = () => {
            const parentPath = currentPath.includes('/') ? 
                currentPath.substring(0, currentPath.lastIndexOf('/')) : '';
            navigateToDayFileFolder(parentPath);
        };
        fileTree.appendChild(backItem);
    }
    
    // Afficher les dossiers du niveau actuel
    Object.values(folders).forEach(folder => {
        const shouldShow = currentPath ? 
            folder.parent === currentPath : 
            !folder.parent;
        
        if (shouldShow) {
            const folderItem = document.createElement('div');
            folderItem.className = 'file-item folder';
            folderItem.innerHTML = `
                <i class="fas fa-folder file-icon"></i>
                <span class="file-name">${folder.name}</span>
            `;
            folderItem.onclick = () => navigateToDayFileFolder(folder.path);
            fileTree.appendChild(folderItem);
        }
    });
    
    // Afficher les fichiers du niveau actuel
    currentLevelFiles.forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        
        const icon = getFileIconByType(file.file_type);
        
        fileItem.innerHTML = `
            <i class="${icon} file-icon"></i>
            <span class="file-name">${file.original_filename}</span>
        `;
        
        if (file.file_type === 'pdf') {
            console.log('üìÑ Cr√©ation du gestionnaire de clic pour le PDF:', file.original_filename, 'ID:', file.id);
            fileItem.onclick = () => {
                console.log('üñ±Ô∏è Clic sur le fichier PDF:', file.original_filename);
                openDayPdfInViewer(file.id, file.original_filename);
            };
        }
        
        fileTree.appendChild(fileItem);
    });
    
    // Mettre √† jour le fil d'Ariane
    updateDayBreadcrumb(currentPath);
}

// Naviguer dans un dossier pour la vue journali√®re
function navigateToDayFileFolder(folderPath) {
    currentDayFilePath = folderPath;
    console.log('Navigation vers le dossier:', folderPath);
    
    renderDayFileTree(allDayClassFiles, folderPath);
}

// Mettre √† jour le fil d'Ariane pour la vue journali√®re
function updateDayBreadcrumb(path) {
    const breadcrumb = document.getElementById('dayFileBreadcrumb');
    breadcrumb.innerHTML = '';
    
    // Racine
    const rootItem = document.createElement('span');
    rootItem.className = 'breadcrumb-item';
    rootItem.innerHTML = '<i class="fas fa-home"></i> Racine';
    rootItem.onclick = () => navigateToDayFileFolder('');
    breadcrumb.appendChild(rootItem);
    
    // Ajouter les parties du chemin
    if (path) {
        const parts = path.split('/').filter(p => p);
        let accumulatedPath = '';
        
        parts.forEach((part, index) => {
            // Ajouter le s√©parateur
            const separator = document.createElement('i');
            separator.className = 'fas fa-chevron-right';
            separator.style.cssText = 'margin: 0 0.5rem; font-size: 0.75rem; color: #9ca3af;';
            breadcrumb.appendChild(separator);
            
            // Construire le chemin accumul√©
            accumulatedPath = accumulatedPath ? `${accumulatedPath}/${part}` : part;
            
            // Cr√©er l'√©l√©ment du fil d'Ariane
            const partItem = document.createElement('span');
            partItem.className = index === parts.length - 1 ? 'breadcrumb-item active' : 'breadcrumb-item';
            partItem.textContent = part;
            
            if (index < parts.length - 1) {
                const pathToNavigate = accumulatedPath;
                partItem.onclick = () => navigateToDayFileFolder(pathToNavigate);
            }
            
            breadcrumb.appendChild(partItem);
        });
    }
}

// Ouvrir un PDF dans le lecteur int√©gr√© en mode split pour la vue journali√®re
async function openDayPdfInViewer(fileId, fileName) {
    console.log('üìÑ Ouverture du PDF avec lecteur unifi√© en mode split journalier:', fileName);
    console.log('üìç FileId:', fileId, 'FileName:', fileName);
    
    try {
        // Approche alternative : cr√©er un nouveau conteneur directement dans le body
        let container = document.getElementById('pdf-viewer-container-day');
        if (container) {
            document.body.removeChild(container);
        }
        
        container = document.createElement('div');
        container.id = 'pdf-viewer-container-day';
        container.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            right: 0 !important;
            width: 50vw !important;
            height: 100vh !important;
            z-index: 15000 !important;
            background: #F8FAFC !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1) !important;
        `;
        
        document.body.appendChild(container);
        console.log('‚úÖ Nouveau conteneur cr√©√© dans le body');
        
        // V√©rifier les dimensions apr√®s ajout au body
        console.log('üîç Debug nouveau conteneur:', {
            width: container.offsetWidth,
            height: container.offsetHeight,
            visible: container.offsetParent !== null
        });
        
        // D√©terminer quelle classe utiliser pour l'envoi de fichiers selon le contexte journalier
        let currentClassId = getDayViewSelectedClassId();
        
        // R√©cup√©rer les √©tudiants de la classe actuelle
        const studentsData = await getStudentsForClass(currentClassId);
        
        // Configuration pour le mode split sans suivi d'√©l√®ves
        const options = {
            mode: 'split',
            enableStudentTracking: false, // D√©sactiver le bouton de suivi d'√©l√®ves
            enableSendToStudents: true,   // Activer l'envoi aux √©l√®ves
            currentClassId: currentClassId,
            studentData: studentsData,
            autoSave: true,
            saveDelay: 3000,
            apiEndpoints: {
                saveAnnotations: '/file_manager/api/save-annotations',
                loadAnnotations: '/file_manager/api/load-annotations',
                search: '/api/search-pdf'
            }
        };
        
        // D√©truire l'instance pr√©c√©dente si elle existe
        if (window.currentPdfViewer) {
            window.currentPdfViewer.destroy();
        }
        
        // Cr√©er la nouvelle instance avec le nouveau conteneur
        window.currentPdfViewer = new UnifiedPDFViewer('pdf-viewer-container-day', options);
        
        // Attendre que le DOM se mette √† jour
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // V√©rifier et forcer tous les styles de visibilit√©
        const computedStyle = window.getComputedStyle(container);
        console.log('üîç Debug conteneur principal avant correction:', {
            containerDisplay: container.style.display,
            containerWidth: container.offsetWidth,
            containerHeight: container.offsetHeight,
            containerVisible: container.offsetParent !== null,
            computedDisplay: computedStyle.display,
            computedVisibility: computedStyle.visibility,
            computedOpacity: computedStyle.opacity
        });
        
        // Forcer absolument la visibilit√©
        container.style.display = 'block !important';
        container.style.visibility = 'visible !important';
        container.style.opacity = '1 !important';
        container.style.zIndex = '11000';
        
        // Re-check apr√®s for√ßage
        setTimeout(() => {
            console.log('üîç Debug conteneur apr√®s for√ßage:', {
                containerWidth: container.offsetWidth,
                containerHeight: container.offsetHeight,
                containerVisible: container.offsetParent !== null
            });
        }, 50);
        
        // Forcer les dimensions des conteneurs internes
        const pdfViewerArea = container.querySelector('.pdf-viewer-area');
        const pdfMain = container.querySelector('.pdf-main');
        const unifiedViewer = container.querySelector('.unified-pdf-viewer');
        
        if (unifiedViewer) {
            console.log('üîç Debug unified-pdf-viewer:', {
                width: unifiedViewer.offsetWidth,
                height: unifiedViewer.offsetHeight,
                computedStyle: window.getComputedStyle(unifiedViewer).display
            });
        }
        
        if (pdfViewerArea) {
            pdfViewerArea.style.width = '100%';
            pdfViewerArea.style.height = '100%';
            pdfViewerArea.style.display = 'flex';
            console.log('üîß Dimensions forc√©es pour pdf-viewer-area:', {
                width: pdfViewerArea.offsetWidth,
                height: pdfViewerArea.offsetHeight
            });
        }
        if (pdfMain) {
            pdfMain.style.width = '100%';
            pdfMain.style.height = '100%';
            pdfMain.style.display = 'flex';
            console.log('üîß Dimensions forc√©es pour pdf-main:', {
                width: pdfMain.offsetWidth,
                height: pdfMain.offsetHeight
            });
        }
        
        // Charger le PDF avec fileId pour la sauvegarde  
        const pdfUrl = `/file_manager/serve_file/${fileId}`;
        console.log('üìé URL du PDF:', pdfUrl);
        await window.currentPdfViewer.loadPDF(pdfUrl, fileId);
        
        // Forcer le recalcul des dimensions apr√®s le chargement
        setTimeout(() => {
            if (window.currentPdfViewer && window.currentPdfViewer.handleToolbarResize) {
                console.log('üîß Recalcul forc√© des dimensions de la toolbar');
                window.currentPdfViewer.handleToolbarResize();
            }
        }, 200);
        
        console.log('‚úÖ PDF charg√© avec succ√®s');
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement du PDF:', error);
    }
}

// Charger un document PDF pour la vue journali√®re
async function loadDayPDF(fileId) {
    try {
        const url = `/file_manager/preview/${fileId}`;
        console.log('üìÑ Chargement du PDF depuis:', url);
        
        const loadingTask = pdfjsLib.getDocument(url);
        dayPdfDocument = await loadingTask.promise;
        
        console.log(`üìÑ PDF charg√© avec ${dayPdfDocument.numPages} pages`);
        
        // Effacer le conteneur et les miniatures
        const pagesContainer = document.getElementById('dayPdfPagesContainer');
        const thumbnailContainer = document.getElementById('dayPageThumbnails');
        
        pagesContainer.innerHTML = '';
        thumbnailContainer.innerHTML = '';
        
        // Cr√©er toutes les pages
        for (let pageNum = 1; pageNum <= dayPdfDocument.numPages; pageNum++) {
            await createDayPDFPageWithCanvas(pageNum);
            await createDayThumbnail(pageNum);
        }
        
        // Configurer l'observer pour d√©tecter les pages visibles (version journali√®re)
        setupDayPageVisibilityObserver();
        
        // Appliquer automatiquement la correction du probl√®me de scroll apr√®s un petit d√©lai
        setTimeout(() => {
            console.log('üîß Application automatique de la correction de scroll journalier...');
            applyDayScrollFixToViewer();
        }, 300);
        
        console.log('üìÑ Toutes les pages cr√©√©es avec succ√®s');
        
    } catch (error) {
        console.error('‚ùå Erreur lors du chargement du PDF:', error);
        showDayError('Erreur lors du chargement du PDF');
    }
}

// Cr√©er une page PDF avec canvas d'annotation pour la vue journali√®re
async function createDayPDFPageWithCanvas(pageNum) {
    try {
        const page = await dayPdfDocument.getPage(pageNum);
        const viewport = page.getViewport({ scale: dayCurrentScale });
        
        // Cr√©er le wrapper de la page
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'pdf-page-wrapper';
        pageWrapper.id = `day-page-wrapper-${pageNum}`;
        
        // Canvas pour le PDF
        const pdfCanvas = document.createElement('canvas');
        pdfCanvas.className = 'pdf-canvas';
        pdfCanvas.id = `day-pdf-canvas-${pageNum}`;
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        
        // Canvas pour les annotations
        const annotationCanvas = document.createElement('canvas');
        annotationCanvas.className = 'annotation-canvas';
        annotationCanvas.id = `day-annotation-canvas-${pageNum}`;
        annotationCanvas.width = viewport.width;
        annotationCanvas.height = viewport.height;
        
        // Num√©ro de page
        const pageNumber = document.createElement('div');
        pageNumber.className = 'pdf-page-number';
        pageNumber.textContent = `Page ${pageNum}`;
        
        // Assembler la page
        pageWrapper.appendChild(pdfCanvas);
        pageWrapper.appendChild(annotationCanvas);
        pageWrapper.appendChild(pageNumber);
        
        // Ajouter au conteneur
        document.getElementById('dayPdfPagesContainer').appendChild(pageWrapper);
        
        // Rendre le PDF
        const ctx = pdfCanvas.getContext('2d');
        await page.render({
            canvasContext: ctx,
            viewport: viewport
        }).promise;
        
        // Configurer les √©v√©nements d'annotation
        setupDayAnnotationEvents(annotationCanvas, pageNum);
        
        console.log(`üìÑ Page journali√®re ${pageNum} cr√©√©e avec succ√®s`);
        
    } catch (error) {
        console.error(`‚ùå Erreur lors de la cr√©ation de la page journali√®re ${pageNum}:`, error);
    }
}

// Cr√©er une miniature pour la vue journali√®re
async function createDayThumbnail(pageNum) {
    try {
        const page = await dayPdfDocument.getPage(pageNum);
        const thumbnailScale = 0.25;
        const viewport = page.getViewport({ scale: thumbnailScale });
        
        const thumbnailCanvas = document.createElement('canvas');
        thumbnailCanvas.className = 'thumbnail-canvas';
        thumbnailCanvas.width = viewport.width;
        thumbnailCanvas.height = viewport.height;
        
        const ctx = thumbnailCanvas.getContext('2d');
        await page.render({
            canvasContext: ctx,
            viewport: viewport
        }).promise;
        
        // Wrapper pour la miniature
        const thumbnailItem = document.createElement('div');
        thumbnailItem.className = 'thumbnail-item';
        thumbnailItem.id = `day-thumbnail-${pageNum}`;
        thumbnailItem.appendChild(thumbnailCanvas);
        
        // √âv√©nement de clic pour navigation
        thumbnailItem.addEventListener('click', () => scrollToDayPage(pageNum));
        
        document.getElementById('dayPageThumbnails').appendChild(thumbnailItem);
        
    } catch (error) {
        console.error(`‚ùå Erreur lors de la cr√©ation de la miniature journali√®re ${pageNum}:`, error);
    }
}

// Faire d√©filer vers une page sp√©cifique pour la vue journali√®re
function scrollToDayPage(pageNum) {
    const pageWrapper = document.getElementById(`day-page-wrapper-${pageNum}`);
    if (pageWrapper) {
        // Utiliser scrollIntoView avec des options plus pr√©cises
        const viewerContainer = document.getElementById('dayViewerContainer');
        const containerRect = viewerContainer.getBoundingClientRect();
        const pageRect = pageWrapper.getBoundingClientRect();
        
        // Calculer la position de scroll n√©cessaire
        const scrollTop = viewerContainer.scrollTop + pageRect.top - containerRect.top - 20;
        
        // Faire le scroll avec une animation fluide
        viewerContainer.scrollTo({
            top: scrollTop,
            behavior: 'smooth'
        });
        
        // Mettre √† jour la miniature active
        updateDayActiveThumbnail(pageNum);
        
        dayCurrentPageNum = pageNum;
    }
}

// Mettre √† jour la miniature active pour la vue journali√®re
function updateDayActiveThumbnail(pageNum) {
    document.querySelectorAll('#dayPageThumbnails .thumbnail-item').forEach(item => {
        item.classList.remove('active');
    });
    document.getElementById(`day-thumbnail-${pageNum}`)?.classList.add('active');
}

// Configurer l'observer pour d√©tecter automatiquement les pages visibles (version journali√®re)
function setupDayPageVisibilityObserver() {
    const viewerContainer = document.getElementById('dayViewerContainer');
    if (!viewerContainer) return;
    
    // Cr√©er l'intersection observer
    const observer = new IntersectionObserver((entries) => {
        let mostVisiblePage = null;
        let maxVisibilityRatio = 0;
        
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const pageId = entry.target.id;
                const pageNum = parseInt(pageId.split('-').pop());
                
                // Trouver la page la plus visible
                if (entry.intersectionRatio > maxVisibilityRatio) {
                    maxVisibilityRatio = entry.intersectionRatio;
                    mostVisiblePage = pageNum;
                }
            }
        });
        
        // Mettre √† jour la page active si on a trouv√© une page visible
        if (mostVisiblePage && mostVisiblePage !== dayCurrentPageNum) {
            dayCurrentPageNum = mostVisiblePage;
            updateDayActiveThumbnail(mostVisiblePage);
        }
    }, {
        root: viewerContainer,
        rootMargin: '-50px 0px -50px 0px',
        threshold: [0.1, 0.5, 0.9]
    });
    
    // Observer toutes les pages
    for (let pageNum = 1; pageNum <= dayPdfDocument.numPages; pageNum++) {
        const pageWrapper = document.getElementById(`day-page-wrapper-${pageNum}`);
        if (pageWrapper) {
            observer.observe(pageWrapper);
        }
    }
    
    // Stocker l'observer pour pouvoir le nettoyer plus tard
    window.dayPdfPageObserver = observer;
}

// Fonction de correction automatique du scroll pour la vue journali√®re (adapt√©e de lesson_view.html)
function applyDayScrollFixToViewer() {
    console.log('üõ†Ô∏è Application automatique de la correction de scroll journalier...');
    
    const viewerContainer = document.getElementById('dayViewerContainer');
    const pagesContainer = document.getElementById('dayPdfPagesContainer');
    const firstPage = document.getElementById('day-page-wrapper-1');
    
    if (!viewerContainer || !pagesContainer || !firstPage) {
        console.warn('‚ö†Ô∏è √âl√©ments journaliers non trouv√©s pour la correction - retry dans 100ms');
        setTimeout(applyDayScrollFixToViewer, 100);
        return;
    }
    
    // V√©rifier si la correction est n√©cessaire
    const rect = firstPage.getBoundingClientRect();
    const containerRect = viewerContainer.getBoundingClientRect();
    const pagePosition = rect.top - containerRect.top;
    
    console.log(`üìä Position actuelle de la page 1 journali√®re: ${Math.round(pagePosition)}px`);
    
    // Si la page 1 est tr√®s mal positionn√©e, appliquer la correction
    if (pagePosition < -100 || pagePosition > viewerContainer.clientHeight) {
        console.log('üö® Correction n√©cessaire - page 1 journali√®re mal positionn√©e');
        
        // Appliquer les corrections CSS
        viewerContainer.style.scrollBehavior = 'auto';
        viewerContainer.style.height = '100%';
        viewerContainer.style.minHeight = '500px';
        viewerContainer.style.maxHeight = 'none';
        viewerContainer.style.overflow = 'auto';
        viewerContainer.style.position = 'relative';
        
        // Reset du pages container
        pagesContainer.style.paddingTop = '16px';
        pagesContainer.style.marginTop = '0px';
        pagesContainer.style.transform = 'none';
        pagesContainer.style.position = 'relative';
        pagesContainer.style.top = '0px';
        pagesContainer.style.left = '0px';
        
        // Forcer le reflow
        viewerContainer.style.display = 'none';
        viewerContainer.offsetHeight; // Force reflow
        viewerContainer.style.display = 'block';
        
        setTimeout(() => {
            // V√©rifier et ajuster le scroll
            const newRect = firstPage.getBoundingClientRect();
            const newContainerRect = viewerContainer.getBoundingClientRect();
            const newPosition = newRect.top - newContainerRect.top;
            
            console.log(`üìä Position apr√®s correction CSS journali√®re: ${Math.round(newPosition)}px`);
            
            if (newPosition < -50 || newPosition > 100) {
                // Correction manuelle du scroll
                const targetScrollTop = firstPage.offsetTop - 16;
                viewerContainer.scrollTop = Math.max(0, targetScrollTop);
                console.log(`üîß Scroll manuel journalier appliqu√©: ${viewerContainer.scrollTop}px`);
            }
            
            // Forcer la page courante √† 1
            dayCurrentPageNum = 1;
            updateDayActiveThumbnail(1);
            
            // Red√©marrer l'observer apr√®s correction
            if (window.dayPdfPageObserver) {
                window.dayPdfPageObserver.disconnect();
                setTimeout(() => {
                    setupDayPageVisibilityObserver();
                    console.log('‚úÖ Correction automatique journali√®re termin√©e - Page 1 active');
                }, 100);
            }
        }, 50);
    } else {
        console.log('‚úÖ Position journali√®re correcte - aucune correction n√©cessaire');
        // Juste s'assurer qu'on est √† la page 1
        viewerContainer.scrollTop = 0;
        dayCurrentPageNum = 1;
        updateDayActiveThumbnail(1);
    }
}

// Configurer les √©v√©nements d'annotation pour un canvas journalier
function setupDayAnnotationEvents(canvas, pageNum) {
    let isPageDrawing = false;
    let currentStroke = [];
    
    // Fonctions de dessin
    function startDrawing(e) {
        e.preventDefault();
        isPageDrawing = true;
        dayCurrentPageNum = pageNum;
        
        const coords = getCanvasCoordinates(e, canvas);
        currentStroke = [coords];
        
        // Configurer le contexte
        const ctx = canvas.getContext('2d');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalCompositeOperation = dayCurrentTool === 'eraser' ? 'destination-out' : 'source-over';
        ctx.lineWidth = dayCurrentLineWidth;
        ctx.strokeStyle = dayCurrentColor;
        
        if (dayCurrentTool === 'highlighter') {
            ctx.globalAlpha = 0.3;
        } else {
            ctx.globalAlpha = 1.0;
        }
        
        ctx.beginPath();
        ctx.moveTo(coords.x, coords.y);
    }
    
    function continueDrawing(e) {
        if (!isPageDrawing) return;
        e.preventDefault();
        
        const coords = getCanvasCoordinates(e, canvas);
        currentStroke.push(coords);
        
        const ctx = canvas.getContext('2d');
        ctx.lineTo(coords.x, coords.y);
        ctx.stroke();
    }
    
    function stopDrawing(e) {
        if (!isPageDrawing) return;
        e.preventDefault();
        
        isPageDrawing = false;
        
        // Sauvegarder l'annotation
        if (currentStroke.length > 1) {
            const annotation = {
                page: pageNum,
                tool: dayCurrentTool,
                color: dayCurrentColor,
                lineWidth: dayCurrentLineWidth,
                points: [...currentStroke]
            };
            
            dayAnnotations.push(annotation);
            console.log(`üìù Annotation journali√®re sauvegard√©e sur page ${pageNum}`);
        }
        
        currentStroke = [];
    }
    
    // √âv√©nements de souris
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', continueDrawing);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);
    
    // √âv√©nements tactiles
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', continueDrawing);
    canvas.addEventListener('touchend', stopDrawing);
}

// Configurer les outils d'annotation pour la vue journali√®re
function setupDayAnnotationTools() {
    console.log('üîß Configuration des outils d\'annotation journaliers...');
    
    // Outils de dessin
    document.querySelectorAll('#dayFileViewerModal [data-tool]').forEach(btn => {
        btn.addEventListener('click', () => {
            dayCurrentTool = btn.dataset.tool;
            document.querySelectorAll('#dayFileViewerModal [data-tool]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            console.log('üîß Outil journalier s√©lectionn√©:', dayCurrentTool);
        });
    });

    // Couleurs
    document.querySelectorAll('#dayFileViewerModal [data-color]').forEach(btn => {
        btn.addEventListener('click', () => {
            dayCurrentColor = btn.dataset.color;
            document.querySelectorAll('#dayFileViewerModal [data-color]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            console.log('üé® Couleur journali√®re s√©lectionn√©e:', dayCurrentColor);
        });
    });

    // Couleur personnalis√©e
    const colorPicker = document.getElementById('dayAnnotationColor');
    if (colorPicker) {
        colorPicker.addEventListener('change', (e) => {
            dayCurrentColor = e.target.value;
            document.querySelectorAll('#dayFileViewerModal [data-color]').forEach(b => b.classList.remove('active'));
            console.log('üé® Couleur journali√®re personnalis√©e:', dayCurrentColor);
        });
    }

    // √âpaisseur du trait
    const strokeWidth = document.getElementById('dayStrokeWidth');
    const strokeWidthValue = document.getElementById('dayStrokeWidthValue');
    if (strokeWidth && strokeWidthValue) {
        strokeWidth.addEventListener('input', (e) => {
            dayCurrentLineWidth = parseInt(e.target.value);
            strokeWidthValue.textContent = dayCurrentLineWidth;
            console.log('üìè √âpaisseur journali√®re:', dayCurrentLineWidth);
        });
    }
}

// Configurer les √©v√©nements des outils pour la vue journali√®re
function setupDayToolEvents() {
    console.log('üîß Configuration des √©v√©nements d\'outils journaliers...');
    
    // Bouton d'annulation
    const undoBtn = document.getElementById('dayUndoBtn');
    if (undoBtn) {
        undoBtn.addEventListener('click', undoDayLastAnnotation);
    }

    // Bouton de suppression
    const clearAllBtn = document.getElementById('dayClearAllBtn');
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', clearDayAllAnnotations);
    }
}

// Annuler la derni√®re annotation journali√®re
function undoDayLastAnnotation() {
    if (dayAnnotations.length > 0) {
        const lastAnnotation = dayAnnotations.pop();
        redrawDayAllAnnotations();
        console.log('‚Ü∂ Annotation journali√®re annul√©e');
    }
}

// Effacer toutes les annotations journali√®res
function clearDayAllAnnotations() {
    if (confirm('Voulez-vous vraiment effacer toutes les annotations ?')) {
        dayAnnotations = [];
        redrawDayAllAnnotations();
        console.log('üóëÔ∏è Toutes les annotations journali√®res effac√©es');
    }
}

// Redessiner toutes les annotations journali√®res
function redrawDayAllAnnotations() {
    if (!dayPdfDocument) return;
    
    // Effacer tous les canvas d'annotation
    for (let pageNum = 1; pageNum <= dayPdfDocument.numPages; pageNum++) {
        const canvas = document.getElementById(`day-annotation-canvas-${pageNum}`);
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    }
    
    // Redessiner toutes les annotations
    dayAnnotations.forEach(annotation => {
        const canvas = document.getElementById(`day-annotation-canvas-${annotation.page}`);
        if (canvas) {
            drawAnnotationOnCanvas(canvas.getContext('2d'), annotation);
        }
    });
}

// Charger les annotations depuis le serveur pour la vue journali√®re
async function loadDayAnnotations(fileId) {
    try {
        const response = await fetch(`/file-manager/api/annotations/${fileId}`);
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.annotations) {
                dayAnnotations = data.annotations;
                console.log(`üìù ${dayAnnotations.length} annotations journali√®res charg√©es`);
                // Redessiner les annotations
                setTimeout(() => redrawDayAllAnnotations(), 500);
            }
        }
    } catch (error) {
        console.log('‚ÑπÔ∏è Aucune annotation journali√®re existante:', error);
        dayAnnotations = [];
    }
}

// Sauvegarder les annotations journali√®res
async function saveDayAnnotations() {
    if (!dayCurrentFileId || dayAnnotations.length === 0) {
        console.log('üíæ Aucune annotation journali√®re √† sauvegarder');
        return;
    }

    try {
        const response = await fetch('/file-manager/api/save-annotations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_id: dayCurrentFileId,
                annotations: dayAnnotations
            })
        });

        if (response.ok) {
            console.log('üíæ Annotations journali√®res sauvegard√©es avec succ√®s');
            updateDaySaveStatus('Sauvegard√©', 'success');
        } else {
            throw new Error('Erreur de sauvegarde');
        }
    } catch (error) {
        console.error('‚ùå Erreur lors de la sauvegarde journali√®re:', error);
        updateDaySaveStatus('Erreur de sauvegarde', 'error');
    }
}

// Mettre √† jour le statut de sauvegarde journali√®re
function updateDaySaveStatus(message, type = 'info') {
    const saveStatus = document.getElementById('daySaveStatus');
    if (saveStatus) {
        const icon = type === 'success' ? 'check-circle' : 'info-circle';
        saveStatus.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;
        
        if (type === 'success') {
            setTimeout(() => {
                saveStatus.innerHTML = '<i class="fas fa-info-circle"></i> Sauvegarde √† la fermeture';
            }, 3000);
        }
    }
}

// Fermer le lecteur de fichier journalier
function closeDayFileViewer() {
    const modal = document.getElementById('dayFileViewerModal');
    modal.classList.remove('show', 'embedded');
    
    // Sauvegarder les annotations avant fermeture
    if (dayAnnotations.length > 0) {
        saveDayAnnotations();
    }
    
    // Nettoyer l'observer journalier
    if (window.dayPdfPageObserver) {
        window.dayPdfPageObserver.disconnect();
        window.dayPdfPageObserver = null;
    }
    
    // R√©initialiser les variables
    dayCurrentFileId = null;
    dayCurrentPageNum = 1;
    dayCurrentScale = 1.0;
    dayPdfDocument = null;
    dayAnnotations = [];
}

// Afficher une erreur journali√®re
function showDayError(message) {
    const container = document.getElementById('dayPdfPagesContainer');
    container.innerHTML = `<div class="error-message">${message}</div>`;
}

// === FONCTIONS DE DEBUG POUR LE LECTEUR PDF DU CALENDRIER ===
window.calendarPdfDebug = {
    // Diagnostiquer le probl√®me de scroll
    testScrollIssue: function() {
        console.log('üß™ Diagnostic du probl√®me de scroll du calendrier');
        const viewerContainer = document.getElementById('viewerContainer');
        const firstPage = document.getElementById('page-wrapper-1');
        
        if (!viewerContainer || !firstPage) {
            console.error('‚ùå √âl√©ments non trouv√©s');
            return;
        }
        
        const rect = firstPage.getBoundingClientRect();
        const containerRect = viewerContainer.getBoundingClientRect();
        const pagePosition = rect.top - containerRect.top;
        
        console.log(`üìä Position de la page 1: ${Math.round(pagePosition)}px`);
        console.log(`üìä Scroll actuel: ${viewerContainer.scrollTop}px`);
        console.log(`üìä Page actuelle: ${currentPageNum}`);
        console.log(`üìä Nombre total de pages: ${pdfDocument ? pdfDocument.numPages : 'PDF non charg√©'}`);
        
        if (pagePosition < -100 || pagePosition > viewerContainer.clientHeight) {
            console.warn('‚ö†Ô∏è La page 1 est mal positionn√©e - correction recommand√©e');
        } else {
            console.log('‚úÖ Position normale');
        }
    },
    
    // Forcer le retour √† la page 1
    goToFirst: function() {
        console.log('üîß Force le retour √† la page 1...');
        applyScrollFixToViewer();
    },
    
    // Correction automatique
    fixScrollIssue: function() {
        console.log('üõ†Ô∏è Application de la correction automatique...');
        applyScrollFixToViewer();
    },
    
    // Version journali√®re - diagnostiquer
    testDayScrollIssue: function() {
        console.log('üß™ Diagnostic du probl√®me de scroll journalier');
        const viewerContainer = document.getElementById('dayViewerContainer');
        const firstPage = document.getElementById('day-page-wrapper-1');
        
        if (!viewerContainer || !firstPage) {
            console.error('‚ùå √âl√©ments journaliers non trouv√©s');
            return;
        }
        
        const rect = firstPage.getBoundingClientRect();
        const containerRect = viewerContainer.getBoundingClientRect();
        const pagePosition = rect.top - containerRect.top;
        
        console.log(`üìä Position de la page 1 journali√®re: ${Math.round(pagePosition)}px`);
        console.log(`üìä Scroll actuel journalier: ${viewerContainer.scrollTop}px`);
        console.log(`üìä Page actuelle journali√®re: ${dayCurrentPageNum}`);
        console.log(`üìä Nombre total de pages journali√®res: ${dayPdfDocument ? dayPdfDocument.numPages : 'PDF non charg√©'}`);
        
        if (pagePosition < -100 || pagePosition > viewerContainer.clientHeight) {
            console.warn('‚ö†Ô∏è La page 1 journali√®re est mal positionn√©e - correction recommand√©e');
        } else {
            console.log('‚úÖ Position journali√®re normale');
        }
    },
    
    // Forcer le retour √† la page 1 journali√®re
    goToDayFirst: function() {
        console.log('üîß Force le retour √† la page 1 journali√®re...');
        applyDayScrollFixToViewer();
    },
    
    // Correction automatique journali√®re
    fixDayScrollIssue: function() {
        console.log('üõ†Ô∏è Application de la correction automatique journali√®re...');
        applyDayScrollFixToViewer();
    }
};

// === FONCTIONS UTILITAIRES POUR LE LECTEUR PDF UNIFI√â ===

// R√©cup√©rer l'ID de classe pour la vue journali√®re
function getDayViewSelectedClassId() {
    // Pour la vue journali√®re, utiliser la classe du modal
    const dayModalClassroom = document.getElementById('dayModalClassroom');
    if (dayModalClassroom && dayModalClassroom.value) {
        return dayModalClassroom.value;
    }
    // Fallback vers la classe globalement s√©lectionn√©e
    return selectedClassroomId;
}

// R√©cup√©rer les √©tudiants d'une classe
async function getStudentsForClass(classId) {
    if (!classId) {
        console.warn('‚ö†Ô∏è Aucune classe s√©lectionn√©e pour r√©cup√©rer les √©tudiants');
        return [];
    }
    
    try {
        console.log(`üë• R√©cup√©ration des √©tudiants pour la classe: ${classId}`);
        
        // Parser l'ID de classe (peut √™tre "classroom_4" ou "mixed_group_2" ou "4")
        let apiClassId = classId;
        if (typeof classId === 'string' && classId.includes('_')) {
            const parts = classId.split('_');
            apiClassId = parts[parts.length - 1]; // Prendre le dernier √©l√©ment (l'ID num√©rique)
        }
        
        const response = await fetch(`/planning/get-class-resources/${apiClassId}`);
        if (!response.ok) {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.success && data.students) {
            console.log(`‚úÖ ${data.students.length} √©tudiants r√©cup√©r√©s`);
            return data.students;
        } else {
            console.warn('‚ö†Ô∏è Aucun √©tudiant trouv√© pour cette classe');
            return [];
        }
    } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des √©tudiants:', error);
        return [];
    }
}

// Fermer le lecteur PDF unifi√©
function closePdfViewer() {
    if (window.currentPdfViewer) {
        window.currentPdfViewer.destroy();
        window.currentPdfViewer = null;
    }
    
    const container = document.getElementById('pdf-viewer-container');
    if (container) {
        container.style.display = 'none';
        container.innerHTML = '';
    }
    
    // Nettoyer aussi le conteneur journalier s'il existe
    const dayContainer = document.getElementById('pdf-viewer-container-day');
    if (dayContainer && dayContainer.parentNode) {
        dayContainer.parentNode.removeChild(dayContainer);
    }
    
    // Nettoyer aussi le conteneur principal s'il existe
    const mainContainer = document.getElementById('pdf-viewer-container-main');
    if (mainContainer && mainContainer.parentNode) {
        mainContainer.parentNode.removeChild(mainContainer);
    }
}

// Ajouter un gestionnaire de fermeture avec la touche Escape
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && window.currentPdfViewer) {
        closePdfViewer();
    }
});

console.log('üé® Fonctions de debug PDF du calendrier disponibles: window.calendarPdfDebug');
console.log('   - testScrollIssue() : Diagnostiquer le probl√®me de scroll');
console.log('   - goToFirst() : Forcer le retour √† la page 1');
console.log('   - fixScrollIssue() : Correction automatique');
console.log('   - testDayScrollIssue() : Diagnostiquer le probl√®me de scroll journalier');
console.log('   - goToDayFirst() : Forcer le retour √† la page 1 journali√®re');
console.log('   - fixDayScrollIssue() : Correction automatique journali√®re');

// Fonction pour afficher/masquer les options de r√©p√©tition des groupes (modal principal)
function toggleGroupRepeatOptions() {
    const groupSelect = document.getElementById('modalGroup');
    const repeatOptions = document.getElementById('groupRepeatOptions');
    
    if (groupSelect && repeatOptions) {
        const hasGroupSelected = groupSelect.value && groupSelect.value !== '';
        repeatOptions.style.display = hasGroupSelected ? 'block' : 'none';
        
        // R√©initialiser les boutons radio quand on cache les options
        if (!hasGroupSelected) {
            const noneOption = document.querySelector('input[name="groupRepeat"][value="none"]');
            if (noneOption) {
                noneOption.checked = true;
            }
        }
    }
}

// Fonction pour afficher/masquer les options de r√©p√©tition des groupes (modal jour)
function toggleDayGroupRepeatOptions() {
    const groupSelect = document.getElementById('dayModalGroup');
    const repeatOptions = document.getElementById('dayGroupRepeatOptions');
    
    if (groupSelect && repeatOptions) {
        const hasGroupSelected = groupSelect.value && groupSelect.value !== '';
        repeatOptions.style.display = hasGroupSelected ? 'block' : 'none';
        
        // R√©initialiser les boutons radio quand on cache les options
        if (!hasGroupSelected) {
            const noneOption = document.querySelector('input[name="dayGroupRepeat"][value="none"]');
            if (noneOption) {
                noneOption.checked = true;
            }
        }
    }
}

</script>
{% endblock %}
