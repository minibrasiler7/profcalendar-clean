{% extends "base.html" %}

{% block title %}{{ exercise.title }} - Mission{% endblock %}

{% block extra_css %}
<style>
/* ============================================================
   RPG MISSION SOLVING ‚Äî Step-by-step with immediate feedback
   ============================================================ */
body { background: linear-gradient(135deg, #0f0c29, #1a1a4e, #24243e) !important; min-height: 100vh; }

.rpg-solve-container { max-width: 800px; margin: 0 auto; padding: 1rem; }

/* ---- Top Bar ---- */
.rpg-topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0.75rem 1rem;
    background: rgba(255,255,255,0.08);
    border-radius: 14px;
    margin-bottom: 1rem;
    backdrop-filter: blur(8px);
}
.rpg-topbar-left { display: flex; align-items: center; gap: 0.75rem; }
.rpg-topbar-avatar {
    width: 44px; height: 44px; border-radius: 50%;
    border: 2px solid #f59e0b; overflow: hidden; flex-shrink: 0;
}
.rpg-topbar-avatar img { width: 100%; height: 100%; object-fit: contain; background: white; border-radius: 50%; }
.rpg-topbar-info { color: white; }
.rpg-topbar-info .name { font-weight: 700; font-size: 0.95rem; }
.rpg-topbar-info .level-xp { font-size: 0.75rem; opacity: 0.7; }
.rpg-topbar-right { display: flex; align-items: center; gap: 1rem; }
.rpg-topbar-xp, .rpg-topbar-gold {
    color: white; font-weight: 700; font-size: 0.85rem;
    display: flex; align-items: center; gap: 0.3rem;
}
.back-link {
    color: rgba(255,255,255,0.6); text-decoration: none;
    font-size: 0.8rem; display: inline-flex; align-items: center; gap: 0.3rem;
    margin-bottom: 0.5rem; transition: color 0.2s;
}
.back-link:hover { color: white; }

/* ---- Progress ---- */
.progress-section {
    background: rgba(255,255,255,0.06); border-radius: 12px;
    padding: 0.75rem 1rem; margin-bottom: 1rem;
}
.progress-label {
    display: flex; justify-content: space-between;
    color: rgba(255,255,255,0.8); font-size: 0.85rem; font-weight: 600; margin-bottom: 0.4rem;
}
.progress-bar-track {
    width: 100%; height: 10px; background: rgba(255,255,255,0.15);
    border-radius: 5px; overflow: hidden;
}
.progress-bar-fill {
    height: 100%; background: linear-gradient(90deg, #667eea, #764ba2);
    border-radius: 5px; transition: width 0.5s ease;
}

/* ---- Score tracker ---- */
.score-tracker {
    color: white; font-size: 0.85rem; font-weight: 700;
    display: flex; align-items: center; gap: 0.3rem;
}

/* ---- Question Card ---- */
.question-card {
    background: rgba(255,255,255,0.95); border-radius: 16px;
    padding: 1.5rem; margin-bottom: 1rem;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    animation: slideIn 0.4s ease;
    transition: all 0.3s;
}
@keyframes slideIn {
    from { opacity: 0; transform: translateY(30px) scale(0.97); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}
.question-card h3 {
    margin: 0 0 1rem; font-size: 1.1rem;
    display: flex; align-items: center; gap: 0.5rem; color: #1e1b4b;
}
.block-type-badge {
    display: inline-block; padding: 0.15rem 0.5rem; border-radius: 6px;
    font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
    background: #eef2ff; color: #667eea;
}
.question-card .question-text {
    font-size: 0.95rem; color: #374151; margin-bottom: 1rem; line-height: 1.6;
}
.question-points {
    font-size: 0.8rem; font-weight: 700; color: #f59e0b;
    display: flex; align-items: center; gap: 0.3rem;
}

/* ---- Feedback overlays on card ---- */
.question-card.feedback-correct {
    border: 3px solid #10b981;
    background: linear-gradient(135deg, #ecfdf5, #d1fae5);
    animation: correctPulse 0.6s ease;
}
.question-card.feedback-incorrect {
    border: 3px solid #ef4444;
    background: linear-gradient(135deg, #fef2f2, #fecaca);
    animation: incorrectShake 0.6s ease;
}
@keyframes correctPulse {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16,185,129,0.4); }
    30% { transform: scale(1.03); box-shadow: 0 0 30px 10px rgba(16,185,129,0.3); }
    60% { transform: scale(0.99); }
    100% { transform: scale(1); box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
}
@keyframes incorrectShake {
    0%, 100% { transform: translateX(0) rotate(0); }
    10% { transform: translateX(-10px) rotate(-1deg); }
    20% { transform: translateX(10px) rotate(1deg); }
    30% { transform: translateX(-10px) rotate(-1deg); }
    40% { transform: translateX(10px) rotate(1deg); }
    50% { transform: translateX(-6px) rotate(0); }
    60% { transform: translateX(6px) rotate(0); }
    70% { transform: translateX(-3px); }
    80% { transform: translateX(3px); }
}

.feedback-banner {
    display: none; align-items: center; gap: 0.75rem;
    padding: 0.75rem 1rem; border-radius: 10px;
    margin-top: 1rem; font-weight: 700; font-size: 0.95rem;
}
.feedback-banner.show { display: flex; animation: fadeInUp 0.4s cubic-bezier(0.34,1.56,0.64,1); }
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px) scale(0.9); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}
.feedback-correct-banner {
    background: #dcfce7; color: #166534; border: 2px solid #86efac;
}
.feedback-incorrect-banner {
    background: #fef2f2; color: #991b1b; border: 2px solid #fca5a5;
}
.feedback-icon { font-size: 1.5rem; }

/* ---- Screen flash ---- */
.screen-flash {
    position: fixed; inset: 0; pointer-events: none; z-index: 9998;
    animation: screenFlash 0.5s ease-out forwards;
}
.screen-flash.correct { background: radial-gradient(circle, rgba(16,185,129,0.4), transparent 70%); }
.screen-flash.incorrect { background: radial-gradient(circle, rgba(239,68,68,0.35), transparent 70%); }
@keyframes screenFlash {
    0% { opacity: 1; }
    100% { opacity: 0; }
}

/* ---- XP Popup floating ---- */
.xp-popup {
    position: fixed; z-index: 10000; pointer-events: none;
    font-size: 1.8rem; font-weight: 900; color: #f59e0b;
    text-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 0 20px rgba(245,158,11,0.5);
    animation: xpFloat 1.5s cubic-bezier(0.25,0.46,0.45,0.94) forwards;
}
@keyframes xpFloat {
    0% { opacity: 1; transform: translateY(0) scale(0.5); }
    20% { transform: translateY(-20px) scale(1.3); }
    100% { opacity: 0; transform: translateY(-120px) scale(0.8); }
}

/* ---- Combo text ---- */
.combo-popup {
    position: fixed; z-index: 10000; pointer-events: none;
    font-size: 2.5rem; font-weight: 900; color: white;
    text-shadow: 0 0 20px rgba(102,126,234,0.8), 0 0 40px rgba(102,126,234,0.4);
    left: 50%; top: 30%;
    animation: comboZoom 1s cubic-bezier(0.34,1.56,0.64,1) forwards;
}
@keyframes comboZoom {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3) rotate(-10deg); }
    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(3deg); }
    60% { transform: translate(-50%, -50%) scale(0.95) rotate(-1deg); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8) translateY(-30px); }
}

/* ---- Star burst ---- */
.star-burst {
    position: fixed; pointer-events: none; z-index: 9999;
    font-size: 1.5rem;
    animation: starExplode 1s ease-out forwards;
}
@keyframes starExplode {
    0% { opacity: 1; transform: translate(var(--dx, 0), var(--dy, 0)) scale(0.3) rotate(0deg); }
    50% { opacity: 1; transform: translate(calc(var(--dx, 0) * 3), calc(var(--dy, 0) * 3)) scale(1.2) rotate(180deg); }
    100% { opacity: 0; transform: translate(calc(var(--dx, 0) * 5), calc(var(--dy, 0) * 5)) scale(0.5) rotate(360deg); }
}

/* ---- Confetti ---- */
.confetti-container {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none; z-index: 9999; overflow: hidden;
}
.confetti-piece {
    position: absolute; width: 10px; height: 10px;
    animation: confettiFall 2.5s ease-in forwards;
}
@keyframes confettiFall {
    0% { transform: translateY(-10vh) rotate(0deg) scaleX(1); opacity: 1; }
    25% { transform: translateY(25vh) rotate(180deg) scaleX(-1); opacity: 1; }
    50% { transform: translateY(55vh) rotate(360deg) scaleX(1); opacity: 0.8; }
    100% { transform: translateY(110vh) rotate(720deg) scaleX(-1); opacity: 0; }
}

/* ---- Sad particles ---- */
.sad-particle {
    position: fixed; pointer-events: none; z-index: 9999;
}
.sad-particle.type-emoji {
    font-size: 2rem;
    animation: sadFloat 2s ease-out forwards;
}
.sad-particle.type-crack {
    width: 3px; height: 20px; background: #ef4444; border-radius: 2px;
    animation: crackFall 1s ease-in forwards;
}
@keyframes sadFloat {
    0% { opacity: 1; transform: translateY(0) scale(0.5) rotate(0deg); }
    30% { opacity: 1; transform: translateY(-40px) scale(1.3) rotate(10deg); }
    100% { opacity: 0; transform: translateY(-100px) scale(0.5) rotate(-20deg); }
}
@keyframes crackFall {
    0% { opacity: 1; transform: translateY(0) rotate(var(--rot, 0deg)); }
    100% { opacity: 0; transform: translateY(80px) rotate(calc(var(--rot, 0deg) + 90deg)); }
}

/* ---- Boom text (for wrong answer) ---- */
.boom-text {
    position: fixed; z-index: 10000; pointer-events: none;
    font-size: 3rem; font-weight: 900; color: #ef4444;
    text-shadow: 0 0 15px rgba(239,68,68,0.6);
    left: 50%; top: 35%;
    animation: boomPop 0.8s cubic-bezier(0.34,1.56,0.64,1) forwards;
}
@keyframes boomPop {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(3) rotate(-5deg); }
    30% { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(2deg); }
    60% { transform: translate(-50%, -50%) scale(1.1) rotate(-1deg); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.7) translateY(20px); }
}

/* ---- Results overlay enhancements ---- */
.results-overlay { backdrop-filter: blur(6px); }
.results-card {
    background: linear-gradient(135deg, #1e1b4b, #312e81);
    border-radius: 24px; padding: 2.5rem; max-width: 460px; width: 90%;
    text-align: center; color: white;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 80px rgba(102,126,234,0.2);
    animation: resultsAppear 0.6s cubic-bezier(0.34,1.56,0.64,1);
}
@keyframes resultsAppear {
    from { transform: scale(0.5) rotate(-3deg); opacity: 0; }
    to { transform: scale(1) rotate(0); opacity: 1; }
}

/* ---- QCM ---- */
.qcm-options { list-style: none; padding: 0; margin: 0; }
.qcm-option {
    padding: 0.85rem 1rem; border: 2px solid #e5e7eb; border-radius: 10px;
    margin-bottom: 0.5rem; cursor: pointer; transition: all 0.2s;
    display: flex; align-items: center; gap: 0.6rem; font-size: 0.95rem;
}
.qcm-option:hover { border-color: #667eea; background: #f5f3ff; }
.qcm-option.selected { border-color: #667eea; background: #eef2ff; }
.qcm-option.locked { pointer-events: none; opacity: 0.7; }
.qcm-radio {
    width: 20px; height: 20px; border: 2px solid #d1d5db; border-radius: 50%;
    flex-shrink: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.2s;
}
.qcm-option.selected .qcm-radio { border-color: #667eea; background: #667eea; }
.qcm-option.selected .qcm-radio::after {
    content: ''; width: 8px; height: 8px; background: white; border-radius: 50%;
}
.qcm-checkbox {
    width: 20px; height: 20px; border: 2px solid #d1d5db; border-radius: 4px;
    flex-shrink: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.2s;
}
.qcm-option.selected .qcm-checkbox { border-color: #667eea; background: #667eea; }
.qcm-option.selected .qcm-checkbox::after {
    content: '\f00c'; font-family: "Font Awesome 6 Free","Font Awesome 5 Free";
    font-weight: 900; font-size: 0.7rem; color: white;
}

/* ---- Answer Input ---- */
.answer-input {
    width: 100%; padding: 0.85rem; border: 2px solid #e5e7eb;
    border-radius: 10px; font-size: 1rem; font-family: inherit; transition: border-color 0.2s;
}
.answer-input:focus { outline: none; border-color: #667eea; }

/* ---- Fill Blank ---- */
.fill-blank-text { line-height: 2.8; font-size: 1rem; }
.blank-input {
    display: inline-block; width: 110px; border: none;
    border-bottom: 2px solid #667eea; padding: 0.2rem 0.3rem;
    font-size: 1rem; font-family: inherit; text-align: center;
    background: #eef2ff; border-radius: 4px 4px 0 0;
}

/* ---- Sorting ---- */
.sorting-list { list-style: none; padding: 0; margin: 0; }
.sorting-item {
    padding: 0.75rem 1rem; border: 2px solid #e5e7eb; border-radius: 10px;
    margin-bottom: 0.5rem; cursor: grab; display: flex; align-items: center;
    gap: 0.5rem; background: white; user-select: none; transition: all 0.2s;
}
.sorting-item:active { cursor: grabbing; }
.sorting-item.dragging { opacity: 0.5; border-style: dashed; }
.sorting-item i { color: #9ca3af; }

/* ---- Category zones ---- */
.categories-wrapper { display: flex; flex-direction: column; gap: 0.75rem; }
.category-zone {
    border: 2px dashed #d1d5db; border-radius: 12px;
    padding: 0.75rem 1rem; min-height: 60px; transition: all 0.2s; background: #fafafa;
}
.category-zone.drag-over { border-color: #667eea; background: #eef2ff; }
.category-zone h4 { margin: 0 0 0.5rem; font-size: 0.9rem; color: #4b5563; font-weight: 700; }
.category-zone .zone-items { display: flex; flex-wrap: wrap; gap: 0.3rem; }
.category-zone .sorting-item {
    display: inline-flex; padding: 0.4rem 0.75rem; font-size: 0.85rem;
    margin-bottom: 0; border-color: #667eea; background: #eef2ff;
}
.category-pool {
    margin-top: 0.75rem; padding: 0.75rem; border: 2px solid #e5e7eb;
    border-radius: 12px; background: white;
}
.category-pool h4 { margin: 0 0 0.5rem; font-size: 0.85rem; color: #6b7280; }
.category-pool .pool-items { display: flex; flex-wrap: wrap; gap: 0.4rem; }

/* ---- Image Interactive ---- */
.image-click-area {
    position: relative; display: inline-block; cursor: crosshair; max-width: 100%;
}
.image-click-area img { max-width: 100%; border-radius: 8px; display: block; }
.click-marker {
    position: absolute; width: 24px; height: 24px;
    background: #ef4444; border: 3px solid white; border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3); pointer-events: none;
    animation: markerPop 0.3s ease;
}
.click-marker .marker-label {
    position: absolute; top: -22px; left: 50%; transform: translateX(-50%);
    background: #1e1b4b; color: white; font-size: 0.65rem; font-weight: 700;
    padding: 1px 6px; border-radius: 4px; white-space: nowrap;
}
@keyframes markerPop {
    from { transform: translate(-50%,-50%) scale(0); }
    to { transform: translate(-50%,-50%) scale(1); }
}

/* ---- Graph ---- */
.graph-wrapper {
    border: 2px solid #e5e7eb; border-radius: 10px;
    overflow: hidden; text-align: center; background: white;
}

/* ---- Image undo button ---- */
.btn-undo-image {
    display: flex; align-items: center; justify-content: center; gap: 0.4rem;
    width: 100%; padding: 0.6rem; margin-top: 0.5rem;
    background: #667eea; color: white; border: none;
    border-radius: 8px; font-size: 0.9rem; font-weight: 600;
    cursor: pointer; font-family: inherit; transition: all 0.2s;
}
.btn-undo-image:hover { background: #5568d3; }
.btn-undo-image:disabled { background: #9ca3af; cursor: not-allowed; }

/* ---- Validate Button ---- */
.btn-validate {
    display: flex; align-items: center; justify-content: center; gap: 0.4rem;
    width: 100%; padding: 0.8rem; margin-top: 1rem;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white; border: none; border-radius: 10px;
    font-size: 1rem; font-weight: 700; cursor: pointer;
    font-family: inherit; transition: all 0.2s;
}
.btn-validate:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(102,126,234,0.4); }
.btn-validate:disabled { background: #9ca3af; cursor: not-allowed; transform: none; box-shadow: none; }
.btn-validate.btn-next-q {
    background: linear-gradient(135deg, #10b981, #059669);
}
.btn-validate.btn-finish {
    background: linear-gradient(135deg, #f59e0b, #d97706);
    font-size: 1.1rem;
}

/* ---- Results Overlay ---- */
.results-overlay {
    position: fixed; inset: 0; background: rgba(15,12,41,0.9);
    display: flex; align-items: center; justify-content: center;
    z-index: 9000; animation: fadeIn 0.3s ease;
}
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.results-card h2 { margin: 0; font-size: 1.4rem; color: #fbbf24; }
.results-avatar {
    width: 80px; height: 80px; margin: 1rem auto; border-radius: 50%;
    border: 3px solid #f59e0b; overflow: hidden;
}
.results-avatar img { width: 100%; height: 100%; object-fit: contain; background: white; border-radius: 50%; }
.results-score { font-size: 3.5rem; font-weight: 900; margin: 0.5rem 0; }
.results-score.good { color: #10b981; }
.results-score.medium { color: #f59e0b; }
.results-score.bad { color: #ef4444; }
.results-rewards { display: flex; justify-content: center; gap: 2.5rem; margin: 1.5rem 0; }
.reward-item { text-align: center; }
.reward-item .reward-value { font-size: 1.5rem; font-weight: 800; }
.reward-item .reward-label { font-size: 0.8rem; opacity: 0.6; }
.results-level { font-weight: 700; font-size: 1rem; color: #a78bfa; margin-bottom: 1.5rem; }
.btn-back-missions {
    display: inline-flex; align-items: center; gap: 0.4rem;
    padding: 0.7rem 1.5rem; background: linear-gradient(135deg, #667eea, #764ba2);
    color: white; border: none; border-radius: 10px;
    font-size: 1rem; font-weight: 700; cursor: pointer; text-decoration: none;
    font-family: inherit; transition: all 0.2s;
}
.btn-back-missions:hover { transform: translateY(-2px); }
.completed-banner {
    background: rgba(16,185,129,0.15); border: 2px solid rgba(16,185,129,0.4);
    border-radius: 12px; padding: 1rem 1.5rem; margin-bottom: 1rem;
    color: #a7f3d0; display: flex; align-items: center; gap: 0.75rem;
}
.results-detail {
    font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-top: 0.5rem;
}

@media (max-width: 600px) {
    .rpg-topbar { flex-direction: column; gap: 0.5rem; }
    .results-rewards { gap: 1.5rem; }
    .question-card { padding: 1rem; }
}
</style>
{% endblock %}

{% block extra_head %}
<!-- KaTeX for math rendering -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
{% endblock %}

{% block content %}
<div class="rpg-solve-container">
    <a href="{{ url_for('student_auth.missions') }}" class="back-link">
        <i class="fas fa-arrow-left"></i> Retour aux missions
    </a>

    <!-- Top Bar -->
    <div class="rpg-topbar">
        <div class="rpg-topbar-left">
            {% if rpg and rpg.avatar_class %}
            <div class="rpg-topbar-avatar">
                <img src="{{ url_for('static', filename=rpg.sprite_path) }}" alt="{{ rpg.avatar_class }}">
            </div>
            {% endif %}
            <div class="rpg-topbar-info">
                <div class="name">{{ student.first_name or 'Aventurier' }}</div>
                <div class="level-xp">Niv. {{ rpg.level }} ‚Äî {{ rpg.xp_total }} XP</div>
            </div>
        </div>
        <div class="rpg-topbar-right">
            <div class="score-tracker" id="score-tracker">
                <i class="fas fa-check-circle" style="color:#10b981;"></i> <span id="correct-count">0</span>/<span id="total-answered">0</span>
            </div>
            <div class="rpg-topbar-xp">
                <i class="fas fa-star" style="color:#f59e0b;"></i> <span id="xp-earned">0</span> XP
            </div>
        </div>
    </div>

    {% if already_completed %}
    <div class="completed-banner">
        <i class="fas fa-check-circle" style="font-size:1.3rem;color:#10b981;"></i>
        <span><strong>Mission d√©j√† compl√©t√©e !</strong> Score : {{ previous_attempt.score_percentage }}% ‚Äî {{ previous_attempt.xp_earned }} XP gagn√©s</span>
    </div>
    {% endif %}

    <!-- Progress -->
    <div class="progress-section">
        <div class="progress-label">
            <span id="progress-text">Question 1 / {{ exercise.blocks.count() }}</span>
            <span>{{ exercise.title }}</span>
        </div>
        <div class="progress-bar-track">
            <div class="progress-bar-fill" id="progress-fill" style="width: 0%;"></div>
        </div>
    </div>

    <!-- Questions -->
    <form id="exercise-form">
    {% set blocks_list = exercise.blocks.order_by('position').all() %}
    {% for block in blocks_list %}
    <div class="question-card" id="question-{{ block.id }}"
         data-block-id="{{ block.id }}" data-index="{{ loop.index0 }}"
         data-block-type="{{ block.block_type }}"
         style="{{ '' if loop.index0 == 0 else 'display:none;' }}">

        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
            <h3>
                <span class="block-type-badge">
                    {% if block.block_type == 'qcm' %}QCM
                    {% elif block.block_type == 'short_answer' %}R√©ponse
                    {% elif block.block_type == 'fill_blank' %}Trou
                    {% elif block.block_type == 'sorting' %}Tri
                    {% elif block.block_type == 'image_position' %}Image
                    {% elif block.block_type == 'graph' %}Graphique
                    {% endif %}
                </span>
                {{ block.title or 'Question ' ~ loop.index }}
            </h3>
            <div class="question-points"><i class="fas fa-star"></i> {{ block.points }} XP</div>
        </div>

        {% set c = block.config_json %}

        {% if block.block_type == 'qcm' %}
            {% if c.question %}<p class="question-text">{{ c.question }}</p>{% endif %}
            <ul class="qcm-options" data-block="{{ block.id }}" data-multiple="{{ 'true' if c.multiple_answers else 'false' }}">
                {% for opt in c.options %}
                <li class="qcm-option" data-index="{{ loop.index0 }}" onclick="selectQCM(this)">
                    <div class="{{ 'qcm-checkbox' if c.multiple_answers else 'qcm-radio' }}"></div>
                    <span>{{ opt.text }}</span>
                </li>
                {% endfor %}
            </ul>

        {% elif block.block_type == 'short_answer' %}
            {% if c.question %}<p class="question-text">{{ c.question }}</p>{% endif %}
            <input class="answer-input" type="{{ 'number' if c.answer_type == 'number' else 'text' }}"
                data-block="{{ block.id }}" placeholder="Ta r√©ponse..."
                {{ 'step=any' if c.answer_type == 'number' else '' }}
                {{ 'disabled' if already_completed }}>

        {% elif block.block_type == 'fill_blank' %}
            <div class="fill-blank-text" id="fill-blank-{{ block.id }}"></div>
            <script>
                (function() {
                    const template = {{ c.text_template|tojson }};
                    let blankIdx = 0;
                    const html = template.replace(/\{([^}]+)\}/g, function() {
                        const i = blankIdx++;
                        return '<input class="blank-input" type="text" data-block="{{ block.id }}" data-blank="' + i + '" placeholder="..." {{ "disabled" if already_completed }}>';
                    });
                    document.getElementById('fill-blank-{{ block.id }}').innerHTML = html;
                })();
            </script>

        {% elif block.block_type == 'sorting' %}
            {% if c.mode == 'order' %}
                <p class="question-text" style="color:#6b7280;">Remets ces √©l√©ments dans le bon ordre :</p>
                <ul class="sorting-list" id="sorting-{{ block.id }}" data-block="{{ block.id }}" data-mode="order">
                    {# Les items seront m√©lang√©s par JavaScript #}
                    {% for item in c['items'] %}
                    {% if item %}
                    <li class="sorting-item" draggable="true" data-original-index="{{ loop.index0 }}" data-text="{{ item }}">
                        <i class="fas fa-grip-vertical"></i> <span class="item-text">{{ item }}</span>
                    </li>
                    {% endif %}
                    {% endfor %}
                </ul>
            {% else %}
                <p class="question-text" style="color:#6b7280;">Classe ces √©l√©ments dans les bonnes cat√©gories :</p>
                <div class="categories-wrapper" id="categories-{{ block.id }}" data-block="{{ block.id }}" data-mode="categories">
                    {% for cat in c.categories %}
                    <div class="category-zone" data-category="{{ loop.index0 }}"
                         ondragover="catDragOver(event)" ondragleave="catDragLeave(event)" ondrop="catDrop(event, '{{ block.id }}')">
                        <h4><i class="fas fa-folder-open"></i> {{ cat.name }}</h4>
                        <div class="zone-items"></div>
                    </div>
                    {% endfor %}
                </div>
                <div class="category-pool" id="pool-{{ block.id }}">
                    <h4><i class="fas fa-hand-pointer"></i> √âl√©ments √† classer :</h4>
                    <div class="pool-items">
                        {# Les items seront m√©lang√©s par JavaScript #}
                        {% for item in c['items'] %}
                        {% if item %}
                        <div class="sorting-item" draggable="true" data-item-index="{{ loop.index0 }}"
                             data-block-id="{{ block.id }}" data-text="{{ item }}"
                             ondragstart="catDragStart(event)">
                            <i class="fas fa-grip-vertical"></i> <span class="item-text">{{ item }}</span>
                        </div>
                        {% endif %}
                        {% endfor %}
                    </div>
                </div>
            {% endif %}

        {% elif block.block_type == 'image_position' %}
            {% if c.image_file_id or c.image_url %}
            <div class="image-zone-prompt" id="zone-prompt-{{ block.id }}" style="text-align:center;margin-bottom:1rem;">
                <p style="color:#6b7280;font-size:0.85rem;margin:0 0 0.3rem;">Clique sur la zone :</p>
                <div style="font-size:1.6rem;font-weight:900;color:#667eea;" id="zone-current-label-{{ block.id }}">
                    {{ c.zones[0].label if c.zones else '' }}
                </div>
                <p style="color:#9ca3af;font-size:0.8rem;margin:0.3rem 0 0;" id="zone-counter-{{ block.id }}">
                    Zone 1 / {{ c.zones|length }}
                </p>
            </div>
            <div class="image-click-area" id="img-click-{{ block.id }}" data-block="{{ block.id }}"
                 data-expected="{{ c.zones|length }}"
                 data-zones='{{ c.zones|tojson }}'
                 onclick="handleImageClick(event, '{{ block.id }}')">
                {% if c.image_file_id %}
                <img src="{{ url_for('exercises.exercise_block_image', file_id=c.image_file_id) }}" alt="Image">
                {% elif c.image_url %}
                <img src="{{ c.image_url }}" alt="Image">
                {% endif %}
            </div>
            {% if not already_completed %}
            <button type="button" class="btn-undo-image" id="btn-undo-{{ block.id }}" style="display:none;margin-top:0.5rem;" onclick="undoLastClick('{{ block.id }}')">
                <i class="fas fa-undo"></i> Annuler le dernier clic
            </button>
            {% endif %}
            {% else %}
            <p style="color:#ef4444;">Image non disponible.</p>
            {% endif %}

        {% elif block.block_type == 'graph' %}
            {% if c.question %}<p class="question-text">{{ c.question }}</p>{% endif %}
            {% set ca = c.get('correct_answer', {}) %}
            {% if c.question_type == 'draw_quadratic' %}
                {% if not c.question %}
                <p class="question-text" style="font-size:1.1rem;font-weight:700;color:#1e1b4b;">
                    Trace la courbe : <span style="font-family:serif;font-style:italic;">f(x) =
                    {% if ca.a is defined and ca.a is not none %}
                        {% if ca.a != 1 and ca.a != -1 %}{{ ca.a }}{% elif ca.a == -1 %}-{% endif %}x¬≤
                    {% endif %}
                    {% if ca.b is defined and ca.b is not none and ca.b != 0 %}
                        {% if ca.b > 0 %} + {{ ca.b }}x{% else %} - {{ (-ca.b)|round(2) }}x{% endif %}
                    {% endif %}
                    {% if ca.c is defined and ca.c is not none and ca.c != 0 %}
                        {% if ca.c > 0 %} + {{ ca.c }}{% else %} - {{ (-ca.c)|round(2) }}{% endif %}
                    {% endif %}
                    </span>
                </p>
                {% endif %}
                <p class="question-text" style="color:#6b7280;">
                    D√©place les <strong>3 points</strong> pour tracer la courbe.
                </p>
            {% elif c.question_type == 'find_expression' %}
                <p class="question-text" style="font-size:1.1rem;font-weight:700;color:#1e1b4b;">
                    Trouve l'expression de la fonction repr√©sent√©e sur le graphique.
                </p>
                {% set ft = c.get('find_type', 'linear') %}
                <div class="find-expression-inputs" data-find-type="{{ ft }}" style="margin:1rem 0;padding:1rem;background:#f0f4ff;border-radius:12px;border:2px solid #c7d2fe;">
                    <p style="font-weight:600;color:#4338ca;margin-bottom:0.8rem;">
                        {% if ft == 'quadratic' %}
                            f(x) = <strong>a</strong>x¬≤ + <strong>b</strong>x + <strong>c</strong>
                        {% else %}
                            f(x) = <strong>a</strong>x + <strong>b</strong>
                        {% endif %}
                    </p>
                    <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center;">
                        <label style="font-weight:500;">a = <input type="number" step="any" class="find-coeff" data-coeff="a" style="width:70px;padding:0.4rem;border:2px solid #a5b4fc;border-radius:8px;font-size:1rem;text-align:center;" /></label>
                        <label style="font-weight:500;">b = <input type="number" step="any" class="find-coeff" data-coeff="b" style="width:70px;padding:0.4rem;border:2px solid #a5b4fc;border-radius:8px;font-size:1rem;text-align:center;" /></label>
                        {% if ft == 'quadratic' %}
                        <label style="font-weight:500;">c = <input type="number" step="any" class="find-coeff" data-coeff="c" style="width:70px;padding:0.4rem;border:2px solid #a5b4fc;border-radius:8px;font-size:1rem;text-align:center;" /></label>
                        {% endif %}
                    </div>
                </div>
            {% else %}
                {% if not c.question %}
                <p class="question-text" style="font-size:1.1rem;font-weight:700;color:#1e1b4b;">
                    Trace la droite : <span style="font-family:serif;font-style:italic;">f(x) =
                    {% if ca.a is defined and ca.a is not none %}
                        {% if ca.a != 1 and ca.a != -1 %}{{ ca.a }}{% elif ca.a == -1 %}-{% endif %}x
                    {% endif %}
                    {% if ca.b is defined and ca.b is not none and ca.b != 0 %}
                        {% if ca.b > 0 %} + {{ ca.b }}{% else %} - {{ (-ca.b)|round(2) }}{% endif %}
                    {% endif %}
                    </span>
                </p>
                {% endif %}
                <p class="question-text" style="color:#6b7280;">
                    D√©place les <strong>2 points</strong> pour tracer la droite.
                </p>
            {% endif %}
            <div class="graph-wrapper" style="position:relative;display:inline-block;width:100%;">
                <canvas id="graph-{{ block.id }}" width="600" height="500" style="display:block;width:100%;"></canvas>
            </div>
        {% endif %}

        <!-- Feedback banner (hidden initially) -->
        <div class="feedback-banner feedback-correct-banner" id="feedback-correct-{{ block.id }}">
            <span class="feedback-icon">üéâ</span> <span>Bravo ! Bonne r√©ponse !</span>
        </div>
        <div class="feedback-banner feedback-incorrect-banner" id="feedback-incorrect-{{ block.id }}">
            <span class="feedback-icon">üòî</span>
            <div>
                <span>Pas tout √† fait... Essaie encore la prochaine fois !</span>
                <div id="correct-answer-{{ block.id }}" style="margin-top:0.4rem;font-size:0.85rem;font-weight:600;color:#166534;background:#dcfce7;padding:0.4rem 0.6rem;border-radius:6px;display:none;">
                    <i class="fas fa-check-circle"></i> <span class="correct-text"></span>
                </div>
            </div>
        </div>

        <!-- Validate button (per question) -->
        {% if not already_completed %}
        <button type="button" class="btn-validate" id="btn-validate-{{ block.id }}" onclick="validateCurrentQuestion()">
            <i class="fas fa-check"></i> Valider ma r√©ponse
        </button>
        {% endif %}
    </div>
    {% endfor %}
    </form>
</div>

<!-- Confetti container -->
<div class="confetti-container" id="confetti-container"></div>

<!-- Results overlay (hidden) -->
<div class="results-overlay" id="results-overlay" style="display:none;">
    <div class="results-card">
        <h2><i class="fas fa-trophy"></i> Mission termin√©e !</h2>
        {% if rpg and rpg.avatar_class %}
        <div class="results-avatar">
            <img src="{{ url_for('static', filename=rpg.sprite_path) }}" alt="{{ rpg.avatar_class }}">
        </div>
        {% endif %}
        <div class="results-score" id="results-score"></div>
        <div class="results-detail" id="results-detail"></div>
        <div class="results-rewards">
            <div class="reward-item">
                <div class="reward-value" style="color:#f59e0b;" id="results-xp">0</div>
                <div class="reward-label">XP gagn√©s</div>
            </div>
            <div class="reward-item">
                <div class="reward-value" style="color:#fbbf24;" id="results-gold">0</div>
                <div class="reward-label">Or gagn√©</div>
            </div>
        </div>
        <div id="results-item" style="display:none;margin-top:1rem;padding:0.8rem;background:linear-gradient(135deg,#f0f4ff,#eef2ff);border-radius:12px;border:2px solid #c7d2fe;text-align:center;">
            <p style="font-weight:700;color:#4338ca;margin:0 0 0.3rem;font-size:0.9rem;">
                <i class="fas fa-gift"></i> Objet trouv√© !
            </p>
            <div id="results-item-icon" style="width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;margin:0 auto 0.3rem;color:white;font-size:1.2rem;"></div>
            <p id="results-item-name" style="font-weight:800;margin:0;font-size:0.95rem;"></p>
            <p id="results-item-rarity" style="font-weight:700;font-size:0.7rem;text-transform:uppercase;letter-spacing:0.5px;margin:0.2rem 0 0;"></p>
        </div>
        <p class="results-level" id="results-level"></p>
        <a href="{{ url_for('student_auth.missions') }}" class="btn-back-missions">
            <i class="fas fa-arrow-left"></i> Retour aux missions
        </a>
    </div>
</div>

<script>
// ============================================================
// State
// ============================================================
const totalQuestions = {{ blocks_list|length }};
let currentQuestion = 0;
let answeredBlocks = {};  // blockId -> {is_correct, points_earned}
let totalCorrect = 0;
let totalXPEarned = 0;
let questionLocked = false;  // true after validating current question

const allCards = document.querySelectorAll('.question-card');

// ============================================================
// Shuffle sorting items on load
// ============================================================
function shuffleChildren(parent) {
    const children = [...parent.children];
    for (let i = children.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        parent.appendChild(children[j]);
        [children[i], children[j]] = [children[j], children[i]];
    }
}

document.querySelectorAll('.sorting-list[data-mode="order"]').forEach(list => {
    shuffleChildren(list);
});

// Shuffle category pool items
document.querySelectorAll('.category-pool .pool-items').forEach(pool => {
    shuffleChildren(pool);
});

// ============================================================
// Show question
// ============================================================
function showQuestion(idx) {
    allCards.forEach((card, i) => {
        card.style.display = i === idx ? '' : 'none';
    });
    currentQuestion = idx;
    questionLocked = false;

    document.getElementById('progress-text').textContent = `Question ${idx + 1} / ${totalQuestions}`;
    document.getElementById('progress-fill').style.width = ((idx + 1) / totalQuestions * 100) + '%';

    // Init graph if needed
    const card = allCards[idx];
    const blockId = card.dataset.blockId;
    if (card.dataset.blockType === 'graph' && graphConfigs[blockId] && !graphStates[blockId]) {
        initInteractiveGraph(blockId, graphConfigs[blockId]);
    }
}

// ============================================================
// Validate current question ‚Äî sends to server for grading
// ============================================================
async function validateCurrentQuestion() {
    if (questionLocked) return;

    const card = allCards[currentQuestion];
    const blockId = card.dataset.blockId;
    const answer = collectAnswer(card, blockId);

    // Check if answered
    if (!hasAnswer(card, blockId, answer)) {
        alert('Tu dois r√©pondre √† la question avant de valider !');
        return;
    }

    const btn = document.getElementById('btn-validate-' + blockId);
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> V√©rification...';

    try {
        const res = await fetch(`/student/missions/{{ exercise.id }}/check-block`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ block_id: parseInt(blockId), answer }),
        });
        const data = await res.json();

        if (data.success) {
            questionLocked = true;
            answeredBlocks[blockId] = { is_correct: data.is_correct, points_earned: data.points_earned };

            // Update counters
            totalCorrect += data.is_correct ? 1 : 0;
            totalXPEarned += data.points_earned;
            document.getElementById('correct-count').textContent = totalCorrect;
            document.getElementById('total-answered').textContent = Object.keys(answeredBlocks).length;
            document.getElementById('xp-earned').textContent = totalXPEarned;

            // Show feedback
            showFeedback(card, blockId, data.is_correct, data.points_earned, data.max_points, data.correct_answer);

            // Lock inputs
            lockQuestion(card);

            // Show next button or submit
            const isLast = currentQuestion === totalQuestions - 1;
            btn.disabled = false;
            if (isLast) {
                btn.className = 'btn-validate btn-finish';
                btn.innerHTML = '<i class="fas fa-flag-checkered"></i> Terminer la mission';
                btn.onclick = submitExercise;
            } else {
                btn.className = 'btn-validate btn-next-q';
                btn.innerHTML = 'Question suivante <i class="fas fa-arrow-right"></i>';
                btn.onclick = () => showQuestion(currentQuestion + 1);
            }
        }
    } catch(e) {
        btn.disabled = false;
        btn.innerHTML = '<i class="fas fa-check"></i> Valider ma r√©ponse';
        alert('Erreur de connexion');
    }
}

// ============================================================
// Check if a question has been answered
// ============================================================
function hasAnswer(card, blockId, answer) {
    const type = card.dataset.blockType;
    if (type === 'qcm') return (answer.selected || []).length > 0;
    if (type === 'short_answer') return (answer.value || '').trim().length > 0;
    if (type === 'fill_blank') return (answer.blanks || []).some(b => b.trim().length > 0);
    if (type === 'sorting') {
        if (answer.categories) {
            const totalItems = Object.values(answer.categories).flat().length;
            return totalItems > 0;
        }
        return true;  // order mode always has an answer
    }
    if (type === 'image_position') return (imageClicks[blockId] || []).length > 0;
    if (type === 'graph') return !!graphStates[blockId];
    return true;
}

// ============================================================
// Combo streak tracking
// ============================================================
let comboStreak = 0;

// ============================================================
// Show feedback animation ‚Äî full gaming experience
// ============================================================
function showFeedback(card, blockId, isCorrect, points, maxPoints, correctAnswer) {
    // Screen flash
    const flash = document.createElement('div');
    flash.className = 'screen-flash ' + (isCorrect ? 'correct' : 'incorrect');
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 600);

    if (isCorrect) {
        comboStreak++;
        card.classList.add('feedback-correct');
        document.getElementById('feedback-correct-' + blockId).classList.add('show');

        // Confetti burst
        spawnConfetti();

        // Star burst from card center
        spawnStarBurst(card);

        // XP floating popup
        spawnXPPopup(card, points);

        // Combo popup if streak
        if (comboStreak >= 2) {
            spawnComboPopup(comboStreak);
        }
    } else {
        comboStreak = 0;
        card.classList.add('feedback-incorrect');
        document.getElementById('feedback-incorrect-' + blockId).classList.add('show');

        // Show correct answer
        if (correctAnswer) {
            const caDiv = document.getElementById('correct-answer-' + blockId);
            if (caDiv) {
                caDiv.querySelector('.correct-text').textContent = 'Bonne r√©ponse : ' + correctAnswer;
                caDiv.style.display = 'block';
            }
        }

        // For image_position, show correct zones
        const cardType = card.dataset.blockType;
        if (cardType === 'image_position') {
            const zonesStr = document.getElementById('img-click-' + blockId)?.dataset.zones;
            if (zonesStr) {
                const zones = JSON.parse(zonesStr);
                drawCorrectZones(blockId, zones);
            }
        }

        // For graph, draw the correct line/curve in green
        if (cardType === 'graph' && graphStates[blockId]) {
            drawCorrectCurveOnGraph(blockId);
        }

        // Sad particles + cracks
        spawnSadParticles(card);

        // Boom text
        spawnBoomText();

        // Screen shake
        document.body.style.animation = 'none';
        document.body.offsetHeight; // force reflow
        document.body.style.animation = 'screenShakeBody 0.4s ease';
        setTimeout(() => { document.body.style.animation = ''; }, 500);
    }
}

// ============================================================
// Confetti ‚Äî enhanced with ribbons
// ============================================================
function spawnConfetti() {
    const container = document.getElementById('confetti-container');
    const confColors = ['#10b981', '#f59e0b', '#667eea', '#ec4899', '#8b5cf6', '#06b6d4', '#fbbf24', '#34d399'];
    const shapes = ['circle', 'square', 'ribbon'];
    for (let i = 0; i < 60; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        piece.style.left = Math.random() * 100 + '%';
        piece.style.background = confColors[Math.floor(Math.random() * confColors.length)];
        piece.style.animationDelay = Math.random() * 0.7 + 's';
        piece.style.animationDuration = (2 + Math.random() * 1.5) + 's';
        if (shape === 'ribbon') {
            piece.style.width = (3 + Math.random() * 4) + 'px';
            piece.style.height = (15 + Math.random() * 15) + 'px';
            piece.style.borderRadius = '2px';
        } else if (shape === 'circle') {
            const size = (6 + Math.random() * 8) + 'px';
            piece.style.width = size; piece.style.height = size;
            piece.style.borderRadius = '50%';
        } else {
            const size = (6 + Math.random() * 8) + 'px';
            piece.style.width = size; piece.style.height = size;
            piece.style.borderRadius = '2px';
        }
        piece.style.transform = `rotate(${Math.random() * 360}deg)`;
        container.appendChild(piece);
    }
    setTimeout(() => { container.innerHTML = ''; }, 4000);
}

// ============================================================
// Star burst from card center
// ============================================================
function spawnStarBurst(card) {
    const rect = card.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    const stars = ['‚≠ê', '‚ú®', 'üåü', 'üí´'];
    for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const s = document.createElement('div');
        s.className = 'star-burst';
        s.textContent = stars[Math.floor(Math.random() * stars.length)];
        s.style.left = cx + 'px';
        s.style.top = cy + 'px';
        s.style.setProperty('--dx', Math.cos(angle) * 30 + 'px');
        s.style.setProperty('--dy', Math.sin(angle) * 30 + 'px');
        document.body.appendChild(s);
        setTimeout(() => s.remove(), 1200);
    }
}

// ============================================================
// XP floating popup
// ============================================================
function spawnXPPopup(card, points) {
    const rect = card.getBoundingClientRect();
    const popup = document.createElement('div');
    popup.className = 'xp-popup';
    popup.textContent = `+${points} XP`;
    popup.style.left = (rect.left + rect.width / 2 - 50) + 'px';
    popup.style.top = (rect.top + 20) + 'px';
    document.body.appendChild(popup);
    setTimeout(() => popup.remove(), 1600);
}

// ============================================================
// Combo popup
// ============================================================
function spawnComboPopup(streak) {
    const popup = document.createElement('div');
    popup.className = 'combo-popup';
    const labels = { 2: 'DOUBLE !', 3: 'TRIPLE !', 4: 'INCROYABLE !', 5: 'L√âGENDAIRE !' };
    popup.textContent = labels[Math.min(streak, 5)] || `x${streak} COMBO !`;
    document.body.appendChild(popup);
    setTimeout(() => popup.remove(), 1200);
}

// ============================================================
// Sad particles ‚Äî enhanced with cracks
// ============================================================
function spawnSadParticles(card) {
    const rect = card.getBoundingClientRect();
    const emojis = ['üòî', 'üíî', 'üò¢', 'üòì', 'ü•∫'];
    for (let i = 0; i < 6; i++) {
        const p = document.createElement('div');
        p.className = 'sad-particle type-emoji';
        p.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        p.style.left = (rect.left + Math.random() * rect.width) + 'px';
        p.style.top = (rect.top + rect.height * 0.2 + Math.random() * rect.height * 0.5) + 'px';
        p.style.animationDelay = (Math.random() * 0.3) + 's';
        document.body.appendChild(p);
        setTimeout(() => p.remove(), 2200);
    }
    // Crack fragments
    for (let i = 0; i < 8; i++) {
        const c = document.createElement('div');
        c.className = 'sad-particle type-crack';
        c.style.left = (rect.left + rect.width * 0.3 + Math.random() * rect.width * 0.4) + 'px';
        c.style.top = (rect.top + rect.height / 2) + 'px';
        c.style.setProperty('--rot', (Math.random() * 360) + 'deg');
        c.style.animationDelay = (Math.random() * 0.2) + 's';
        document.body.appendChild(c);
        setTimeout(() => c.remove(), 1200);
    }
}

// ============================================================
// Boom text for wrong answer
// ============================================================
function spawnBoomText() {
    const texts = ['RAT√â !', 'OUPS !', 'DOMMAGE !', 'PRESQUE !'];
    const boom = document.createElement('div');
    boom.className = 'boom-text';
    boom.textContent = texts[Math.floor(Math.random() * texts.length)];
    document.body.appendChild(boom);
    setTimeout(() => boom.remove(), 1000);
}

// Screen shake keyframes (added inline for body)
const shakeStyle = document.createElement('style');
shakeStyle.textContent = `
@keyframes screenShakeBody {
    0%, 100% { transform: translate(0); }
    10% { transform: translate(-4px, 2px); }
    20% { transform: translate(4px, -2px); }
    30% { transform: translate(-3px, 3px); }
    40% { transform: translate(3px, -1px); }
    50% { transform: translate(-2px, 1px); }
}`;
document.head.appendChild(shakeStyle);

// ============================================================
// Lock question inputs after answering
// ============================================================
function lockQuestion(card) {
    card.querySelectorAll('input, select, textarea').forEach(el => el.disabled = true);
    card.querySelectorAll('.qcm-option').forEach(el => el.classList.add('locked'));
    card.querySelectorAll('.sorting-item').forEach(el => el.setAttribute('draggable', 'false'));
}

// ============================================================
// Collect answer from a question card
// ============================================================
function collectAnswer(card, blockId) {
    const type = card.dataset.blockType;

    if (type === 'qcm') {
        const selected = [...card.querySelectorAll('.qcm-option.selected')].map(o => parseInt(o.dataset.index));
        return { selected };
    }
    if (type === 'short_answer') {
        const input = card.querySelector('.answer-input');
        return { value: input ? input.value : '' };
    }
    if (type === 'fill_blank') {
        const blanks = [...card.querySelectorAll('.blank-input')].map(i => i.value);
        return { blanks };
    }
    if (type === 'sorting') {
        const sortingList = card.querySelector('.sorting-list[data-mode="order"]');
        if (sortingList) {
            return { order: [...sortingList.children].map(li => parseInt(li.dataset.originalIndex)) };
        }
        const catWrapper = card.querySelector('.categories-wrapper');
        if (catWrapper) {
            const categories = {};
            catWrapper.querySelectorAll('.category-zone').forEach(zone => {
                const catIdx = zone.dataset.category;
                categories[catIdx] = [...zone.querySelectorAll('.sorting-item')].map(el => parseInt(el.dataset.itemIndex));
            });
            return { categories };
        }
    }
    if (type === 'image_position') {
        return { clicks: imageClicks[blockId] || [] };
    }
    if (type === 'graph') {
        // Check if it's find_expression (coefficient inputs)
        const findInputs = card.querySelector('.find-expression-inputs');
        if (findInputs) {
            const coeffs = {};
            findInputs.querySelectorAll('.find-coeff').forEach(inp => {
                coeffs[inp.dataset.coeff] = parseFloat(inp.value) || 0;
            });
            return { coefficients: coeffs };
        }
        if (graphStates[blockId]) {
            return { points: graphStates[blockId].points };
        }
    }
    return {};
}

// ============================================================
// Submit entire exercise (final)
// ============================================================
async function submitExercise() {
    const btn = allCards[currentQuestion].querySelector('.btn-validate, .btn-finish');
    if (btn) { btn.disabled = true; btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Envoi...'; }

    // Collect all answers
    const answers = {};
    allCards.forEach(card => {
        const blockId = card.dataset.blockId;
        answers[blockId] = collectAnswer(card, blockId);
    });

    try {
        const res = await fetch(`/student/missions/{{ exercise.id }}/submit`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answers }),
        });
        const data = await res.json();

        if (data.success) {
            const pct = data.percentage;
            const scoreEl = document.getElementById('results-score');
            scoreEl.textContent = pct + '%';
            scoreEl.className = 'results-score ' + (pct >= 80 ? 'good' : pct >= 50 ? 'medium' : 'bad');

            document.getElementById('results-detail').textContent =
                `${data.score}/${data.max_score} points ‚Äî ${totalCorrect}/${totalQuestions} bonnes r√©ponses`;
            document.getElementById('results-xp').textContent = '+' + data.xp_earned;
            document.getElementById('results-gold').textContent = '+' + data.gold_earned;
            document.getElementById('results-level').textContent = 'Niveau ' + data.new_level;

            // Show item won
            if (data.item_won) {
                const itemDiv = document.getElementById('results-item');
                itemDiv.style.display = 'block';
                document.getElementById('results-item-icon').style.background = data.item_won.color;
                document.getElementById('results-item-icon').innerHTML = `<i class="fas fa-${data.item_won.icon}"></i>`;
                document.getElementById('results-item-name').textContent = data.item_won.name;
                const rarityEl = document.getElementById('results-item-rarity');
                rarityEl.textContent = data.item_won.rarity_label;
                rarityEl.style.color = data.item_won.rarity_color;
            }

            document.getElementById('results-overlay').style.display = 'flex';
            // Big celebration for good scores
            if (pct >= 80) {
                spawnConfetti();
                setTimeout(spawnConfetti, 800);
                setTimeout(spawnConfetti, 1600);
            } else if (pct >= 50) {
                spawnConfetti();
            }
        } else {
            alert(data.message || 'Erreur');
            if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-flag-checkered"></i> Terminer la mission'; }
        }
    } catch(e) {
        alert('Erreur de connexion');
        if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-flag-checkered"></i> Terminer la mission'; }
    }
}

// ============================================================
// QCM selection
// ============================================================
function selectQCM(li) {
    if (li.classList.contains('locked')) return;
    const list = li.parentElement;
    const isMultiple = list.dataset.multiple === 'true';
    if (!isMultiple) {
        list.querySelectorAll('.qcm-option').forEach(o => o.classList.remove('selected'));
    }
    li.classList.toggle('selected');
}

// ============================================================
// Image click
// ============================================================
let imageClicks = {};
function handleImageClick(event, blockId) {
    if (questionLocked) return;
    const container = document.getElementById('img-click-' + blockId);
    const img = container.querySelector('img');
    const containerRect = container.getBoundingClientRect();
    const imgRect = img.getBoundingClientRect();
    // Offset of image within container
    const imgOffsetX = imgRect.left - containerRect.left;
    const imgOffsetY = imgRect.top - containerRect.top;
    // Convert to natural image dimensions for consistent validation
    const scaleX = (img.naturalWidth || imgRect.width) / imgRect.width;
    const scaleY = (img.naturalHeight || imgRect.height) / imgRect.height;
    const x = Math.round((event.clientX - imgRect.left) * scaleX);
    const y = Math.round((event.clientY - imgRect.top) * scaleY);
    const expected = parseInt(container.dataset.expected) || 1;
    const zones = JSON.parse(container.dataset.zones || '[]');

    if (!imageClicks[blockId]) imageClicks[blockId] = [];
    if (imageClicks[blockId].length >= expected) {
        // Reset ‚Äî remove all markers and restart
        container.querySelectorAll('.click-marker').forEach(m => m.remove());
        imageClicks[blockId] = [];
    }
    imageClicks[blockId].push({ x, y });

    const clickIdx = imageClicks[blockId].length - 1;
    const marker = document.createElement('div');
    marker.className = 'click-marker';
    // Display marker at display coordinates relative to container (not natural)
    const displayX = imgOffsetX + (x / scaleX);
    const displayY = imgOffsetY + (y / scaleY);
    marker.style.left = displayX + 'px';
    marker.style.top = displayY + 'px';
    const label = document.createElement('div');
    label.className = 'marker-label';
    label.textContent = zones[clickIdx] ? zones[clickIdx].label : (clickIdx + 1);
    marker.appendChild(label);
    container.appendChild(marker);

    // Update zone prompt to show next zone
    const nextIdx = imageClicks[blockId].length;
    const currentLabel = document.getElementById('zone-current-label-' + blockId);
    const counter = document.getElementById('zone-counter-' + blockId);
    const undoBtn = document.getElementById('btn-undo-' + blockId);

    if (currentLabel && counter) {
        if (nextIdx < expected && zones[nextIdx]) {
            currentLabel.textContent = zones[nextIdx].label;
            counter.textContent = `Zone ${nextIdx + 1} / ${expected}`;
        } else {
            currentLabel.textContent = 'Toutes les zones plac√©es !';
            currentLabel.style.color = '#10b981';
            counter.textContent = `${expected} / ${expected} ‚Äî Pr√™t √† valider`;
        }
    }

    // Show undo button if there are clicks
    if (undoBtn && imageClicks[blockId].length > 0) {
        undoBtn.style.display = 'flex';
    }
}

// ============================================================
// Draw correct zones on image
// ============================================================
function drawCorrectZones(blockId, zones) {
    const container = document.getElementById('img-click-' + blockId);
    if (!container) return;

    const img = container.querySelector('img');
    if (!img) return;

    const imgRect = img.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    // Offset of image within container (accounts for any padding/margin/centering)
    const imgOffsetX = imgRect.left - containerRect.left;
    const imgOffsetY = imgRect.top - containerRect.top;
    const scaleX = (img.naturalWidth || imgRect.width) / imgRect.width;
    const scaleY = (img.naturalHeight || imgRect.height) / imgRect.height;

    // Remove old correct zones
    container.querySelectorAll('.correct-zone-circle').forEach(c => c.remove());
    container.querySelectorAll('.correct-zone-label').forEach(c => c.remove());

    // Draw new correct zones
    zones.forEach((zone) => {
        let zonePoints = zone.points || [];
        const zoneRadius = zone.radius || 30;

        // Backward compat: zone with direct x/y instead of points array
        if (zonePoints.length === 0 && (zone.x != null || zone.y != null)) {
            zonePoints = [{ x: zone.x || 0, y: zone.y || 0 }];
        }

        zonePoints.forEach((pt) => {
            // Convert from natural image coords to display coords, adding image offset within container
            const displayX = imgOffsetX + (pt.x / scaleX);
            const displayY = imgOffsetY + (pt.y / scaleY);
            const displayRadius = (zoneRadius / scaleX);

            const zoneCircle = document.createElement('div');
            zoneCircle.className = 'correct-zone-circle';
            zoneCircle.style.position = 'absolute';
            zoneCircle.style.left = (displayX - displayRadius) + 'px';
            zoneCircle.style.top = (displayY - displayRadius) + 'px';
            zoneCircle.style.width = (displayRadius * 2) + 'px';
            zoneCircle.style.height = (displayRadius * 2) + 'px';
            zoneCircle.style.border = '2px solid #10b981';
            zoneCircle.style.borderRadius = '50%';
            zoneCircle.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
            zoneCircle.style.pointerEvents = 'none';
            zoneCircle.style.zIndex = '10';

            container.appendChild(zoneCircle);

            // Add label below first point of each zone
            if (zone.label) {
                const label = document.createElement('div');
                label.className = 'correct-zone-label';
                label.style.cssText = 'position:absolute;z-index:11;pointer-events:none;background:#10b981;color:#fff;font-size:0.7rem;font-weight:700;padding:1px 6px;border-radius:4px;white-space:nowrap;';
                label.style.left = (displayX - 20) + 'px';
                label.style.top = (displayY + displayRadius + 2) + 'px';
                label.textContent = zone.label;
                container.appendChild(label);
            }
        });
    });
}

// ============================================================
// Undo last click on image_position
// ============================================================
function undoLastClick(blockId) {
    const container = document.getElementById('img-click-' + blockId);
    if (!container) return;

    if (!imageClicks[blockId] || imageClicks[blockId].length === 0) return;

    // Remove last click
    imageClicks[blockId].pop();

    // Remove last marker
    const markers = container.querySelectorAll('.click-marker');
    if (markers.length > 0) {
        markers[markers.length - 1].remove();
    }

    // Update zone prompt
    const nextIdx = imageClicks[blockId].length;
    const expected = parseInt(container.dataset.expected) || 1;
    const zones = JSON.parse(container.dataset.zones || '[]');
    const currentLabel = document.getElementById('zone-current-label-' + blockId);
    const counter = document.getElementById('zone-counter-' + blockId);
    const undoBtn = document.getElementById('btn-undo-' + blockId);

    if (currentLabel && counter) {
        if (nextIdx < expected && zones[nextIdx]) {
            currentLabel.textContent = zones[nextIdx].label;
            counter.textContent = `Zone ${nextIdx + 1} / ${expected}`;
        } else if (nextIdx > 0) {
            currentLabel.textContent = zones[nextIdx - 1].label;
            counter.textContent = `Zone ${nextIdx} / ${expected}`;
        } else {
            currentLabel.textContent = zones[0] ? zones[0].label : '';
            counter.textContent = `Zone 1 / ${expected}`;
        }
    }

    // Hide undo button if no clicks left
    if (undoBtn && imageClicks[blockId].length === 0) {
        undoBtn.style.display = 'none';
    }
}

// ============================================================
// Sorting drag & drop ‚Äî ORDER mode
// ============================================================
document.querySelectorAll('.sorting-list[data-mode="order"]').forEach(list => {
    let dragEl = null;
    list.querySelectorAll('.sorting-item').forEach(item => {
        item.addEventListener('dragstart', function(e) {
            dragEl = this; this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        });
        item.addEventListener('dragend', function() {
            this.classList.remove('dragging'); dragEl = null;
        });
        item.addEventListener('dragover', function(e) { e.preventDefault(); });
        item.addEventListener('drop', function(e) {
            e.preventDefault();
            if (dragEl && dragEl !== this) {
                const parent = this.parentNode;
                const all = [...parent.children];
                const from = all.indexOf(dragEl);
                const to = all.indexOf(this);
                if (from < to) parent.insertBefore(dragEl, this.nextSibling);
                else parent.insertBefore(dragEl, this);
            }
        });
    });
});

// ============================================================
// Sorting drag & drop ‚Äî CATEGORIES mode
// ============================================================
let draggedCatItem = null;

function catDragStart(event) {
    draggedCatItem = event.target.closest('.sorting-item');
    if (draggedCatItem) {
        draggedCatItem.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', '');
    }
}
function catDragOver(event) { event.preventDefault(); event.currentTarget.classList.add('drag-over'); }
function catDragLeave(event) { event.currentTarget.classList.remove('drag-over'); }
function catDrop(event, blockId) {
    event.preventDefault();
    const zone = event.currentTarget;
    zone.classList.remove('drag-over');
    if (draggedCatItem) {
        const zoneItems = zone.querySelector('.zone-items');
        draggedCatItem.setAttribute('draggable', 'true');
        draggedCatItem.ondragstart = catDragStart;
        zoneItems.appendChild(draggedCatItem);
        draggedCatItem.classList.remove('dragging');
        draggedCatItem = null;
    }
}
document.querySelectorAll('.category-pool').forEach(pool => {
    pool.addEventListener('dragover', (e) => { e.preventDefault(); pool.style.borderColor = '#667eea'; });
    pool.addEventListener('dragleave', () => { pool.style.borderColor = '#e5e7eb'; });
    pool.addEventListener('drop', (e) => {
        e.preventDefault(); pool.style.borderColor = '#e5e7eb';
        if (draggedCatItem) {
            pool.querySelector('.pool-items').appendChild(draggedCatItem);
            draggedCatItem.classList.remove('dragging');
            draggedCatItem = null;
        }
    });
});

// ============================================================
// INTERACTIVE GRAPH ‚Äî improved rendering, no equation display
// ============================================================
let graphStates = {};
const graphConfigs = {};
{% for block in blocks_list %}
{% if block.block_type == 'graph' %}
graphConfigs['{{ block.id }}'] = {{ block.config_json|tojson }};
{% endif %}
{% endfor %}

function initInteractiveGraph(blockId, config) {
    const canvas = document.getElementById('graph-' + blockId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    if (config.question_type === 'find_expression') {
        // Static graph ‚Äî draw the correct curve, no draggable points
        graphStates[blockId] = { config, points: [], dragging: -1 };
        drawStaticGraph(blockId, config);
        return;
    }

    const isQuadratic = config.question_type === 'draw_quadratic';
    const numPoints = isQuadratic ? 3 : 2;
    const xRange = config.x_max - config.x_min;
    const defaultPoints = [];
    for (let i = 0; i < numPoints; i++) {
        const x = config.x_min + xRange * (i + 1) / (numPoints + 1);
        defaultPoints.push({ x: Math.round(x), y: 0 });
    }

    graphStates[blockId] = { config, points: defaultPoints, dragging: -1 };
    drawInteractiveGraph(blockId);

    canvas.style.cursor = 'pointer';
    canvas.addEventListener('mousedown', (e) => onGraphMouseDown(e, blockId));
    canvas.addEventListener('mousemove', (e) => onGraphMouseMove(e, blockId));
    canvas.addEventListener('mouseup', () => onGraphMouseUp(blockId));
    canvas.addEventListener('mouseleave', () => onGraphMouseUp(blockId));
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onGraphTouchStart(e, blockId); }, {passive: false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onGraphTouchMove(e, blockId); }, {passive: false});
    canvas.addEventListener('touchend', () => onGraphMouseUp(blockId));
}

function drawStaticGraph(blockId, config) {
    const canvas = document.getElementById('graph-' + blockId);
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const margin = 50;
    const c = config;

    // DPR scaling
    const dpr = window.devicePixelRatio || 1;
    if (!canvas.dataset.scaled) {
        canvas.dataset.scaled = '1';
        canvas.width = GRAPH_W * dpr;
        canvas.height = GRAPH_H * dpr;
        canvas.style.width = GRAPH_W + 'px';
        canvas.style.height = GRAPH_H + 'px';
        ctx.scale(dpr, dpr);
    }

    // We need graphToPixel which uses graphStates, so we set it up
    const s = graphStates[blockId];

    ctx.clearRect(0, 0, GRAPH_W * dpr, GRAPH_H * dpr);
    ctx.fillStyle = '#fafbfc';
    ctx.fillRect(0, 0, GRAPH_W, GRAPH_H);

    // Grid
    if (c.grid !== false) {
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
        for (let x = Math.ceil(c.x_min); x <= c.x_max; x++) {
            const p = graphToPixel(blockId, x, 0);
            ctx.beginPath(); ctx.moveTo(p.px, margin); ctx.lineTo(p.px, GRAPH_H - margin); ctx.stroke();
        }
        for (let y = Math.ceil(c.y_min); y <= c.y_max; y++) {
            const p = graphToPixel(blockId, 0, y);
            ctx.beginPath(); ctx.moveTo(margin, p.py); ctx.lineTo(GRAPH_W - margin, p.py); ctx.stroke();
        }
    }

    // Axes
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 2;
    const origin = graphToPixel(blockId, 0, 0);
    ctx.beginPath(); ctx.moveTo(margin, origin.py); ctx.lineTo(GRAPH_W - margin, origin.py); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.px, margin); ctx.lineTo(origin.px, GRAPH_H - margin); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#374151'; ctx.font = 'bold 14px Inter, system-ui, sans-serif';
    ctx.fillText(c.x_label || 'x', GRAPH_W - margin + 8, origin.py + 5);
    ctx.fillText(c.y_label || 'y', origin.px + 8, margin - 12);

    // Numbers
    ctx.font = '12px Inter, system-ui, sans-serif'; ctx.fillStyle = '#6b7280';
    for (let x = Math.ceil(c.x_min); x <= c.x_max; x++) {
        if (x === 0) continue;
        const p = graphToPixel(blockId, x, 0);
        ctx.textAlign = 'center'; ctx.fillText(x, p.px, origin.py + 18);
    }
    ctx.textAlign = 'right';
    for (let y = Math.ceil(c.y_min); y <= c.y_max; y++) {
        if (y === 0) continue;
        const p = graphToPixel(blockId, 0, y);
        ctx.fillText(y, origin.px - 8, p.py + 4);
    }
    ctx.textAlign = 'left';

    // Draw the correct curve
    const ca = c.correct_answer || {};
    let fn;
    if (c.find_type === 'quadratic') {
        const a = ca.a || 0, b = ca.b || 0, cc = ca.c || 0;
        fn = (x) => a*x*x + b*x + cc;
    } else {
        const a = ca.a || 0, b = ca.b || 0;
        fn = (x) => a*x + b;
    }

    ctx.strokeStyle = '#667eea'; ctx.lineWidth = 3;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); let started = false;
    const step = (c.x_max - c.x_min) / 400;
    for (let x = c.x_min; x <= c.x_max; x += step) {
        const y = fn(x);
        const p = graphToPixel(blockId, x, y);
        if (p.py < margin - 5 || p.py > GRAPH_H - margin + 5) { started = false; continue; }
        if (!started) { ctx.moveTo(p.px, p.py); started = true; }
        else ctx.lineTo(p.px, p.py);
    }
    ctx.stroke();
}

// Logical (CSS) dimensions for graph ‚Äî stored after DPR scaling
const GRAPH_W = 600, GRAPH_H = 500;

function graphToPixel(blockId, gx, gy) {
    const s = graphStates[blockId]; const c = s.config;
    const margin = 50; const gw = GRAPH_W - 2 * margin; const gh = GRAPH_H - 2 * margin;
    return {
        px: margin + ((gx - c.x_min) / (c.x_max - c.x_min)) * gw,
        py: GRAPH_H - margin - ((gy - c.y_min) / (c.y_max - c.y_min)) * gh
    };
}
function pixelToGraph(blockId, px, py) {
    const s = graphStates[blockId]; const c = s.config;
    const margin = 50; const gw = GRAPH_W - 2 * margin; const gh = GRAPH_H - 2 * margin;
    return {
        x: c.x_min + ((px - margin) / gw) * (c.x_max - c.x_min),
        y: c.y_min + ((GRAPH_H - margin - py) / gh) * (c.y_max - c.y_min)
    };
}

function drawInteractiveGraph(blockId) {
    const s = graphStates[blockId]; const c = s.config;
    const canvas = document.getElementById('graph-' + blockId);
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const margin = 50;

    // Use devicePixelRatio for sharp rendering
    const dpr = window.devicePixelRatio || 1;
    if (!canvas.dataset.scaled) {
        canvas.dataset.scaled = '1';
        canvas.width = GRAPH_W * dpr;
        canvas.height = GRAPH_H * dpr;
        canvas.style.width = GRAPH_W + 'px';
        canvas.style.height = GRAPH_H + 'px';
        ctx.scale(dpr, dpr);
    }

    const cw = GRAPH_W, ch = GRAPH_H;
    ctx.clearRect(0, 0, GRAPH_W * dpr, GRAPH_H * dpr);

    // Background
    ctx.fillStyle = '#fafbfc';
    ctx.fillRect(0, 0, cw, ch);

    // Grid
    if (c.grid !== false) {
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
        for (let x = Math.ceil(c.x_min); x <= c.x_max; x++) {
            const p = graphToPixel(blockId, x, 0);
            ctx.beginPath(); ctx.moveTo(p.px, margin); ctx.lineTo(p.px, ch - margin); ctx.stroke();
        }
        for (let y = Math.ceil(c.y_min); y <= c.y_max; y++) {
            const p = graphToPixel(blockId, 0, y);
            ctx.beginPath(); ctx.moveTo(margin, p.py); ctx.lineTo(cw - margin, p.py); ctx.stroke();
        }
    }

    // Axes
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 2;
    const origin = graphToPixel(blockId, 0, 0);
    ctx.beginPath(); ctx.moveTo(margin, origin.py); ctx.lineTo(cw - margin, origin.py); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.px, margin); ctx.lineTo(origin.px, ch - margin); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#374151'; ctx.font = 'bold 14px Inter, system-ui, sans-serif';
    ctx.fillText(c.x_label || 'x', cw - margin + 8, origin.py + 5);
    ctx.fillText(c.y_label || 'y', origin.px + 8, margin - 12);

    // Axis numbers
    ctx.font = '12px Inter, system-ui, sans-serif'; ctx.fillStyle = '#6b7280';
    for (let x = Math.ceil(c.x_min); x <= c.x_max; x++) {
        if (x === 0) continue;
        const p = graphToPixel(blockId, x, 0);
        ctx.textAlign = 'center';
        ctx.fillText(x, p.px, origin.py + 18);
    }
    ctx.textAlign = 'right';
    for (let y = Math.ceil(c.y_min); y <= c.y_max; y++) {
        if (y === 0) continue;
        const p = graphToPixel(blockId, 0, y);
        ctx.fillText(y, origin.px - 8, p.py + 4);
    }
    ctx.textAlign = 'left';

    // Compute function
    const pts = s.points; let fn = null;
    if (c.question_type === 'draw_quadratic' && pts.length >= 3) {
        const [p1, p2, p3] = pts;
        const det = (p1.x**2*(p2.x-p3.x) - p2.x**2*(p1.x-p3.x) + p3.x**2*(p1.x-p2.x));
        if (Math.abs(det) > 0.001) {
            const a = (p1.y*(p2.x-p3.x) - p2.y*(p1.x-p3.x) + p3.y*(p1.x-p2.x)) / det;
            const b = (p1.x**2*(p2.y-p3.y) - p2.x**2*(p1.y-p3.y) + p3.x**2*(p1.y-p2.y)) / det;
            const cc = (p1.x**2*(p2.x*p3.y-p3.x*p2.y) - p2.x**2*(p1.x*p3.y-p3.x*p1.y) + p3.x**2*(p1.x*p2.y-p2.x*p1.y)) / det;
            fn = (x) => a*x*x + b*x + cc;
        }
    } else if (pts.length >= 2) {
        const dx = pts[1].x - pts[0].x;
        if (Math.abs(dx) > 0.001) {
            const a = (pts[1].y - pts[0].y) / dx;
            const b = pts[0].y - a * pts[0].x;
            fn = (x) => a*x + b;
        }
    }

    // Draw curve (thicker, smoother)
    if (fn) {
        ctx.strokeStyle = '#667eea'; ctx.lineWidth = 3;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); let started = false;
        const step = (c.x_max - c.x_min) / 400;
        for (let x = c.x_min; x <= c.x_max; x += step) {
            const y = fn(x);
            const p = graphToPixel(blockId, x, y);
            if (p.py < margin - 5 || p.py > ch - margin + 5) { started = false; continue; }
            if (!started) { ctx.moveTo(p.px, p.py); started = true; }
            else ctx.lineTo(p.px, p.py);
        }
        ctx.stroke();
    }

    // Draw draggable points (bigger, more visible)
    pts.forEach((pt, i) => {
        const p = graphToPixel(blockId, pt.x, pt.y);
        // Glow
        ctx.fillStyle = (i === s.dragging ? 'rgba(220,38,38,0.2)' : 'rgba(16,185,129,0.2)');
        ctx.beginPath(); ctx.arc(p.px, p.py, 18, 0, Math.PI * 2); ctx.fill();
        // Point
        ctx.fillStyle = i === s.dragging ? '#dc2626' : '#10b981';
        ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(p.px, p.py, 12, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();
        // Letter
        ctx.fillStyle = 'white'; ctx.font = 'bold 12px Inter, system-ui, sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(String.fromCharCode(65 + i), p.px, p.py + 4);
        ctx.textAlign = 'left';
        // Coordinates
        ctx.fillStyle = '#1e1b4b'; ctx.font = 'bold 12px Inter, system-ui, sans-serif';
        ctx.fillText(`(${Math.round(pt.x*10)/10}, ${Math.round(pt.y*10)/10})`, p.px + 18, p.py - 6);
    });
}

function getCanvasCoords(e, blockId) {
    const canvas = document.getElementById('graph-' + blockId);
    const rect = canvas.getBoundingClientRect();
    const scaleX = GRAPH_W / rect.width;
    const scaleY = GRAPH_H / rect.height;
    return { px: (e.clientX - rect.left) * scaleX, py: (e.clientY - rect.top) * scaleY };
}
function onGraphMouseDown(e, blockId) {
    if (questionLocked) return;
    const s = graphStates[blockId]; const {px, py} = getCanvasCoords(e, blockId);
    for (let i = 0; i < s.points.length; i++) {
        const p = graphToPixel(blockId, s.points[i].x, s.points[i].y);
        if (Math.sqrt((px - p.px)**2 + (py - p.py)**2) < 25) { s.dragging = i; break; }
    }
}
function onGraphTouchStart(e, blockId) {
    if (questionLocked) return;
    const touch = e.touches[0];
    const canvas = document.getElementById('graph-' + blockId);
    const rect = canvas.getBoundingClientRect();
    const scaleX = GRAPH_W / rect.width;
    const scaleY = GRAPH_H / rect.height;
    const px = (touch.clientX - rect.left) * scaleX;
    const py = (touch.clientY - rect.top) * scaleY;
    const s = graphStates[blockId];
    for (let i = 0; i < s.points.length; i++) {
        const p = graphToPixel(blockId, s.points[i].x, s.points[i].y);
        if (Math.sqrt((px - p.px)**2 + (py - p.py)**2) < 30) { s.dragging = i; break; }
    }
}
function onGraphMouseMove(e, blockId) {
    const s = graphStates[blockId]; if (s.dragging < 0) return;
    const {px, py} = getCanvasCoords(e, blockId);
    const g = pixelToGraph(blockId, px, py);
    s.points[s.dragging].x = Math.round(g.x * 2) / 2;
    s.points[s.dragging].y = Math.round(g.y * 2) / 2;
    drawInteractiveGraph(blockId);
}
function onGraphTouchMove(e, blockId) {
    const s = graphStates[blockId]; if (s.dragging < 0) return;
    const touch = e.touches[0];
    const canvas = document.getElementById('graph-' + blockId);
    const rect = canvas.getBoundingClientRect();
    const scaleX = GRAPH_W / rect.width;
    const scaleY = GRAPH_H / rect.height;
    const g = pixelToGraph(blockId, (touch.clientX - rect.left) * scaleX, (touch.clientY - rect.top) * scaleY);
    s.points[s.dragging].x = Math.round(g.x * 2) / 2;
    s.points[s.dragging].y = Math.round(g.y * 2) / 2;
    drawInteractiveGraph(blockId);
}
function onGraphMouseUp(blockId) {
    const s = graphStates[blockId]; if (!s) return;
    s.dragging = -1; drawInteractiveGraph(blockId);
}

// ============================================================
// Draw correct curve on graph after wrong answer
// ============================================================
function drawCorrectCurveOnGraph(blockId) {
    const s = graphStates[blockId];
    if (!s) return;
    const c = s.config;
    const ca = c.correct_answer || {};
    const canvas = document.getElementById('graph-' + blockId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const margin = 50;

    // Build correct function
    let fn = null;
    if (c.question_type === 'draw_quadratic') {
        const a = ca.a || 0, b = ca.b || 0, cc = ca.c || 0;
        fn = (x) => a*x*x + b*x + cc;
    } else {
        const a = ca.a || 0, b = ca.b || 0;
        fn = (x) => a*x + b;
    }
    if (!fn) return;

    // Draw correct curve in green (dashed)
    ctx.save();
    ctx.strokeStyle = '#10b981';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.lineCap = 'round';
    ctx.beginPath();
    let started = false;
    const step = (c.x_max - c.x_min) / 400;
    for (let x = c.x_min; x <= c.x_max; x += step) {
        const y = fn(x);
        const p = graphToPixel(blockId, x, y);
        if (p.py < margin - 5 || p.py > GRAPH_H - margin + 5) { started = false; continue; }
        if (!started) { ctx.moveTo(p.px, p.py); started = true; }
        else ctx.lineTo(p.px, p.py);
    }
    ctx.stroke();
    ctx.restore();

    // Add "R√©ponse correcte" label
    const labelP = graphToPixel(blockId, c.x_max - 1, fn(c.x_max - 1));
    if (labelP.py > margin && labelP.py < GRAPH_H - margin) {
        ctx.save();
        ctx.fillStyle = '#10b981';
        ctx.font = 'bold 12px Inter, system-ui, sans-serif';
        ctx.fillText('R√©ponse correcte', labelP.px - 100, labelP.py - 10);
        ctx.restore();
    }
}

// ============================================================
// Init
// ============================================================
document.addEventListener('DOMContentLoaded', function() {
    if (totalQuestions > 0) showQuestion(0);
    // KaTeX auto-render for math expressions in questions
    if (window.renderMathInElement) {
        renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            throwOnError: false
        });
    }
});
</script>
<!-- KaTeX auto-render -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="if(window.renderMathInElement) renderMathInElement(document.body, {delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\\\(',right:'\\\\)',display:false},{left:'\\\\[',right:'\\\\]',display:true}],throwOnError:false});"></script>
{% endblock %}
