{% extends "base.html" %}

{% block title %}{{ exercise.title }} - Mission{% endblock %}

{% block extra_css %}
<style>
.solve-container { max-width: 800px; margin: 0 auto; padding: 1rem; }

.exercise-header {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    margin-bottom: 1.5rem;
}

.exercise-header h1 { margin: 0 0 0.5rem; font-size: 1.4rem; }
.exercise-header p { color: #6b7280; margin: 0 0 0.75rem; }

.exercise-meta {
    display: flex; gap: 1rem; flex-wrap: wrap;
    font-size: 0.85rem; color: #4b5563;
}
.exercise-meta span { display: flex; align-items: center; gap: 0.3rem; }

.block-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    margin-bottom: 1rem;
    border-left: 4px solid #667eea;
}

.block-card.correct { border-left-color: #10b981; background: #f0fdf4; }
.block-card.incorrect { border-left-color: #ef4444; background: #fef2f2; }

.block-card h3 {
    margin: 0 0 1rem;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.block-number {
    width: 28px; height: 28px;
    background: #667eea;
    color: white;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.8rem; font-weight: 700;
}

/* QCM */
.qcm-options { list-style: none; padding: 0; }
.qcm-option {
    padding: 0.75rem 1rem;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    margin-bottom: 0.5rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex; align-items: center; gap: 0.5rem;
}
.qcm-option:hover { border-color: #667eea; }
.qcm-option.selected { border-color: #667eea; background: #eef2ff; }
.qcm-option.correct-answer { border-color: #10b981; background: #dcfce7; }
.qcm-option.wrong-answer { border-color: #ef4444; background: #fef2f2; }

/* Answer input */
.answer-input {
    width: 100%;
    padding: 0.75rem;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    font-size: 1rem;
    font-family: inherit;
}
.answer-input:focus { outline: none; border-color: #667eea; }

/* Fill blank */
.fill-blank-text { line-height: 2.5; font-size: 1rem; }
.blank-input {
    display: inline-block;
    width: 100px;
    border: none;
    border-bottom: 2px solid #667eea;
    padding: 0.2rem 0.3rem;
    font-size: 1rem;
    font-family: inherit;
    text-align: center;
    background: #eef2ff;
    border-radius: 4px 4px 0 0;
}

/* Sorting */
.sorting-list { list-style: none; padding: 0; }
.sorting-item {
    padding: 0.75rem 1rem;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    margin-bottom: 0.5rem;
    cursor: grab;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: white;
    user-select: none;
}
.sorting-item:active { cursor: grabbing; }
.sorting-item i { color: #9ca3af; }

/* Category drop zones */
.category-zone {
    border: 2px dashed #d1d5db;
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 0.75rem;
    min-height: 60px;
    transition: all 0.2s;
}
.category-zone.drag-over { border-color: #667eea; background: #eef2ff; }
.category-zone h4 { margin: 0 0 0.5rem; font-size: 0.9rem; color: #4b5563; }

/* Image interactive */
.image-click-area {
    position: relative;
    display: inline-block;
    cursor: crosshair;
    max-width: 100%;
}
.image-click-area img { max-width: 100%; border-radius: 8px; }
.click-marker {
    position: absolute;
    width: 20px; height: 20px;
    background: #ef4444;
    border: 3px solid white;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    pointer-events: none;
}

/* Graph */
.graph-wrapper {
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    overflow: hidden;
    text-align: center;
}

/* Submit */
.submit-section {
    text-align: center;
    padding: 2rem;
}

.btn-submit {
    padding: 0.75rem 2rem;
    background: #10b981;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.2s;
}
.btn-submit:hover { background: #059669; transform: scale(1.02); }
.btn-submit:disabled { background: #9ca3af; cursor: not-allowed; transform: none; }

/* Results overlay */
.results-overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.6);
    display: flex; align-items: center; justify-content: center;
    z-index: 9000;
}

.results-card {
    background: white;
    border-radius: 20px;
    padding: 2.5rem;
    max-width: 450px;
    width: 90%;
    text-align: center;
}

.results-score {
    font-size: 3rem;
    font-weight: 900;
    margin: 1rem 0;
}

.results-score.good { color: #10b981; }
.results-score.medium { color: #f59e0b; }
.results-score.bad { color: #ef4444; }

.results-rewards {
    display: flex;
    justify-content: center;
    gap: 2rem;
    margin: 1.5rem 0;
}

.reward-item {
    text-align: center;
}

.reward-item .reward-value {
    font-size: 1.5rem;
    font-weight: 800;
}

.reward-item .reward-label {
    font-size: 0.8rem;
    color: #6b7280;
}

.btn-back {
    display: inline-block;
    padding: 0.6rem 1.5rem;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    text-decoration: none;
    font-family: inherit;
    margin-top: 1rem;
}
</style>
{% endblock %}

{% block content %}
<div class="solve-container">
    <div class="exercise-header">
        <a href="{{ url_for('student_auth.missions') }}" style="color:#667eea;font-size:0.85rem;">
            <i class="fas fa-arrow-left"></i> Retour aux missions
        </a>
        <h1>{{ exercise.title }}</h1>
        {% if exercise.description %}<p>{{ exercise.description }}</p>{% endif %}
        <div class="exercise-meta">
            {% if exercise.subject %}<span><i class="fas fa-book"></i> {{ exercise.subject }}</span>{% endif %}
            <span><i class="fas fa-star" style="color:#f59e0b;"></i> {{ exercise.total_points }} XP</span>
        </div>
    </div>

    {% if already_completed %}
    <div style="background:#ecfdf5;border:2px solid #10b981;border-radius:12px;padding:1rem 1.5rem;margin-bottom:1rem;">
        <strong style="color:#166534;"><i class="fas fa-check-circle"></i> Tu as déjà terminé cet exercice !</strong>
        <span style="color:#166534;">Score : {{ previous_attempt.score_percentage }}% — {{ previous_attempt.xp_earned }} XP gagnés</span>
    </div>
    {% endif %}

    <form id="exercise-form">
    {% for block in exercise.blocks.order_by('position') %}
    <div class="block-card" id="block-card-{{ block.id }}" data-block-id="{{ block.id }}">
        <h3>
            <span class="block-number">{{ loop.index }}</span>
            {{ block.title or 'Question ' ~ loop.index }}
        </h3>

        {% set c = block.config_json %}

        {% if block.block_type == 'qcm' %}
            {% if c.question %}<p>{{ c.question }}</p>{% endif %}
            <ul class="qcm-options" data-block="{{ block.id }}" data-multiple="{{ 'true' if c.multiple_answers else 'false' }}">
                {% for opt in c.options %}
                <li class="qcm-option" data-index="{{ loop.index0 }}" onclick="selectQCM(this)">
                    <input type="{{ 'checkbox' if c.multiple_answers else 'radio' }}"
                           name="qcm-{{ block.id }}" style="pointer-events:none;" {{ 'disabled' if already_completed }}>
                    <span>{{ opt.text }}</span>
                </li>
                {% endfor %}
            </ul>

        {% elif block.block_type == 'short_answer' %}
            {% if c.question %}<p>{{ c.question }}</p>{% endif %}
            <input class="answer-input" type="{{ 'number' if c.answer_type == 'number' else 'text' }}"
                data-block="{{ block.id }}" placeholder="Ta réponse..."
                {{ 'step=any' if c.answer_type == 'number' else '' }}
                {{ 'disabled' if already_completed }}>

        {% elif block.block_type == 'fill_blank' %}
            <div class="fill-blank-text" id="fill-blank-{{ block.id }}"></div>
            <script>
                (function() {
                    const template = {{ c.text_template|tojson }};
                    let blankIdx = 0;
                    const html = template.replace(/\{([^}]+)\}/g, function() {
                        const i = blankIdx++;
                        return `<input class="blank-input" type="text" data-block="{{ block.id }}" data-blank="${i}"
                            placeholder="..." {{ 'disabled' if already_completed }}>`;
                    });
                    document.getElementById('fill-blank-{{ block.id }}').innerHTML = html;
                })();
            </script>

        {% elif block.block_type == 'sorting' %}
            {% if c.mode == 'order' %}
                <p style="color:#6b7280;font-size:0.85rem;">Remets ces éléments dans le bon ordre (glisse pour réorganiser) :</p>
                <ul class="sorting-list" id="sorting-{{ block.id }}" data-block="{{ block.id }}">
                    {% for item in c['items'] %}
                    <li class="sorting-item" draggable="true" data-original-index="{{ loop.index0 }}">
                        <i class="fas fa-grip-vertical"></i> {{ item }}
                    </li>
                    {% endfor %}
                </ul>
            {% else %}
                <p style="color:#6b7280;font-size:0.85rem;">Classe ces éléments dans les bonnes catégories :</p>
                <!-- Simplified: just show categories with dropdowns -->
                {% for cat in c.categories %}
                <div class="category-zone" data-category="{{ loop.index0 }}">
                    <h4>{{ cat.name }}</h4>
                </div>
                {% endfor %}
                <div class="sorting-list" id="sorting-pool-{{ block.id }}">
                    {% for item in c['items'] %}
                    <div class="sorting-item" data-item-index="{{ loop.index0 }}">{{ item }}</div>
                    {% endfor %}
                </div>
            {% endif %}

        {% elif block.block_type == 'image_position' %}
            {% if c.image_url %}
            <p style="color:#6b7280;font-size:0.85rem;">Clique sur {{ c.zones|length }} zone(s) correcte(s) sur l'image :</p>
            <div class="image-click-area" id="img-click-{{ block.id }}" data-block="{{ block.id }}"
                 data-expected="{{ c.zones|length }}"
                 onclick="handleImageClick(event, '{{ block.id }}')">
                <img src="{{ c.image_url }}">
            </div>
            {% endif %}

        {% elif block.block_type == 'graph' %}
            <p style="color:#6b7280;font-size:0.85rem;">
                {% if c.question_type == 'draw_quadratic' %}
                    Déplace les <strong>3 points</strong> sur le graphique pour tracer la courbe quadratique demandée :
                {% else %}
                    Déplace les <strong>2 points</strong> sur le graphique pour tracer la droite demandée :
                {% endif %}
            </p>
            <div class="graph-wrapper" style="position:relative;display:inline-block;">
                <canvas id="graph-{{ block.id }}" width="500" height="400" style="display:block;"></canvas>
            </div>
            <div id="graph-equation-{{ block.id }}" style="text-align:center;padding:0.5rem;font-weight:600;color:#667eea;font-size:0.95rem;"></div>
            <script>
                (function() {
                    initInteractiveGraph('{{ block.id }}', {{ c|tojson }});
                })();
            </script>
        {% endif %}
    </div>
    {% endfor %}
    </form>

    {% if not already_completed %}
    <div class="submit-section">
        <button class="btn-submit" id="submit-btn" onclick="submitExercise()">
            <i class="fas fa-paper-plane"></i> Soumettre mes réponses
        </button>
    </div>
    {% endif %}
</div>

<!-- Results overlay (hidden) -->
<div class="results-overlay" id="results-overlay" style="display:none;">
    <div class="results-card">
        <h2>Mission terminée !</h2>
        <div class="results-score" id="results-score"></div>
        <div class="results-rewards">
            <div class="reward-item">
                <div class="reward-value" style="color:#f59e0b;" id="results-xp">0</div>
                <div class="reward-label">XP gagnés</div>
            </div>
            <div class="reward-item">
                <div class="reward-value" style="color:#fbbf24;" id="results-gold">0</div>
                <div class="reward-label">Or gagné</div>
            </div>
        </div>
        <p id="results-level" style="font-weight:600;color:#667eea;"></p>
        <a href="{{ url_for('student_auth.missions') }}" class="btn-back">
            <i class="fas fa-arrow-left"></i> Retour aux missions
        </a>
    </div>
</div>

<script>
// ============================================================
// INTERACTIVE GRAPH — Drag points to trace line/quadratic
// ============================================================
let graphStates = {};  // blockId -> {config, points, dragging}

function initInteractiveGraph(blockId, config) {
    const canvas = document.getElementById('graph-' + blockId);
    if (!canvas) return;
    const isQuadratic = config.question_type === 'draw_quadratic';
    const numPoints = isQuadratic ? 3 : 2;

    // Initial points spread across the graph
    const xRange = config.x_max - config.x_min;
    const defaultPoints = [];
    for (let i = 0; i < numPoints; i++) {
        const x = config.x_min + xRange * (i + 1) / (numPoints + 1);
        defaultPoints.push({ x: Math.round(x), y: 0 });
    }

    graphStates[blockId] = {
        config: config,
        points: defaultPoints,
        dragging: -1,
    };

    drawInteractiveGraph(blockId);

    // Mouse events
    canvas.style.cursor = 'pointer';
    canvas.addEventListener('mousedown', (e) => onGraphMouseDown(e, blockId));
    canvas.addEventListener('mousemove', (e) => onGraphMouseMove(e, blockId));
    canvas.addEventListener('mouseup', () => onGraphMouseUp(blockId));
    canvas.addEventListener('mouseleave', () => onGraphMouseUp(blockId));

    // Touch events for mobile
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onGraphTouchStart(e, blockId); }, {passive: false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onGraphTouchMove(e, blockId); }, {passive: false});
    canvas.addEventListener('touchend', () => onGraphMouseUp(blockId));

    updateGraphEquation(blockId);
}

function graphToPixel(blockId, gx, gy) {
    const s = graphStates[blockId];
    const c = s.config;
    const canvas = document.getElementById('graph-' + blockId);
    const margin = 40;
    const gw = canvas.width - 2 * margin;
    const gh = canvas.height - 2 * margin;
    return {
        px: margin + ((gx - c.x_min) / (c.x_max - c.x_min)) * gw,
        py: canvas.height - margin - ((gy - c.y_min) / (c.y_max - c.y_min)) * gh
    };
}

function pixelToGraph(blockId, px, py) {
    const s = graphStates[blockId];
    const c = s.config;
    const canvas = document.getElementById('graph-' + blockId);
    const margin = 40;
    const gw = canvas.width - 2 * margin;
    const gh = canvas.height - 2 * margin;
    return {
        x: c.x_min + ((px - margin) / gw) * (c.x_max - c.x_min),
        y: c.y_min + ((canvas.height - margin - py) / gh) * (c.y_max - c.y_min)
    };
}

function drawInteractiveGraph(blockId) {
    const s = graphStates[blockId];
    const c = s.config;
    const canvas = document.getElementById('graph-' + blockId);
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    const margin = 40;

    // Clear
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#fafbfc';
    ctx.fillRect(0, 0, w, h);

    // Grid
    if (c.grid !== false) {
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 0.5;
        for (let x = Math.ceil(c.x_min); x <= c.x_max; x++) {
            const p = graphToPixel(blockId, x, 0);
            ctx.beginPath(); ctx.moveTo(p.px, margin); ctx.lineTo(p.px, h - margin); ctx.stroke();
        }
        for (let y = Math.ceil(c.y_min); y <= c.y_max; y++) {
            const p = graphToPixel(blockId, 0, y);
            ctx.beginPath(); ctx.moveTo(margin, p.py); ctx.lineTo(w - margin, p.py); ctx.stroke();
        }
    }

    // Axes
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 2;
    const origin = graphToPixel(blockId, 0, 0);
    ctx.beginPath(); ctx.moveTo(margin, origin.py); ctx.lineTo(w - margin, origin.py); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.px, margin); ctx.lineTo(origin.px, h - margin); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#4b5563'; ctx.font = '12px Inter, sans-serif';
    ctx.fillText(c.x_label || 'x', w - margin + 5, origin.py + 4);
    ctx.fillText(c.y_label || 'y', origin.px + 5, margin - 8);

    // Axis numbers
    ctx.font = '10px Inter, sans-serif'; ctx.fillStyle = '#9ca3af';
    for (let x = Math.ceil(c.x_min); x <= c.x_max; x++) {
        if (x === 0) continue;
        const p = graphToPixel(blockId, x, 0);
        ctx.fillText(x, p.px - 4, origin.py + 14);
    }
    for (let y = Math.ceil(c.y_min); y <= c.y_max; y++) {
        if (y === 0) continue;
        const p = graphToPixel(blockId, 0, y);
        ctx.fillText(y, origin.px - 18, p.py + 4);
    }

    // Compute function from student's points
    const pts = s.points;
    let fn = null;
    if (c.question_type === 'draw_quadratic' && pts.length >= 3) {
        // Solve for ax²+bx+c through 3 points
        const [p1, p2, p3] = pts;
        const det = (p1.x**2*(p2.x - p3.x) - p2.x**2*(p1.x - p3.x) + p3.x**2*(p1.x - p2.x));
        if (Math.abs(det) > 0.001) {
            const a = (p1.y*(p2.x - p3.x) - p2.y*(p1.x - p3.x) + p3.y*(p1.x - p2.x)) / det;
            const b = (p1.x**2*(p2.y - p3.y) - p2.x**2*(p1.y - p3.y) + p3.x**2*(p1.y - p2.y)) / det;
            const cc = (p1.x**2*(p2.x*p3.y - p3.x*p2.y) - p2.x**2*(p1.x*p3.y - p3.x*p1.y) + p3.x**2*(p1.x*p2.y - p2.x*p1.y)) / det;
            fn = (x) => a*x*x + b*x + cc;
        }
    } else if (pts.length >= 2) {
        const dx = pts[1].x - pts[0].x;
        if (Math.abs(dx) > 0.001) {
            const a = (pts[1].y - pts[0].y) / dx;
            const b = pts[0].y - a * pts[0].x;
            fn = (x) => a*x + b;
        }
    }

    // Draw the curve/line
    if (fn) {
        ctx.strokeStyle = '#667eea'; ctx.lineWidth = 2.5;
        ctx.beginPath();
        let started = false;
        const step = (c.x_max - c.x_min) / 300;
        for (let x = c.x_min; x <= c.x_max; x += step) {
            const y = fn(x);
            const p = graphToPixel(blockId, x, y);
            if (p.py < margin || p.py > h - margin) { started = false; continue; }
            if (!started) { ctx.moveTo(p.px, p.py); started = true; }
            else { ctx.lineTo(p.px, p.py); }
        }
        ctx.stroke();
    }

    // Draw draggable points
    pts.forEach((pt, i) => {
        const p = graphToPixel(blockId, pt.x, pt.y);
        ctx.fillStyle = i === s.dragging ? '#dc2626' : '#10b981';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(p.px, p.py, 10, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();
        // Point label
        ctx.fillStyle = 'white'; ctx.font = 'bold 10px Inter, sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(String.fromCharCode(65 + i), p.px, p.py + 4); // A, B, C
        ctx.textAlign = 'left';
        // Coordinates
        ctx.fillStyle = '#374151'; ctx.font = '11px Inter, sans-serif';
        ctx.fillText(`(${Math.round(pt.x*10)/10}, ${Math.round(pt.y*10)/10})`, p.px + 14, p.py - 4);
    });
}

function getCanvasCoords(e, blockId) {
    const canvas = document.getElementById('graph-' + blockId);
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        px: (e.clientX - rect.left) * scaleX,
        py: (e.clientY - rect.top) * scaleY
    };
}

function onGraphMouseDown(e, blockId) {
    const s = graphStates[blockId];
    const {px, py} = getCanvasCoords(e, blockId);
    // Find closest point
    for (let i = 0; i < s.points.length; i++) {
        const p = graphToPixel(blockId, s.points[i].x, s.points[i].y);
        const dist = Math.sqrt((px - p.px)**2 + (py - p.py)**2);
        if (dist < 20) { s.dragging = i; break; }
    }
}

function onGraphTouchStart(e, blockId) {
    const touch = e.touches[0];
    const canvas = document.getElementById('graph-' + blockId);
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const px = (touch.clientX - rect.left) * scaleX;
    const py = (touch.clientY - rect.top) * scaleY;
    const s = graphStates[blockId];
    for (let i = 0; i < s.points.length; i++) {
        const p = graphToPixel(blockId, s.points[i].x, s.points[i].y);
        if (Math.sqrt((px - p.px)**2 + (py - p.py)**2) < 25) { s.dragging = i; break; }
    }
}

function onGraphMouseMove(e, blockId) {
    const s = graphStates[blockId];
    if (s.dragging < 0) return;
    const {px, py} = getCanvasCoords(e, blockId);
    const gCoords = pixelToGraph(blockId, px, py);
    // Snap to nearest 0.5
    s.points[s.dragging].x = Math.round(gCoords.x * 2) / 2;
    s.points[s.dragging].y = Math.round(gCoords.y * 2) / 2;
    drawInteractiveGraph(blockId);
    updateGraphEquation(blockId);
}

function onGraphTouchMove(e, blockId) {
    const s = graphStates[blockId];
    if (s.dragging < 0) return;
    const touch = e.touches[0];
    const canvas = document.getElementById('graph-' + blockId);
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const px = (touch.clientX - rect.left) * scaleX;
    const py = (touch.clientY - rect.top) * scaleY;
    const gCoords = pixelToGraph(blockId, px, py);
    s.points[s.dragging].x = Math.round(gCoords.x * 2) / 2;
    s.points[s.dragging].y = Math.round(gCoords.y * 2) / 2;
    drawInteractiveGraph(blockId);
    updateGraphEquation(blockId);
}

function onGraphMouseUp(blockId) {
    const s = graphStates[blockId];
    if (!s) return;
    s.dragging = -1;
    drawInteractiveGraph(blockId);
}

function updateGraphEquation(blockId) {
    const s = graphStates[blockId];
    const el = document.getElementById('graph-equation-' + blockId);
    if (!el) return;
    const pts = s.points;
    const c = s.config;

    if (c.question_type === 'draw_quadratic' && pts.length >= 3) {
        const det = (pts[0].x**2*(pts[1].x - pts[2].x) - pts[1].x**2*(pts[0].x - pts[2].x) + pts[2].x**2*(pts[0].x - pts[1].x));
        if (Math.abs(det) > 0.001) {
            const a = (pts[0].y*(pts[1].x - pts[2].x) - pts[1].y*(pts[0].x - pts[2].x) + pts[2].y*(pts[0].x - pts[1].x)) / det;
            const b = (pts[0].x**2*(pts[1].y - pts[2].y) - pts[1].x**2*(pts[0].y - pts[2].y) + pts[2].x**2*(pts[0].y - pts[1].y)) / det;
            const cc = (pts[0].x**2*(pts[1].x*pts[2].y - pts[2].x*pts[1].y) - pts[1].x**2*(pts[0].x*pts[2].y - pts[2].x*pts[0].y) + pts[2].x**2*(pts[0].x*pts[1].y - pts[1].x*pts[0].y)) / det;
            el.textContent = `f(x) = ${Math.round(a*100)/100}x\u00B2 + ${Math.round(b*100)/100}x + ${Math.round(cc*100)/100}`;
        } else {
            el.textContent = 'Déplace les points (positions invalides)';
        }
    } else if (pts.length >= 2) {
        const dx = pts[1].x - pts[0].x;
        if (Math.abs(dx) > 0.001) {
            const a = (pts[1].y - pts[0].y) / dx;
            const b = pts[0].y - a * pts[0].x;
            el.textContent = `f(x) = ${Math.round(a*100)/100}x + ${Math.round(b*100)/100}`;
        } else {
            el.textContent = 'Déplace les points (droite verticale)';
        }
    }
}

// QCM selection
function selectQCM(li) {
    const list = li.parentElement;
    const isMultiple = list.dataset.multiple === 'true';

    if (!isMultiple) {
        list.querySelectorAll('.qcm-option').forEach(o => {
            o.classList.remove('selected');
            o.querySelector('input').checked = false;
        });
    }
    li.classList.toggle('selected');
    li.querySelector('input').checked = li.classList.contains('selected');
}

// Image click
let imageClicks = {};
function handleImageClick(event, blockId) {
    const container = document.getElementById('img-click-' + blockId);
    const img = container.querySelector('img');
    const rect = img.getBoundingClientRect();
    const x = Math.round(event.clientX - rect.left);
    const y = Math.round(event.clientY - rect.top);
    const expected = parseInt(container.dataset.expected) || 1;

    if (!imageClicks[blockId]) imageClicks[blockId] = [];

    // Remove existing markers if at max
    if (imageClicks[blockId].length >= expected) {
        container.querySelectorAll('.click-marker').forEach(m => m.remove());
        imageClicks[blockId] = [];
    }

    imageClicks[blockId].push({ x, y });

    const marker = document.createElement('div');
    marker.className = 'click-marker';
    marker.style.left = x + 'px';
    marker.style.top = y + 'px';
    container.appendChild(marker);
}

// Sorting drag & drop
document.querySelectorAll('.sorting-list').forEach(list => {
    let dragEl = null;
    list.querySelectorAll('.sorting-item').forEach(item => {
        item.addEventListener('dragstart', function(e) {
            dragEl = this;
            this.style.opacity = '0.5';
        });
        item.addEventListener('dragend', function() {
            this.style.opacity = '1';
            dragEl = null;
        });
        item.addEventListener('dragover', function(e) { e.preventDefault(); });
        item.addEventListener('drop', function(e) {
            e.preventDefault();
            if (dragEl && dragEl !== this) {
                const parent = this.parentNode;
                const allItems = [...parent.children];
                const fromIdx = allItems.indexOf(dragEl);
                const toIdx = allItems.indexOf(this);
                if (fromIdx < toIdx) {
                    parent.insertBefore(dragEl, this.nextSibling);
                } else {
                    parent.insertBefore(dragEl, this);
                }
            }
        });
    });
});

// Submit exercise
async function submitExercise() {
    const btn = document.getElementById('submit-btn');
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Envoi...';

    const answers = {};

    document.querySelectorAll('.block-card').forEach(card => {
        const blockId = card.dataset.blockId;

        // QCM
        const qcmList = card.querySelector('.qcm-options');
        if (qcmList) {
            const selected = [...card.querySelectorAll('.qcm-option.selected')].map(o => parseInt(o.dataset.index));
            answers[blockId] = { selected };
        }

        // Short answer
        const ansInput = card.querySelector('.answer-input[data-block]');
        if (ansInput && !ansInput.dataset.axis) {
            answers[blockId] = { value: ansInput.value };
        }

        // Fill blank
        const blankInputs = card.querySelectorAll('.blank-input');
        if (blankInputs.length > 0) {
            const blanks = [...blankInputs].map(input => input.value);
            answers[blockId] = { blanks };
        }

        // Sorting
        const sortingList = card.querySelector('.sorting-list');
        if (sortingList) {
            const order = [...sortingList.children].map(li => parseInt(li.dataset.originalIndex));
            answers[blockId] = { order };
        }

        // Image clicks
        if (imageClicks[blockId]) {
            answers[blockId] = { clicks: imageClicks[blockId] };
        }

        // Graph (interactive points)
        if (graphStates[blockId]) {
            answers[blockId] = { points: graphStates[blockId].points };
        }
    });

    try {
        const res = await fetch(`/student/missions/{{ exercise.id }}/submit`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ answers }),
        });
        const data = await res.json();

        if (data.success) {
            // Show results
            const pct = data.percentage;
            const scoreEl = document.getElementById('results-score');
            scoreEl.textContent = pct + '%';
            scoreEl.className = 'results-score ' + (pct >= 80 ? 'good' : pct >= 50 ? 'medium' : 'bad');

            document.getElementById('results-xp').textContent = '+' + data.xp_earned;
            document.getElementById('results-gold').textContent = '+' + data.gold_earned;
            document.getElementById('results-level').textContent = 'Niveau ' + data.new_level;

            // Highlight correct/incorrect blocks
            (data.results || []).forEach(r => {
                const card = document.getElementById('block-card-' + r.block_id);
                if (card) card.classList.add(r.is_correct ? 'correct' : 'incorrect');
            });

            document.getElementById('results-overlay').style.display = 'flex';
        } else {
            alert(data.message || 'Erreur');
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-paper-plane"></i> Soumettre mes réponses';
        }
    } catch(e) {
        alert('Erreur de connexion');
        btn.disabled = false;
        btn.innerHTML = '<i class="fas fa-paper-plane"></i> Soumettre mes réponses';
    }
}
</script>
{% endblock %}
